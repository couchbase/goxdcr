// Code generated by mockery. DO NOT EDIT.

package mocks

import (
	context "context"

	grpc "google.golang.org/grpc"

	internal_xdcr_v1 "github.com/couchbase/goprotostellar/genproto/internal_xdcr_v1"
	mock "github.com/stretchr/testify/mock"
)

// XDCRClient is an autogenerated mock type for the XDCRClient type
type XDCRClient struct {
	mock.Mock
}

type XDCRClient_Expecter struct {
	mock *mock.Mock
}

func (_m *XDCRClient) EXPECT() *XDCRClient_Expecter {
	return &XDCRClient_Expecter{mock: &_m.Mock}
}

// CheckDocument provides a mock function with given fields: ctx, in, opts
func (_m *XDCRClient) CheckDocument(ctx context.Context, in *internal_xdcr_v1.CheckDocumentRequest, opts ...grpc.CallOption) (*internal_xdcr_v1.CheckDocumentResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CheckDocument")
	}

	var r0 *internal_xdcr_v1.CheckDocumentResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *internal_xdcr_v1.CheckDocumentRequest, ...grpc.CallOption) (*internal_xdcr_v1.CheckDocumentResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *internal_xdcr_v1.CheckDocumentRequest, ...grpc.CallOption) *internal_xdcr_v1.CheckDocumentResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*internal_xdcr_v1.CheckDocumentResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *internal_xdcr_v1.CheckDocumentRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// XDCRClient_CheckDocument_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CheckDocument'
type XDCRClient_CheckDocument_Call struct {
	*mock.Call
}

// CheckDocument is a helper method to define mock.On call
//   - ctx context.Context
//   - in *internal_xdcr_v1.CheckDocumentRequest
//   - opts ...grpc.CallOption
func (_e *XDCRClient_Expecter) CheckDocument(ctx interface{}, in interface{}, opts ...interface{}) *XDCRClient_CheckDocument_Call {
	return &XDCRClient_CheckDocument_Call{Call: _e.mock.On("CheckDocument",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *XDCRClient_CheckDocument_Call) Run(run func(ctx context.Context, in *internal_xdcr_v1.CheckDocumentRequest, opts ...grpc.CallOption)) *XDCRClient_CheckDocument_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*internal_xdcr_v1.CheckDocumentRequest), variadicArgs...)
	})
	return _c
}

func (_c *XDCRClient_CheckDocument_Call) Return(_a0 *internal_xdcr_v1.CheckDocumentResponse, _a1 error) *XDCRClient_CheckDocument_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *XDCRClient_CheckDocument_Call) RunAndReturn(run func(context.Context, *internal_xdcr_v1.CheckDocumentRequest, ...grpc.CallOption) (*internal_xdcr_v1.CheckDocumentResponse, error)) *XDCRClient_CheckDocument_Call {
	_c.Call.Return(run)
	return _c
}

// GetBucketInfo provides a mock function with given fields: ctx, in, opts
func (_m *XDCRClient) GetBucketInfo(ctx context.Context, in *internal_xdcr_v1.GetBucketInfoRequest, opts ...grpc.CallOption) (*internal_xdcr_v1.GetBucketInfoResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetBucketInfo")
	}

	var r0 *internal_xdcr_v1.GetBucketInfoResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *internal_xdcr_v1.GetBucketInfoRequest, ...grpc.CallOption) (*internal_xdcr_v1.GetBucketInfoResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *internal_xdcr_v1.GetBucketInfoRequest, ...grpc.CallOption) *internal_xdcr_v1.GetBucketInfoResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*internal_xdcr_v1.GetBucketInfoResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *internal_xdcr_v1.GetBucketInfoRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// XDCRClient_GetBucketInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBucketInfo'
type XDCRClient_GetBucketInfo_Call struct {
	*mock.Call
}

// GetBucketInfo is a helper method to define mock.On call
//   - ctx context.Context
//   - in *internal_xdcr_v1.GetBucketInfoRequest
//   - opts ...grpc.CallOption
func (_e *XDCRClient_Expecter) GetBucketInfo(ctx interface{}, in interface{}, opts ...interface{}) *XDCRClient_GetBucketInfo_Call {
	return &XDCRClient_GetBucketInfo_Call{Call: _e.mock.On("GetBucketInfo",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *XDCRClient_GetBucketInfo_Call) Run(run func(ctx context.Context, in *internal_xdcr_v1.GetBucketInfoRequest, opts ...grpc.CallOption)) *XDCRClient_GetBucketInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*internal_xdcr_v1.GetBucketInfoRequest), variadicArgs...)
	})
	return _c
}

func (_c *XDCRClient_GetBucketInfo_Call) Return(_a0 *internal_xdcr_v1.GetBucketInfoResponse, _a1 error) *XDCRClient_GetBucketInfo_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *XDCRClient_GetBucketInfo_Call) RunAndReturn(run func(context.Context, *internal_xdcr_v1.GetBucketInfoRequest, ...grpc.CallOption) (*internal_xdcr_v1.GetBucketInfoResponse, error)) *XDCRClient_GetBucketInfo_Call {
	_c.Call.Return(run)
	return _c
}

// GetClusterInfo provides a mock function with given fields: ctx, in, opts
func (_m *XDCRClient) GetClusterInfo(ctx context.Context, in *internal_xdcr_v1.GetClusterInfoRequest, opts ...grpc.CallOption) (*internal_xdcr_v1.GetClusterInfoResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetClusterInfo")
	}

	var r0 *internal_xdcr_v1.GetClusterInfoResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *internal_xdcr_v1.GetClusterInfoRequest, ...grpc.CallOption) (*internal_xdcr_v1.GetClusterInfoResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *internal_xdcr_v1.GetClusterInfoRequest, ...grpc.CallOption) *internal_xdcr_v1.GetClusterInfoResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*internal_xdcr_v1.GetClusterInfoResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *internal_xdcr_v1.GetClusterInfoRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// XDCRClient_GetClusterInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetClusterInfo'
type XDCRClient_GetClusterInfo_Call struct {
	*mock.Call
}

// GetClusterInfo is a helper method to define mock.On call
//   - ctx context.Context
//   - in *internal_xdcr_v1.GetClusterInfoRequest
//   - opts ...grpc.CallOption
func (_e *XDCRClient_Expecter) GetClusterInfo(ctx interface{}, in interface{}, opts ...interface{}) *XDCRClient_GetClusterInfo_Call {
	return &XDCRClient_GetClusterInfo_Call{Call: _e.mock.On("GetClusterInfo",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *XDCRClient_GetClusterInfo_Call) Run(run func(ctx context.Context, in *internal_xdcr_v1.GetClusterInfoRequest, opts ...grpc.CallOption)) *XDCRClient_GetClusterInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*internal_xdcr_v1.GetClusterInfoRequest), variadicArgs...)
	})
	return _c
}

func (_c *XDCRClient_GetClusterInfo_Call) Return(_a0 *internal_xdcr_v1.GetClusterInfoResponse, _a1 error) *XDCRClient_GetClusterInfo_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *XDCRClient_GetClusterInfo_Call) RunAndReturn(run func(context.Context, *internal_xdcr_v1.GetClusterInfoRequest, ...grpc.CallOption) (*internal_xdcr_v1.GetClusterInfoResponse, error)) *XDCRClient_GetClusterInfo_Call {
	_c.Call.Return(run)
	return _c
}

// GetDocument provides a mock function with given fields: ctx, in, opts
func (_m *XDCRClient) GetDocument(ctx context.Context, in *internal_xdcr_v1.GetDocumentRequest, opts ...grpc.CallOption) (*internal_xdcr_v1.GetDocumentResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetDocument")
	}

	var r0 *internal_xdcr_v1.GetDocumentResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *internal_xdcr_v1.GetDocumentRequest, ...grpc.CallOption) (*internal_xdcr_v1.GetDocumentResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *internal_xdcr_v1.GetDocumentRequest, ...grpc.CallOption) *internal_xdcr_v1.GetDocumentResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*internal_xdcr_v1.GetDocumentResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *internal_xdcr_v1.GetDocumentRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// XDCRClient_GetDocument_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDocument'
type XDCRClient_GetDocument_Call struct {
	*mock.Call
}

// GetDocument is a helper method to define mock.On call
//   - ctx context.Context
//   - in *internal_xdcr_v1.GetDocumentRequest
//   - opts ...grpc.CallOption
func (_e *XDCRClient_Expecter) GetDocument(ctx interface{}, in interface{}, opts ...interface{}) *XDCRClient_GetDocument_Call {
	return &XDCRClient_GetDocument_Call{Call: _e.mock.On("GetDocument",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *XDCRClient_GetDocument_Call) Run(run func(ctx context.Context, in *internal_xdcr_v1.GetDocumentRequest, opts ...grpc.CallOption)) *XDCRClient_GetDocument_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*internal_xdcr_v1.GetDocumentRequest), variadicArgs...)
	})
	return _c
}

func (_c *XDCRClient_GetDocument_Call) Return(_a0 *internal_xdcr_v1.GetDocumentResponse, _a1 error) *XDCRClient_GetDocument_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *XDCRClient_GetDocument_Call) RunAndReturn(run func(context.Context, *internal_xdcr_v1.GetDocumentRequest, ...grpc.CallOption) (*internal_xdcr_v1.GetDocumentResponse, error)) *XDCRClient_GetDocument_Call {
	_c.Call.Return(run)
	return _c
}

// GetVbucketInfo provides a mock function with given fields: ctx, in, opts
func (_m *XDCRClient) GetVbucketInfo(ctx context.Context, in *internal_xdcr_v1.GetVbucketInfoRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[internal_xdcr_v1.GetVbucketInfoResponse], error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetVbucketInfo")
	}

	var r0 grpc.ServerStreamingClient[internal_xdcr_v1.GetVbucketInfoResponse]
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *internal_xdcr_v1.GetVbucketInfoRequest, ...grpc.CallOption) (grpc.ServerStreamingClient[internal_xdcr_v1.GetVbucketInfoResponse], error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *internal_xdcr_v1.GetVbucketInfoRequest, ...grpc.CallOption) grpc.ServerStreamingClient[internal_xdcr_v1.GetVbucketInfoResponse]); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(grpc.ServerStreamingClient[internal_xdcr_v1.GetVbucketInfoResponse])
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *internal_xdcr_v1.GetVbucketInfoRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// XDCRClient_GetVbucketInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetVbucketInfo'
type XDCRClient_GetVbucketInfo_Call struct {
	*mock.Call
}

// GetVbucketInfo is a helper method to define mock.On call
//   - ctx context.Context
//   - in *internal_xdcr_v1.GetVbucketInfoRequest
//   - opts ...grpc.CallOption
func (_e *XDCRClient_Expecter) GetVbucketInfo(ctx interface{}, in interface{}, opts ...interface{}) *XDCRClient_GetVbucketInfo_Call {
	return &XDCRClient_GetVbucketInfo_Call{Call: _e.mock.On("GetVbucketInfo",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *XDCRClient_GetVbucketInfo_Call) Run(run func(ctx context.Context, in *internal_xdcr_v1.GetVbucketInfoRequest, opts ...grpc.CallOption)) *XDCRClient_GetVbucketInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*internal_xdcr_v1.GetVbucketInfoRequest), variadicArgs...)
	})
	return _c
}

func (_c *XDCRClient_GetVbucketInfo_Call) Return(_a0 grpc.ServerStreamingClient[internal_xdcr_v1.GetVbucketInfoResponse], _a1 error) *XDCRClient_GetVbucketInfo_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *XDCRClient_GetVbucketInfo_Call) RunAndReturn(run func(context.Context, *internal_xdcr_v1.GetVbucketInfoRequest, ...grpc.CallOption) (grpc.ServerStreamingClient[internal_xdcr_v1.GetVbucketInfoResponse], error)) *XDCRClient_GetVbucketInfo_Call {
	_c.Call.Return(run)
	return _c
}

// Heartbeat provides a mock function with given fields: ctx, in, opts
func (_m *XDCRClient) Heartbeat(ctx context.Context, in *internal_xdcr_v1.HeartbeatRequest, opts ...grpc.CallOption) (*internal_xdcr_v1.HeartbeatResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Heartbeat")
	}

	var r0 *internal_xdcr_v1.HeartbeatResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *internal_xdcr_v1.HeartbeatRequest, ...grpc.CallOption) (*internal_xdcr_v1.HeartbeatResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *internal_xdcr_v1.HeartbeatRequest, ...grpc.CallOption) *internal_xdcr_v1.HeartbeatResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*internal_xdcr_v1.HeartbeatResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *internal_xdcr_v1.HeartbeatRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// XDCRClient_Heartbeat_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Heartbeat'
type XDCRClient_Heartbeat_Call struct {
	*mock.Call
}

// Heartbeat is a helper method to define mock.On call
//   - ctx context.Context
//   - in *internal_xdcr_v1.HeartbeatRequest
//   - opts ...grpc.CallOption
func (_e *XDCRClient_Expecter) Heartbeat(ctx interface{}, in interface{}, opts ...interface{}) *XDCRClient_Heartbeat_Call {
	return &XDCRClient_Heartbeat_Call{Call: _e.mock.On("Heartbeat",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *XDCRClient_Heartbeat_Call) Run(run func(ctx context.Context, in *internal_xdcr_v1.HeartbeatRequest, opts ...grpc.CallOption)) *XDCRClient_Heartbeat_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*internal_xdcr_v1.HeartbeatRequest), variadicArgs...)
	})
	return _c
}

func (_c *XDCRClient_Heartbeat_Call) Return(_a0 *internal_xdcr_v1.HeartbeatResponse, _a1 error) *XDCRClient_Heartbeat_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *XDCRClient_Heartbeat_Call) RunAndReturn(run func(context.Context, *internal_xdcr_v1.HeartbeatRequest, ...grpc.CallOption) (*internal_xdcr_v1.HeartbeatResponse, error)) *XDCRClient_Heartbeat_Call {
	_c.Call.Return(run)
	return _c
}

// PushDocument provides a mock function with given fields: ctx, in, opts
func (_m *XDCRClient) PushDocument(ctx context.Context, in *internal_xdcr_v1.PushDocumentRequest, opts ...grpc.CallOption) (*internal_xdcr_v1.PushDocumentResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PushDocument")
	}

	var r0 *internal_xdcr_v1.PushDocumentResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *internal_xdcr_v1.PushDocumentRequest, ...grpc.CallOption) (*internal_xdcr_v1.PushDocumentResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *internal_xdcr_v1.PushDocumentRequest, ...grpc.CallOption) *internal_xdcr_v1.PushDocumentResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*internal_xdcr_v1.PushDocumentResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *internal_xdcr_v1.PushDocumentRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// XDCRClient_PushDocument_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PushDocument'
type XDCRClient_PushDocument_Call struct {
	*mock.Call
}

// PushDocument is a helper method to define mock.On call
//   - ctx context.Context
//   - in *internal_xdcr_v1.PushDocumentRequest
//   - opts ...grpc.CallOption
func (_e *XDCRClient_Expecter) PushDocument(ctx interface{}, in interface{}, opts ...interface{}) *XDCRClient_PushDocument_Call {
	return &XDCRClient_PushDocument_Call{Call: _e.mock.On("PushDocument",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *XDCRClient_PushDocument_Call) Run(run func(ctx context.Context, in *internal_xdcr_v1.PushDocumentRequest, opts ...grpc.CallOption)) *XDCRClient_PushDocument_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*internal_xdcr_v1.PushDocumentRequest), variadicArgs...)
	})
	return _c
}

func (_c *XDCRClient_PushDocument_Call) Return(_a0 *internal_xdcr_v1.PushDocumentResponse, _a1 error) *XDCRClient_PushDocument_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *XDCRClient_PushDocument_Call) RunAndReturn(run func(context.Context, *internal_xdcr_v1.PushDocumentRequest, ...grpc.CallOption) (*internal_xdcr_v1.PushDocumentResponse, error)) *XDCRClient_PushDocument_Call {
	_c.Call.Return(run)
	return _c
}

// WatchCollections provides a mock function with given fields: ctx, in, opts
func (_m *XDCRClient) WatchCollections(ctx context.Context, in *internal_xdcr_v1.WatchCollectionsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[internal_xdcr_v1.WatchCollectionsResponse], error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for WatchCollections")
	}

	var r0 grpc.ServerStreamingClient[internal_xdcr_v1.WatchCollectionsResponse]
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *internal_xdcr_v1.WatchCollectionsRequest, ...grpc.CallOption) (grpc.ServerStreamingClient[internal_xdcr_v1.WatchCollectionsResponse], error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *internal_xdcr_v1.WatchCollectionsRequest, ...grpc.CallOption) grpc.ServerStreamingClient[internal_xdcr_v1.WatchCollectionsResponse]); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(grpc.ServerStreamingClient[internal_xdcr_v1.WatchCollectionsResponse])
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *internal_xdcr_v1.WatchCollectionsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// XDCRClient_WatchCollections_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WatchCollections'
type XDCRClient_WatchCollections_Call struct {
	*mock.Call
}

// WatchCollections is a helper method to define mock.On call
//   - ctx context.Context
//   - in *internal_xdcr_v1.WatchCollectionsRequest
//   - opts ...grpc.CallOption
func (_e *XDCRClient_Expecter) WatchCollections(ctx interface{}, in interface{}, opts ...interface{}) *XDCRClient_WatchCollections_Call {
	return &XDCRClient_WatchCollections_Call{Call: _e.mock.On("WatchCollections",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *XDCRClient_WatchCollections_Call) Run(run func(ctx context.Context, in *internal_xdcr_v1.WatchCollectionsRequest, opts ...grpc.CallOption)) *XDCRClient_WatchCollections_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*internal_xdcr_v1.WatchCollectionsRequest), variadicArgs...)
	})
	return _c
}

func (_c *XDCRClient_WatchCollections_Call) Return(_a0 grpc.ServerStreamingClient[internal_xdcr_v1.WatchCollectionsResponse], _a1 error) *XDCRClient_WatchCollections_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *XDCRClient_WatchCollections_Call) RunAndReturn(run func(context.Context, *internal_xdcr_v1.WatchCollectionsRequest, ...grpc.CallOption) (grpc.ServerStreamingClient[internal_xdcr_v1.WatchCollectionsResponse], error)) *XDCRClient_WatchCollections_Call {
	_c.Call.Return(run)
	return _c
}

// NewXDCRClient creates a new instance of XDCRClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewXDCRClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *XDCRClient {
	mock := &XDCRClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
