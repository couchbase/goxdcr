// Code generated by mockery. DO NOT EDIT.

package mocks

import (
	log "github.com/couchbase/goxdcr/v8/log"
	metadata "github.com/couchbase/goxdcr/v8/metadata"

	mock "github.com/stretchr/testify/mock"
)

// baseConfigInjector is an autogenerated mock type for the baseConfigInjector type
type baseConfigInjector struct {
	mock.Mock
}

type baseConfigInjector_Expecter struct {
	mock *mock.Mock
}

func (_m *baseConfigInjector) EXPECT() *baseConfigInjector_Expecter {
	return &baseConfigInjector_Expecter{mock: &_m.Mock}
}

// InitInjector provides a mock function with given fields: cfg, settings
func (_m *baseConfigInjector) InitInjector(cfg *parts.baseConfig, settings metadata.ReplicationSettingsMap) {
	_m.Called(cfg, settings)
}

// baseConfigInjector_InitInjector_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InitInjector'
type baseConfigInjector_InitInjector_Call struct {
	*mock.Call
}

// InitInjector is a helper method to define mock.On call
//   - cfg *parts.baseConfig
//   - settings metadata.ReplicationSettingsMap
func (_e *baseConfigInjector_Expecter) InitInjector(cfg interface{}, settings interface{}) *baseConfigInjector_InitInjector_Call {
	return &baseConfigInjector_InitInjector_Call{Call: _e.mock.On("InitInjector", cfg, settings)}
}

func (_c *baseConfigInjector_InitInjector_Call) Run(run func(cfg *parts.baseConfig, settings metadata.ReplicationSettingsMap)) *baseConfigInjector_InitInjector_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*parts.baseConfig), args[1].(metadata.ReplicationSettingsMap))
	})
	return _c
}

func (_c *baseConfigInjector_InitInjector_Call) Return() *baseConfigInjector_InitInjector_Call {
	_c.Call.Return()
	return _c
}

func (_c *baseConfigInjector_InitInjector_Call) RunAndReturn(run func(*parts.baseConfig, metadata.ReplicationSettingsMap)) *baseConfigInjector_InitInjector_Call {
	_c.Run(run)
	return _c
}

// Update provides a mock function with given fields: config, settings, logger, id
func (_m *baseConfigInjector) Update(config *parts.baseConfig, settings metadata.ReplicationSettingsMap, logger *log.CommonLogger, id string) {
	_m.Called(config, settings, logger, id)
}

// baseConfigInjector_Update_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Update'
type baseConfigInjector_Update_Call struct {
	*mock.Call
}

// Update is a helper method to define mock.On call
//   - config *parts.baseConfig
//   - settings metadata.ReplicationSettingsMap
//   - logger *log.CommonLogger
//   - id string
func (_e *baseConfigInjector_Expecter) Update(config interface{}, settings interface{}, logger interface{}, id interface{}) *baseConfigInjector_Update_Call {
	return &baseConfigInjector_Update_Call{Call: _e.mock.On("Update", config, settings, logger, id)}
}

func (_c *baseConfigInjector_Update_Call) Run(run func(config *parts.baseConfig, settings metadata.ReplicationSettingsMap, logger *log.CommonLogger, id string)) *baseConfigInjector_Update_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*parts.baseConfig), args[1].(metadata.ReplicationSettingsMap), args[2].(*log.CommonLogger), args[3].(string))
	})
	return _c
}

func (_c *baseConfigInjector_Update_Call) Return() *baseConfigInjector_Update_Call {
	_c.Call.Return()
	return _c
}

func (_c *baseConfigInjector_Update_Call) RunAndReturn(run func(*parts.baseConfig, metadata.ReplicationSettingsMap, *log.CommonLogger, string)) *baseConfigInjector_Update_Call {
	_c.Run(run)
	return _c
}

// newBaseConfigInjector creates a new instance of baseConfigInjector. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func newBaseConfigInjector(t interface {
	mock.TestingT
	Cleanup(func())
}) *baseConfigInjector {
	mock := &baseConfigInjector{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
