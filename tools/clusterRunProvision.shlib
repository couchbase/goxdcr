#!/usr/bin/env bash
set -u

# Copyright (c) 2019 Couchbase, Inc.
# Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file
# except in compliance with the License. You may obtain a copy of the License at
#   http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software distributed under the
# License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
# either express or implied. See the License for the specific language governing permissions
# and limitations under the License.

# BASH VERSION CHECK - since hash maps are implemented >= bash version 4
bash_major_version=`echo ${BASH_VERSION}|cut -d. -f1`
if (( $bash_major_version < 4 ));then
	echo "===================================================================="
	echo "Bash version >= 4 is required. Current bash version: ${BASH_VERSION}. Script may fail"
	echo "How to upgrade bash on MacOS:"
	echo "1. Run \"brew update && brew install bash\" to install the latest version of bash for macOS"
	echo "2. Run \"sudo vim /etc/shells\" and add \"/usr/local/bin/bash\" to the list"
	echo "3. Run \"chsh -s /usr/local/bin/bash\" to set default shell to the new one"
	echo "4. Exit and restart the current session"
	echo "===================================================================="
	return 1
fi

. ./importExporter.shlib

# globals
# -----------------
declare DEFAULT_ADMIN
declare DEFAULT_PW
# Run curl in silent mode to prevent progress bar
CURL="curl -s"
POOLS_DEFAULT_BUCKETS_PATH="pools/default/buckets"

# topological globals
# -----------------
# cluster -> Bucket(s)
# Bucket -> Scopes
# Scopes -> Collections
declare -A CLUSTER_NAME_PORT_MAP
declare -A CLUSTER_NAME_XDCR_PORT_MAP
declare -A CLUSTER_NAME_BUCKET_MAP
declare -A BUCKET_NAME_RAMQUOTA_MAP
declare -A BUCKET_NAME_SCOPE_MAP
declare -A SCOPE_NAME_COLLECTION_MAP
declare -A BUCKET_PROPERTIES_OUTPUT_MAP
declare -A BUCKET_REPL_PROPERTIES_MAP
declare -A BUCKET_REPL_PROPERTIES_OUTPUT_MAP
declare -A BUCKET_REPL_EXPORT_MAP

# optional globals
# -----------------
# if not defined, will look for it using locate
declare CBWORKLOADGEN=""
# Key is in the format of "BucketName,ParameterName"
# Value is in the format of actual value to send
declare -A BUCKET_NAME_PROPERTIES_MAP

# Input:
# 1. Bucket name
# 2. An associative array of Key - Parameter Value - value to send
# Will store information as:
# BUCKET_NAME_PROPERTIES_MAP=([B1,CompressionMode]="Active" [B1,ramQuotaMB]="100" )
function insertPropertyIntoBucketNamePropertyMap {
	local bucketName=$1
	local -n incomingMap=$2
	for key in ${!incomingMap[@]}
	do
		BUCKET_NAME_PROPERTIES_MAP[${bucketName},${key}]=${incomingMap[$key]}
	done
	export BUCKET_NAME_PROPERTIES_MAP
}

function cleanupBucketNamePropertyMap {
	BUCKET_NAME_PROPERTIES_MAP=()
}

# Input:
# 1. Bucket name
# Outputs associative array as a exported global of BUCKET_PROPERTIES_OUTPUT_MAP
function getPropertiesFromBucketNamePropertyMap {
	local bucketName=$1

	# first clear previous data - cannot use unset as it breaks the return val
	BUCKET_PROPERTIES_OUTPUT_MAP=()

	# key is bucketName,Property
	for bp in ${!BUCKET_NAME_PROPERTIES_MAP[@]}
	do
		key=`echo "$bp" | cut -d, -f1`
		property=`echo "$bp" | cut -d, -f2`
		if [[ $key != $bucketName ]];then
			continue
		fi
		BUCKET_PROPERTIES_OUTPUT_MAP["$property"]=${BUCKET_NAME_PROPERTIES_MAP[$bp]}
	done
	export BUCKET_PROPERTIES_OUTPUT_MAP
}

# Input:
# 1. Source Cluster name
# 2. Source Bucket name
# 3. Target Cluster name
# 4. Target Cluster name
# 2. An associative array of Key - Parameter Value - value to send
function insertPropertyIntoBucketReplPropertyMap {
	local sourceCluster=$1
	local sourceBucket=$2
	local targetCluster=$3
	local targetBucket=$4
	local -n incomingMap=$5

	for key in ${!incomingMap[@]}
	do
		BUCKET_REPL_PROPERTIES_MAP[${sourceCluster},${sourceBucket},${targetCluster},${targetBucket},${key}]=${incomingMap[$key]}
	done
	export BUCKET_REPL_PROPERTIES_MAP
}

# Input:
# 1. Source Cluster name
# 2. Source Bucket name
# 3. Target Cluster name
# 4. Target Cluster name
# 2. An associative array of Key - Parameter Value - value to send
function insertBucketReplIntoExportMap {
	local sourceCluster=$1
	local sourceBucket=$2
	local targetCluster=$3
	local targetBucket=$4
	local replRestID=$5

	BUCKET_REPL_EXPORT_MAP[${sourceCluster},${sourceBucket},${targetCluster},${targetBucket}]=${replRestID}
	export BUCKET_REPL_EXPORT_MAP
}


# Input:
# 1. Source Cluster name
# 2. Source Bucket name
# 3. Target Cluster name
# 4. Target Cluster name
function getPropertiesFromBucketReplPropertyMap {
	local sourceCluster=$1
	local sourceBucket=$2
	local targetCluster=$3
	local targetBucket=$4
	
	local checkString="${sourceCluster},${sourceBucket},${targetCluster},${targetBucket}"
	# key is bucketName,Property
	for bp in ${!BUCKET_REPL_PROPERTIES_MAP[@]}
	do
		key=`echo "$bp" | cut -d, -f1-4`
		property=`echo "$bp" | cut -d, -f5`
		if [[ $key != $checkString ]];then
			continue
		fi
		BUCKET_REPL_PROPERTIES_OUTPUT_MAP["$property"]=${BUCKET_REPL_PROPERTIES_MAP[$bp]}
	done
}



function printBucketPropertiesResults {
	declare -p BUCKET_PROPERTIES_OUTPUT_MAP | cut -d' ' -f3- | cut -d'=' -f2-
}

function printBucketReplPropertiesResults {
	declare -p BUCKET_REPL_PROPERTIES_OUTPUT_MAP | cut -d' ' -f3- | cut -d= -f2-
}

declare -a getBucketOutArr
function getBucketPropertiesRESTString {
	getBucketOutArr=()
	for property in "${!BUCKET_PROPERTIES_OUTPUT_MAP[@]}"
	do
		getBucketOutArr+=("-d")
		getBucketOutArr+=("${property}=${BUCKET_PROPERTIES_OUTPUT_MAP[$property]}")
	done
}

declare -a getBucketReplOutArr
function getBucketReplPropertiesRESTString {
	getBucketReplOutArr=()
	for property in "${!BUCKET_REPL_PROPERTIES_OUTPUT_MAP[@]}"
	do
		getBucketReplOutArr+=("-d")
		getBucketReplOutArr+=("${property}=${BUCKET_REPL_PROPERTIES_OUTPUT_MAP[$property]}")
	done
}

function getBucketInfoRaw {
	local clusterName=$1
	local bucketName=$2
	local port=${CLUSTER_NAME_PORT_MAP[$clusterName]:-}

	$CURL -u $DEFAULT_ADMIN:$DEFAULT_PW -X GET http://localhost:$port/$POOLS_DEFAULT_BUCKETS_PATH/$bucketName
}

function getBucketInfo {
	local clusterName=$1
	local bucketName=$2

	if (( `checkJQ` != 0 ));then
		getBucketInfoRaw $clusterName $bucketName
	else
		echo `getBucketInfoRaw $clusterName $bucketName` | jq
	fi
}

function getBucketItemCount {
	local clusterName=$1
	local bucketName=$2
	local maxRetry=3

	if (( `checkJQ` != 0 ));then
		echo "Cannot run $0 without jq"
		return 1
	fi

	for (( i=0; $i < $maxRetry; i=$(($i+1)) ))
	do
		rawOutput=`getBucketInfoRaw $clusterName $bucketName`
		if (( $? != 0 ));then
			continue
		fi
		basicStats=`echo "$rawOutput" | jq '.basicStats'`
		if (( $? != 0 ));then
			continue
		fi
		itemCount=`echo "$basicStats" | jq '.itemCount'`
		if (( $? == 0 ));then
			echo "$itemCount"
			break
		fi
	done
}

# Tests and see if "cluster_run -n x" has been run
function testForClusterRun {
	for port in ${CLUSTER_NAME_PORT_MAP[@]}
		do
		$CURL -u $DEFAULT_ADMIN:$DEFAULT_PW -X GET http://localhost:$port/nodes/self/controller/settings > /dev/null 2>&1
		if (( $? != 0 ));then
			echo "Node $port not found. Skipping cluster_run XDCR init"
			return 1
		fi
	done
}

function setupCluster {
	for clusterName in `echo ${!CLUSTER_NAME_PORT_MAP[@]}`
	do
		local port=${CLUSTER_NAME_PORT_MAP[$clusterName]:-}
		echo "SETTING up cluster name $clusterName on port $port"
		$CURL -u $DEFAULT_ADMIN:$DEFAULT_PW -X POST http://localhost:$port/nodes/self/controller/settings > /dev/null 2>&1
		$CURL -X POST http://localhost:$port/node/controller/rename -d hostname=127.0.0.1 > /dev/null 2>&1
		$CURL -X POST http://localhost:$port/node/controller/setupServices -d services=kv > /dev/null 2>&1
		$CURL -u $DEFAULT_ADMIN:$DEFAULT_PW -v -X POST http://localhost:$port/settings/web -d password=$DEFAULT_PW -d username=$DEFAULT_ADMIN -d port=$port > /dev/null 2>&1
		if (( $? != 0 ));then
			return $?
		fi
		# enable developer preview
		echo -n "Enabling developer preview on $clusterName"
		$CURL -X POST -u $DEFAULT_ADMIN:$DEFAULT_PW http://localhost:$port/settings/developerPreview -d enabled="true"
		echo ""
	done
}

function setupBuckets {
	for clusterName in `echo ${!CLUSTER_NAME_BUCKET_MAP[@]}`
	do
		local bucketNames=(${CLUSTER_NAME_BUCKET_MAP[$clusterName]:-})
		local port=${CLUSTER_NAME_PORT_MAP[$clusterName]:-}
		for bucketName in `echo ${bucketNames[@]}`
		do
			getPropertiesFromBucketNamePropertyMap "$bucketName"
			echo "For cluster $clusterName CREATING bucket $bucketName with properties `printBucketPropertiesResults`"
			local ramQuotaCheck=${BUCKET_PROPERTIES_OUTPUT_MAP["ramQuotaMB"]:-}
			if [[ -z "$ramQuotaCheck" ]];then
				echo "Missing ramQuota for $bucketName"
				return 1
			fi
			getBucketPropertiesRESTString
			$CURL -u $DEFAULT_ADMIN:$DEFAULT_PW -X POST http://localhost:$port/$POOLS_DEFAULT_BUCKETS_PATH -d name=$bucketName ${getBucketOutArr[@]}  > /dev/null 2>&1
			if (( $? != 0 ));then
				return $?
			fi
			# If bucket has scopes
			if [[ ! -z "${BUCKET_NAME_SCOPE_MAP[$bucketName]:-}" ]];then
				setupScopes $clusterName $bucketName
			fi
		done
	done
}

function cleanupBuckets {
	for clusterName in `echo ${!CLUSTER_NAME_BUCKET_MAP[@]}`
	do
		local bucketNames=(${CLUSTER_NAME_BUCKET_MAP[$clusterName]:-})
		local port=${CLUSTER_NAME_PORT_MAP[$clusterName]:-}
		for bucketName in `echo ${bucketNames[@]}`
		do
		echo "For cluster $clusterName DELETING bucket $bucketName"
		$CURL -u $DEFAULT_ADMIN:$DEFAULT_PW -X DELETE http://localhost:$port/$POOLS_DEFAULT_BUCKETS_PATH/$bucketName > /dev/null 2>&1
		done
	done
}

function createScope {
	local clusterName=$1
	local bucketName=$2
	local scopeName=$3
	local port=${CLUSTER_NAME_PORT_MAP[$clusterName]:-}

	echo "For cluster $clusterName bucket $bucketName CREATING scope $scopeName"
	$CURL -u $DEFAULT_ADMIN:$DEFAULT_PW -X POST http://localhost:$port/$POOLS_DEFAULT_BUCKETS_PATH/$bucketName/collections -d name=$scopeName > /dev/null 2>&1
}

function deleteScope {
	local clusterName=$1
	local bucketName=$2
	local scopeName=$3
	local port=${CLUSTER_NAME_PORT_MAP[$clusterName]:-}

	echo "For cluster $clusterName bucket $bucketName DELETING scope $scopeName"
	$CURL -u $DEFAULT_ADMIN:$DEFAULT_PW -X DELETE http://localhost:$port/$POOLS_DEFAULT_BUCKETS_PATH/$bucketName/collections/$scopeName/ > /dev/null 2>&1
}

# inputs
# 1. cluster name
# 2. bucket name
function setupScopes {
	local clusterName=$1
	local bucketName=$2
	if [[ -z "${clusterName:-}" ]] || [[ -z "${bucketName:-}" ]];then
		echo "Invalid input"
		return 1
	fi

	local -a scopesArr=(${BUCKET_NAME_SCOPE_MAP[$bucketName]:-})
	if [[ -z "${scopesArr:-}" ]];then
		echo "No scopes found for bucket $bucketName"
		return 1
	fi

	for scopeName in `echo ${scopesArr[@]}`
	do
		createScope "$clusterName" "$bucketName" "$scopeName"
		# If scope has collections
		if [[ ! -z "${SCOPE_NAME_COLLECTION_MAP[$scopeName]:-}" ]];then
			setupCollections $clusterName $bucketName $scopeName
		fi
	done
}

function createCollection {
	local clusterName=$1
	local bucketName=$2
	local scopeName=$3
	local collectionName=$4
	local port=${CLUSTER_NAME_PORT_MAP[$clusterName]:-}

	echo "For cluster $clusterName bucket $bucketName scope $scopeName CREATING collection $collectionName"
	$CURL -u $DEFAULT_ADMIN:$DEFAULT_PW -X POST http://localhost:$port/$POOLS_DEFAULT_BUCKETS_PATH/$bucketName/collections/$scopeName -d name=$collectionName > /dev/null 2>&1
}

function deleteCollection {
	local clusterName=$1
	local bucketName=$2
	local scopeName=$3
	local collectionName=$4
	local port=${CLUSTER_NAME_PORT_MAP[$clusterName]:-}

	echo "For cluster $clusterName bucket $bucketName scope $scopeName DELETING collection $collectionName"
	$CURL -u $DEFAULT_ADMIN:$DEFAULT_PW -X DELETE http://localhost:$port/$POOLS_DEFAULT_BUCKETS_PATH/$bucketName/collections/$scopeName/$collectionName > /dev/null 2>&1
}

# inputs
# 1. cluster name
# 2. bucket name
# 3. scope name
function setupCollections {
	local clusterName=$1
	local bucketName=$2
	local scopeName=$3
	if [[ -z "${clusterName:-}" ]] || [[ -z "${bucketName:-}" ]] || [[ -z "${scopeName:-}" ]];then
		echo "Invalid input"
		return 1
	fi

	local collectionsArr=(${SCOPE_NAME_COLLECTION_MAP[$scopeName]:-})
	if [[ -z "${collectionsArr:-}" ]];then
		echo "No collections found for scope $scopeName"
		return 1
	fi

	for collectionName in `echo ${collectionsArr[@]}`
	do
		createCollection "$clusterName" "$bucketName" "$scopeName" "$collectionName"
	done
}

function setupTopologies {
	setupCluster
	if (( $? != 0 ));then
		return $?
	fi
	setupBuckets
	if (( $? != 0 ));then
		return $?
	fi
}

# Takes 2 arguments:
# 1- Source cluster name
# 2- Target cluster name
function createRemoteClusterReference {
	local source=$1
	local target=$2
	if [[ -z "${source:-}" ]] || [[ -z "${target:-}" ]];then
		echo "Invalid input"
		return 1
	fi
	local sourcePort=${CLUSTER_NAME_PORT_MAP[$source]:-}
	local targetPort=${CLUSTER_NAME_PORT_MAP[$target]:-}

	echo "Creating remote cluster reference from $source to $target"
	$CURL -X POST -u $DEFAULT_ADMIN:$DEFAULT_PW http://127.0.0.1:$sourcePort/pools/default/remoteClusters -d name=$target -d hostname=127.0.0.1:$targetPort -d username=$DEFAULT_ADMIN -d password=$DEFAULT_PW
	echo ""
}

function createReplicationInternal {
	local sourceID=$1
	local targetID=$2

	replicationID=`$CURL -X POST -u $DEFAULT_ADMIN:$DEFAULT_PW http://127.0.0.1:${NODEPORTS[$sourceID]}/controller/createReplication -d fromBucket=${BUCKETNAMES[$sourceID]} -d toCluster=${CLUSTERNAMES[$targetID]} -d toBucket=${BUCKETNAMES[$targetID]} -d replicationType=continuous -d checkpointInterval=60 -d statsInterval=500`
	echo "$replicationID"
}

# Check if jq is present. It is used for parsing JSON in a bash environment
function checkJQ {
	which jq > /dev/null 2>&1
	if (( $? != 0 ));then
		which brew > /dev/null 2>&1
		if (( $? != 0 ));then
			return $?
		fi
		echo "jq not found... installing from homebrew"
		brew install jq
		return $?
	fi
	echo $?
}

function getKeyUsingJQ {
	local arg=$1
	local key=$2
	if [[ -z "${arg:-}" ]];then
		return 1
	fi

	echo $arg | jq ${key} 2> /dev/null
}

function validateClusterBucket {
	local cluster=$1
	local bucket=$2

	local -a bucketsArr
	bucketsArr=(${CLUSTER_NAME_BUCKET_MAP[$cluster]:-})
	local found="false"
	for checkBucket in `echo ${bucketsArr[@]}`
	do
		if [[ "$bucket" == "$checkBucket" ]];then
			found="true"
			break
		fi
	done
	if [[ "$found" == "false" ]];then
		echo "Bucket $bucket is not defined for cluster $cluster"
		return 1
	fi
	return 0
}

#Input:
# 1 - source cluster
# 2 - source bucketname
# 3 - target cluster
# 4 - target bucketname
# TODO - optional args for replication
function createBucketReplication {
	local sourceCluster=$1
	local sourceBucket=$2
	local targetCluster=$3
	local targetBucket=$4
	local -a replProperties=$5

	if [[ -z "${sourceCluster:-}" ]] || [[ -z "${sourceBucket:-}" ]] || [[ -z "${targetCluster:-}" ]] || [[ -z "${targetBucket:-}" ]] || [[ -z "${replProperties}" ]];then
		echo "Invalid input"
		return 1
	fi
	# check if bucket belongs to cluster
	validateClusterBucket $sourceCluster $sourceBucket
	if (( $? != 0 ));then
		return $?
	fi
	validateClusterBucket $targetCluster $targetBucket
	if (( $? != 0 ));then
		return $?
	fi
	
	insertPropertyIntoBucketReplPropertyMap $sourceCluster $sourceBucket $targetCluster $targetBucket $replProperties
	getPropertiesFromBucketReplPropertyMap $sourceCluster $sourceBucket $targetCluster $targetBucket

	local sourcePort=${CLUSTER_NAME_PORT_MAP[$sourceCluster]:-}
	getBucketReplPropertiesRESTString

	repId=`$CURL -X POST -u $DEFAULT_ADMIN:$DEFAULT_PW http://127.0.0.1:$sourcePort/controller/createReplication -d fromBucket=$sourceBucket -d toCluster=$targetCluster -d toBucket=$targetBucket "${getBucketReplOutArr[@]}"`

	if (( `checkJQ` == 0 ));then
		repIdReal=`getKeyUsingJQ $repId '.id'`
		if [[ "$repIdReal" == "" ]];then
			echo "Captured replicationID: $repId"
		else
			restFriendlyReplID=`echo $repIdReal | sed 's|/|%2F|g'`
			echo "ReplicationID: $repIdReal Rest-FriendlyID: $restFriendlyReplID"
			insertBucketReplIntoExportMap "$sourceCluster" "$sourceBucket" "$targetCluster" "$targetBucket" "$restFriendlyReplID"
		fi
	else
		echo "Captured replicationID: $repId"
	fi
}

function cleanupBucketReplications {
	for replKey in "${!BUCKET_REPL_EXPORT_MAP[@]}"
	do
		local sourceCluster=`echo "$replKey" | cut -d, -f1`
		local restID=`echo "${BUCKET_REPL_EXPORT_MAP[$replKey]}" | sed 's/"//g'`
		local sourcePort=${CLUSTER_NAME_PORT_MAP[$sourceCluster]:-}
		local sourceBucket=`echo "$replKey" | cut -d, -f2`
		local targetCluster=`echo "$replKey" | cut -d, -f3`
		local targetBucket=`echo "$replKey" | cut -d, -f4`

		echo "DELETING replication from sourceCluster $sourceCluster sourceBucket $sourceBucket to targetCluster $targetCluster targetBucket $targetBucket..."
		$CURL -X DELETE -u $DEFAULT_ADMIN:$DEFAULT_PW http://127.0.0.1:$sourcePort/controller/cancelXDCR/${restID} > /dev/null 2>&1
	done
}

function findCbDocLoader {
	if [[ ! -z "${CBDOCLOADER:-}" ]];then
		echo "$CBDOCLOADER"
		return 0
	fi

	which locate > /dev/null 2>&1
	if (( $? != 0 ));then
		return $?
	fi
	# Just pick one
	docloader=`locate cbdocloader | grep install | grep bin | head -n 1`
	if (( $? != 0 ));then
		echo ""
		return 1
	fi
	if [[ -z "${CBDOCLOADER:-}" ]];then
		# set it in case needed it in future
		export CBDOCLOADER=$docloader
	fi
	echo "$docloader"
	return 0

}

#Input
# 1 - cluster name
# 2 - bucket name
# 3 - file name
function runDocLoader {
	local clusterName=$1
	local bucketName=$2
	local fileName=$3
	if [[ -z "${clusterName:-}" ]] || [[ -z "${bucketName:-}" ]] || [[ -z "${fileName:-}" ]];then
		echo "Invalid input"
		return 1
	fi
	local port=${CLUSTER_NAME_PORT_MAP[$clusterName]:-}
	
	docLoader=`findCbDocLoader`
	if (( $? != 0 ));then
		echo "Could not find docLoader"
		return 1
	fi
	
	getPropertiesFromBucketNamePropertyMap "$bucketName"
	local ramQuota=${BUCKET_PROPERTIES_OUTPUT_MAP["ramQuotaMB"]:-}
	if [[ -z "$ramQuota" ]];then
		echo "Missing ramQuota for $bucketName"
		return 1
	fi

	Echo "Executing cbdocloader on bucket $bucketName for file $fileName..."
	$docLoader -c localhost:${port} -u $DEFAULT_ADMIN -p $DEFAULT_PW -b $bucketName -m $ramQuota -d $fileName
}

function findCbWorkloadGen {
	if [[ ! -z "${CBWORKLOADGEN:-}" ]];then
		echo "$CBWORKLOADGEN"
		return 0
	fi

	which locate > /dev/null 2>&1
	if (( $? != 0 ));then
		return $?
	fi
	# Just pick one
	workloadGen=`locate cbworkloadgen | grep build\/couchbase-cli | head -n 1`
	if (( $? != 0 ));then
		echo ""
		return 1
	fi
	if [[ -z "$CBWORKLOADGEN" ]];then
		# set it in case needed it in future
		CBWORKLOADGEN=$workloadGen
	fi
	echo "$workloadGen"
	return 0
}

# Input
# 1 - cluster name
# 2 - bucket name
function runCbWorkloadGenBucket {
	local clusterName=$1
	local bucketName=$2
	if [[ -z "${clusterName:-}" ]] || [[ -z "${bucketName:-}" ]];then
		echo "Invalid input"
		return 1
	fi
	local port=${CLUSTER_NAME_PORT_MAP[$clusterName]:-}

	workloadGen=`findCbWorkloadGen`
	if (( $? != 0 )) || [[ -z "$workloadGen" ]];then
		echo "Could not find workload generator binary"
		return 1
	fi

	echo "Running cbworkloadGen on $clusterName bucket $bucketName"
	# Run 10000 items of json documents with set/get ratio of 100%
	$workloadGen -i 10000 -j -r 1 -n 127.0.0.1:$port -b $bucketName -u $DEFAULT_ADMIN -p $DEFAULT_PW --prefix=xdcrProv_$clusterName
}

function runCbWorkloadGenCollection {
	local clusterName=$1
	local bucketName=$2
	local scopeName=$3
	local collectionName=$4
	local collectionId

	if [[ -z "${clusterName:-}" ]] || [[ -z "${bucketName:-}" ]] || [[ -z "${scopeName:-}" ]] || [[ -z "${collectionName:-}" ]];then
		echo "Invalid input"
		return 1
	fi
	local port=${CLUSTER_NAME_PORT_MAP[$clusterName]:-}

	workloadGen=`findCbWorkloadGen`
	if (( $? != 0 )) || [[ -z "$workloadGen" ]];then
		echo "Could not find workload generator binary"
		return 1
	fi

	manifestOutput=`getManifest $clusterName $bucketName`
	if (( $? != 0 ));then
		echo "Error retrieving manifest"
		return 1
	fi

	collectionId=`getCollectionIdFromScopeAndCollectionName "$manifestOutput" "$scopeName" "$collectionName"`
	if (( $? != 0 ));then
		echo "Error retrieving collection ID"
		return 1
	fi

	echo "Running cbworkloadGen on $clusterName bucket $bucketName scope: $scopeName collection $collectionName (ID: $collectionId)"
	# Run 10000 items of json documents with set/get ratio of 100%
	$workloadGen -i 10000 -j -r 1 -n 127.0.0.1:$port -b $bucketName -u $DEFAULT_ADMIN -p $DEFAULT_PW --prefix=xdcrProvCollections_$clusterName -c $collectionId
}

function waitForBgJobs {
	echo "Waiting for background jobs to finish..."
	jobsCnt=`jobs -l | grep -c "Running"`
	while (( $jobsCnt > 0 ))
	do
		sleep 1
		jobsCnt=`jobs -l | grep -c "Running"`
	done
}

# Input: 1. clusterName
#        2. bucketName
function getManifest {
	local clusterName="$1"
	local bucketName="$2"
	local port=${CLUSTER_NAME_PORT_MAP[$clusterName]:-}

	if [[ -z "${port:-}" ]];then
		echo ""
		return 1
	fi

	$CURL -u $DEFAULT_ADMIN:$DEFAULT_PW -X GET http://localhost:$port/$POOLS_DEFAULT_BUCKETS_PATH/$bucketName/collections
}

declare -a JQ_KEYS_FILTER_FUNC_ARR

function _jqFilterArray {
	local jqOutputAsInput="$1"
	# clear array
	JQ_KEYS_FILTER_FUNC_ARR=()

	for k in `echo "$jqOutputAsInput"`
	do
		if [[ "$k" == '[' ]] || [[ "$k" == ']' ]];then
			continue
		fi
		# take out last comma and quotes
		key=`echo "$k"| sed s/',$'//g | sed s/'"'//g`
		JQ_KEYS_FILTER_FUNC_ARR[${#JQ_KEYS_FILTER_FUNC_ARR[@]}]="$key"
	done
}

function prettyPrintManifest {
	local manifest=$1

	# get manifest version
	local manifestVersion=`echo "$manifest" | jq '.uid'`
	echo "Manifest version $manifestVersion"

	#get all the scopes
	local scopesRaw=`echo "$manifest" | jq '.scopes'`

	local scopesKeys=`echo "$scopesRaw" | jq 'keys'`
	_jqFilterArray "${scopesKeys}"

	#echo "${JQ_KEYS_FILTER_FUNC_ARR[@]}"
	for scopeName in "${JQ_KEYS_FILTER_FUNC_ARR[@]}"
	do
		local scopeOutput=`echo "$scopesRaw" | jq ".${scopeName}"`
		local scopeUID=`echo "$scopeOutput" | jq '.uid'`
		echo "ScopeName $scopeName (UID $scopeUID)"

		# Get individual collections within this scope
		local collectionsKeysRaw=`echo "$scopeOutput" | jq '.collections|keys'`
		_jqFilterArray "$collectionsKeysRaw"

		for collectionName in "${JQ_KEYS_FILTER_FUNC_ARR[@]}"
		do
			local collectionsOutputRaw=`echo "$scopeOutput" | jq '.collections'`
			local collectionOutput=`echo "$collectionsOutputRaw" | jq ".${collectionName}"`
			local collectionUID=`echo "$collectionOutput" | jq '.uid'`
			echo "ScopeName $scopeName CollectionName $collectionName (UID $collectionUID)"
		done
	done
}

# Returns non-0 if not found
function getCollectionIdFromScopeAndCollectionName {
	local manifest=$1
	local requestedScopeName=$2
	local requestedCollectionName=$3

	local scopesRaw=`echo "$manifest" | jq '.scopes'`

	local scopesKeys=`echo "$scopesRaw" | jq 'keys'`
	_jqFilterArray "${scopesKeys}"


	for scopeName in "${JQ_KEYS_FILTER_FUNC_ARR[@]}"
	do
		if [[ "$scopeName" == "$requestedScopeName" ]];then
			local scopeOutput=`echo "$scopesRaw" | jq ".${scopeName}"`
			local scopeUID=`echo "$scopeOutput" | jq '.uid'`
			local collectionsKeysRaw=`echo "$scopeOutput" | jq '.collections|keys'`
			_jqFilterArray "$collectionsKeysRaw"

			for collectionName in "${JQ_KEYS_FILTER_FUNC_ARR[@]}"
			do
				if [[ "$collectionName" == "$requestedCollectionName" ]];then
					local collectionsOutputRaw=`echo "$scopeOutput" | jq '.collections'`
					local collectionOutput=`echo "$collectionsOutputRaw" | jq ".${collectionName}"`
					local collectionUID=`echo "$collectionOutput" | jq '.uid'`
					echo "$collectionUID"
					return 0
				fi
			done
		fi
	done
	# not found
	echo ""
	return 1
}

function printSingleClusterBucketScopeAndCollection {
	local clusterName=$1
	local bucketName=$2

	# Get the manifest for this bucket
	local manifestOutput=""
	local manifestVersion=""
	manifestOutput=`getManifest $clusterName $bucketName`
	if (( $? != 0 ));then
		echo "Error retrieving manifest - Cluster $clusterName bucket $bucketName scope $scopeName"
		continue
	elif [[ -z "$manifestOutput" ]];then
		echo "Retrieved empty manifest JSON - Cluster $clusterName bucket $bucketName scope $scopeName"
		continue
	fi

	manifestVersion=`echo "$manifestOutput" | jq '.uid'`
	echo "Cluster $clusterName Bucket $bucketName collections manifest version: $manifestVersion"

	prettyPrintManifest "$manifestOutput"
}

# Print a summary of all the topology setup -> scope and collection info
# Uses the manifest REST API
function printGlobalScopeAndCollectionInfo {
	if (( `checkJQ` != 0 ));then
		echo "jq not found - cannot run $0"
		return 1
	fi

	for clusterName in `echo ${!CLUSTER_NAME_PORT_MAP[@]}`
	do
		local port=${CLUSTER_NAME_PORT_MAP[$clusterName]:-}
		local -a buckets=(${CLUSTER_NAME_BUCKET_MAP[$clusterName]:-})
		for bucketName in `echo ${buckets[@]}`
		do
			printSingleClusterBucketScopeAndCollection "$clusterName" "$bucketName"
		done
	done
}

# Stats library

# Gets the last reading of the stats output
function getStats {
	local srcClusterName=$1
	local srcBucketName=$2
	local targetClusterName=$3
	local targetBucketName=$4
	local statsName=$5

	restId=`getRestIDFromExportedData "$srcClusterName" "$srcBucketName" "$targetClusterName" "$targetBucketName"`
	if (( $? != 0 ));then
		return $?
	fi

	local port=${CLUSTER_NAME_PORT_MAP[$srcClusterName]}
	if (( `checkJQ` != 0 ));then
		return 1
	fi

	statsOutput=`$CURL -u $DEFAULT_ADMIN:$DEFAULT_PW -X GET http://localhost:$port/$POOLS_DEFAULT_BUCKETS_PATH/$srcBucketName/stats/replications%2F${restId}%2F${statsName}`
	if (( $? != 0 ));then
		return $?
	fi

	# Gets the last element of the array with -1 indexing
	echo "$statsOutput"  | jq ".nodeStats.\"[::1]:${port}\"[-1]"
}
