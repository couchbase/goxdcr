# Copyright 2025-Present Couchbase, Inc.
#
# Use of this software is governed by the Business Source License included in
# the file licenses/BSL-Couchbase.txt.  As of the Change Date specified in that
# file, in accordance with the Business Source License, use of this software
# will be governed by the Apache License, Version 2.0, included in the file
# licenses/APL2.txt.

# =============================
# topological map information
# =============================
# cluster -> Bucket(s)
# -----------------

CLUSTER_NAME_PORT_MAP=(["C1"]=9000 ["C1P"]=9001 ["C2"]=9002 ["C2P"]=9003)
CLUSTER_DEPENDENCY_MAP=(["C1P"]="C1" ["C2P"]="C2")
CLUSTER_NAME_XDCR_PORT_MAP=(["C1"]=13000 ["C1P"]=13001 ["C2"]=13002 ["C2P"]=13003)
# Set c1 and c2 to have 1 bucket
CLUSTER_NAME_BUCKET_MAP=(["C1"]="B1" ["C2"]="B2")

# Bucket properties
declare -A BucketProperty=(["ramQuotaMB"]=100)
insertPropertyIntoBucketNamePropertyMap "B1" BucketProperty
insertPropertyIntoBucketNamePropertyMap "B2" BucketProperty

declare -A DefaultBucketReplProperties=(["replicationType"]="continuous" ["checkpointInterval"]=300 ["statsInterval"]=500)

# Bucket -> Scopes
# -----------------
declare -a scopeArr=("S1" "S2")
BUCKET_NAME_SCOPE_MAP=(["B1"]=${scopeArr[@]} ["B2"]=${scopeArr[@]})

# Scopes -> Collections
# ----------------------
declare -a collectionArr=("col1" "col2")
SCOPE_NAME_COLLECTION_MAP=(["S1"]=${collectionArr[@]} ["S2"]=${collectionArr[@]})

# declare xdcr roles username and password
DEFAULT_XDCR_ADMIN="XDCR_Admin"
DEFAULT_XDCR_INBOUND="XDCR_Inbound"
DEFAULT_PASSWORD="wewewe"

function runDataLoad {
	echo "RUNNING dataload..."
	runCbWorkloadGenCollection "C1" "B1" "S1" "col1"
	runCbWorkloadGenCollection "C1" "B1" "S1" "col2"
	runCbWorkloadGenCollection "C1" "B1" "S2" "col1"
	runCbWorkloadGenCollection "C1" "B1" "S2" "col2"
}

function setupXdcrRoles {
	for clusterName in $(echo ${!CLUSTER_NAME_PORT_MAP[@]}); do
		setupXdcrAdminUser "$clusterName" "$DEFAULT_XDCR_ADMIN" "$DEFAULT_PASSWORD"
		setupXdcrInboundUser "$clusterName" "$DEFAULT_XDCR_INBOUND" "$DEFAULT_PASSWORD"
	done
}

CREDENTIALS_CHANGE_ERR_MSG="has changed its credentials and the entered credentials on this cluster is no longer valid for pipeline"

function runTestCase {
	echo "============================================================================"
	echo "Running basic replication with certificate rotation (mTLS)"
	echo "============================================================================"
	setupTopologies
	if (($? != 0)); then
		exit 1
	fi

	# Clear the logs at the beginning.
	# This is necessary because we later use 'grep' to search for specific log lines and count their occurrences.
	for clusterName in $(echo ${!CLUSTER_NAME_PORT_MAP[@]}); do
		clearInternalNodeXdcrLog "$clusterName"
	done

	addNodesIn
	startRebalancing "C1"
	startRebalancing "C2"
	sleep 10

	# setup the xdcr roles
	setupXdcrRoles

	setupCertsForTesting
	for clusterName in $(echo ${!CLUSTER_NAME_PORT_MAP[@]}); do
		setEnableClientCert "$clusterName"
	done

	# create a seperate root CA to sign cert for xdcrInbound user
	setupCertificateAuthority "C2" "$DEFAULT_XDCR_INBOUND"

	# deploy the new certificate to C2 and its dependent nodes
	local clusterName="C2"
	local clusterMapKey="${clusterName}_${DEFAULT_XDCR_INBOUND}"
	local port=${CLUSTER_NAME_PORT_MAP[$clusterName]:-}
	curl -X POST --data-binary "@${CLUSTER_ROOT_CERTIFICATE_LOCATION["$clusterMapKey"]}" \
		http://$DEFAULT_ADMIN:$DEFAULT_PW@127.0.0.1:$port/controller/uploadClusterCA

	for dependentNodeName in $(echo ${!CLUSTER_DEPENDENCY_MAP[@]}); do
		if [[ "${CLUSTER_DEPENDENCY_MAP["$dependentNodeName"]}" == "$clusterName" ]]; then
			local clusterMapKey="${dependentNodeName}_${DEFAULT_XDCR_INBOUND}"
			port=${CLUSTER_NAME_PORT_MAP[$dependentNodeName]:-}
			curl -X POST --data-binary "@${CLUSTER_ROOT_CERTIFICATE_LOCATION["$clusterMapKey"]}" \
				http://$DEFAULT_ADMIN:$DEFAULT_PW@127.0.0.1:$port/controller/uploadClusterCA
		fi
	done

	createCertsForUser "C2" "$DEFAULT_XDCR_INBOUND"

	# Wait for vbuckets and all the other things to propagate before XDCR provisioning
	sleep 5
	createSecureRemoteClusterReference "C1" "C2" "${CLUSTER_ROOT_CERTIFICATE_MAP["C2"]}" "$DEFAULT_XDCR_INBOUND"
	sleep 5
	createBucketReplication "C1" "B1" "C2" "B2" DefaultBucketReplProperties
	runDataLoad

	# stage credentials
	port=${CLUSTER_NAME_PORT_MAP["C1"]:-}
	curl -X POST -u "$DEFAULT_ADMIN:$DEFAULT_PW" http://127.0.0.1:$port/pools/default/remoteClusters/C2 \
		--data-urlencode stage=true \
		--data-urlencode "clientCertificate=$(<"${CLIENT_CERT_MAP["C2"]}")" \
		--data-urlencode "clientKey=$(<"${CLIENT_KEY_MAP["C2"]}")"

	# introduce auth errors by deleting the root CA that signed the XDCR_Inbound certificate
	port=${CLUSTER_NAME_PORT_MAP["C2"]:-}
	curl -X DELETE -u $DEFAULT_ADMIN:$DEFAULT_PW http://localhost:$port/pools/default/trustedCAs/2

	echo "Wait for 15sec before grepping for errors"
	sleep 15

	validateLogWithInstance "C1" "$CREDENTIALS_CHANGE_ERR_MSG" "0"

	checkRemoteClusterConnectivity "C1"

	# run data load again
	runDataLoad
	sleep 2
	checkUnidirectionalChangesLeft

	validateLogWithInstance "C1" "$CREDENTIALS_CHANGE_ERR_MSG" "0"

	pipelineErrCnt=$(getPrometheusStat "C1" "B1" "B2" "xdcr_pipeline_errors")
	if (($pipelineErrCnt != 0)); then
		echo "Expected zero pipeline errors. PipelineerrCnt=$pipelineErrCnt"
		echo "============================================================================"
		echo "FAILED"
		echo "============================================================================"
	fi

	grepForPanics

	echo "============================================================================"
	echo "PASSED"
	echo "============================================================================"
	cleanupBucketReplications
	cleanupBuckets
	cleanupRemoteClusterRefs

	for clusterName in $(echo ${!CLUSTER_NAME_PORT_MAP[@]}); do
		setDisableClientCert "$clusterName"
	done
	cleanupClientCertMaps

	restoreClusterBack "C1"
	restoreClusterBack "C2"
}
