#!/usr/bin/env bash
set -u

# Copyright 2019-Present Couchbase, Inc.
#
# Use of this software is governed by the Business Source License included in
# the file licenses/BSL-Couchbase.txt.  As of the Change Date specified in that
# file, in accordance with the Business Source License, use of this software
# will be governed by the Apache License, Version 2.0, included in the file
# licenses/APL2.txt.

# BASH VERSION CHECK - since hash maps are implemented >= bash version 4
bash_major_version=$(echo ${BASH_VERSION} | cut -d. -f1)
if (($bash_major_version < 4)); then
	echo "===================================================================="
	echo "Bash version >= 4 is required. Current bash version: ${BASH_VERSION}. Script may fail"
	echo "How to upgrade bash on MacOS:"
	echo "1. Run \"brew update && brew install bash\" to install the latest version of bash for macOS"
	echo "2. Run \"sudo vim /etc/shells\" and add \"/usr/local/bin/bash\" to the list"
	echo "3. Run \"chsh -s /usr/local/bin/bash\" to set default shell to the new one"
	echo "4. Exit and restart the current session"
	echo "===================================================================="
	return 1
fi

. ./importExporter.shlib
. ./clusterRunProvision.shlib
. ./testLibrary.shlib

# Shortcuts for executing commands on a node... currently 4 nodes
declare -a VSSH
declare -a VSSH_NOHUP

VSSH[0]="vagrant ssh node1 -c "
VSSH[1]="vagrant ssh node2 -c "
VSSH[2]="vagrant ssh node3 -c "
VSSH[3]="vagrant ssh node4 -c "

VSSH_NOHUP[0]="vagrant ssh node1 -- "
VSSH_NOHUP[1]="vagrant ssh node2 -- "
VSSH_NOHUP[2]="vagrant ssh node3 -- "
VSSH_NOHUP[3]="vagrant ssh node4 -- "

# vscp from local to a node
function vscp {
	local index="$1"
	local localFile="$2"
	local targetDir="$3"

	#machine index is +1
	vagrant scp "$localFile" "node$(($index + 1)):${targetDir}"
}

declare -A CBServerLink=(
	["neo"]="https://latestbuilds.service.couchbase.com/builds/latestbuilds/couchbase-server/neo/latest/couchbase-server-enterprise_neo-linux_arm64.deb"
	["trinity"]="https://latestbuilds.service.couchbase.com/builds/latestbuilds/couchbase-server/trinity/latest/couchbase-server-enterprise_trinity-linux_arm64.deb"
	["morpheus"]="https://latestbuilds.service.couchbase.com/builds/latestbuilds/couchbase-server/morpheus/latest/couchbase-server-enterprise_morpheus-linux_arm64.deb"
	["toy"]="https://latestbuilds.service.couchbase.com/builds/latestbuilds/couchbase-server/toybuilds/21114/couchbase-server-enterprise_8.0.0-21114-linux_amd64.deb" # to be filled out
)

declare -A SGWLink=(
	["4.0.0-2"]="https://latestbuilds.service.couchbase.com/builds/latestbuilds/sync_gateway/4.0.0/2/couchbase-sync-gateway-enterprise_4.0.0-2_x86_64.deb"
)

function vagrantUp {
	vagrant up
}

function vagrantHalt {
	vagrant halt
}

function vagrantRemoveCbServer {
	local i=$1
	local cmd

	cmd="${VSSH[$i]} \"sudo dpkg --purge couchbase-server\""
	echo "==== Running $cmd ===="
	eval $cmd

	cmd="${VSSH[$i]} \"sudo rm -rf /opt/couchbase\""
	echo "==== Running $cmd ===="
	eval $cmd
}

function vagrantRemoveCbServerAll {
	local i
	for ((i = 0; $i < ${#VSSH[@]}; i++)); do
		vagrantRemoveCbServer $i
	done
}

# If VPN is not set up, this should catch it
function checkBuildServerAccessibility {
	wget -q latestbuilds.service.couchbase.com/builds/ -O "/tmp/index.html" &
	sleep 3
	local jobsCnt=$(jobs -l | grep -c "Running")
	if (($jobsCnt > 0)); then
		killAllBgJobs
		echo "VPN to Couchbase is not set up"
		exit 1
	fi
}

function vagrantGetLocalDebFileName {
	local version="$1"

	echo "cbServer_$version.deb"
}

function downloadCBServerDeb {
	local version="$1"
	local localFileName=$(vagrantGetLocalDebFileName "$version")
	if [[ -z "${CBServerLink[$version]:-}" ]]; then
		echo "Version $version is not linked"
	fi

	if [[ -f "$localFileName" ]]; then
		echo "Found pre-downloaded file $localFileName"
		return 0
	fi

	checkBuildServerAccessibility
	echo "=== Need to download ${CBServerLink[$version]}... ==="
	wget --show-progress "${CBServerLink[$version]}" -O "$localFileName"
}

function vagrantInstallCBServerAll {
	local i
	local version="$1"
	for ((i = 0; $i < ${#VSSH[@]}; i++)); do
		vagrantInstallCBServer $i "$version"
	done
}

function vagrantInstallCBServer {
	local i=$1
	local version="$2"
	local cmd
	local debFile=$(vagrantGetLocalDebFileName "$version")
	local nodeName=${VAGRANT_VM_IDX_MAP["$i"]}

	vagrantInstallNtp "$i"
	vagrantInstallPythonHttpLib "$i"
	vagrantInstallLibInfo "$i"
	downloadCBServerDeb "$version"
	VAGRANT_VERSION_MAP[$nodeName]="$version"

	cmd="${VSSH[$i]} \"sudo dpkg -i /vagrant/$debFile\""
	echo "==== Running $cmd ===="
	eval $cmd
}

function vagrantInstallPythonHttpLib {
	local i=$1
	local cmd

	cmd="${VSSH[$i]} \"sudo apt-get -y install python-httplib2\""
	echo "==== Running $cmd ===="
	eval $cmd
}

function vagrantInstallNtp {
	local i=$1
	local cmd

	cmd="${VSSH[$i]} \"sudo apt-get -y install ntp\""
	echo "==== Running $cmd ===="
	eval $cmd
}

function vagrantInstallLibInfo {
	local i=$1
	local cmd

	cmd="${VSSH[$i]} \"sudo apt-get -y install libtinfo5\""
	echo "==== Running $cmd ===="
	eval $cmd
}

function vagrantRebalanceAndUpgrade {
	local nodeToUpgrade="$1"
	local nodeIndex="$2"
	local peerNode="$3"
	local versionToInstall="$4"

	# remove node1 and validate XDCR traffic
	echo "Removing node $nodeToUpgrade leaving $peerNode"
	startEjectNode "$nodeToUpgrade" "$peerNode"

	# upgrade node add back in and validate XDCR Traffic
	vagrantInstallCBServer "$nodeIndex" "$versionToInstall"

	echo "Waiting 10 seconds after install for couchbase server processes to launch"
	sleep 10

	echo "Re-adding upgraded node $nodeToUpgrade to $peerNode"
	addOneNodeIn "$nodeToUpgrade" "$peerNode"
	startRebalancing "$peerNode"

	sleep 10

	# As last part, need to set alternate address again
	setupVagrantAltAddress "$nodeToUpgrade"
}

function vagrantGrepForPanic {
	local i=$1
	local cmd
	local output

	output=$(${VSSH[$i]} "sudo grep -c panic /opt/couchbase/var/lib/couchbase/logs/goxdcr.log" 2>/dev/null)
	output=$(echo "$output" | tr -d '\r')
	if (($output > 0)); then
		echo "Found panic on node $i"
		exit 1
	fi
}

function vagrantGrepForPanicAll {
	local i
	for ((i = 0; $i < ${#VSSH[@]}; i++)); do
		vagrantGrepForPanic $i
	done
}

function vagrantLoadCerts {
	local idx
	local caKey

	# Vagrant loading
	for clusterName in $(echo ${!CLUSTER_NAME_PORT_MAP[@]}); do
		if [[ -z "${VAGRANT_VM_IP_MAP["$clusterName"]:-}" ]]; then
			# Not a vagrant node
			continue
		fi
		idx="$(getClusterIdx "$clusterName")"

		# First tell the Ubuntu to trust the certificate authority
		for caKey in $(echo ${!NODE_CA_MAP[@]}); do
			echo "${CLUSTER_ROOT_CERTIFICATE_MAP["$caKey"]}" >/tmp/selfSignedCA.pem
			vscp "$idx" "/tmp/selfSignedCA.pem" "/tmp/"
			${VSSH[$idx]} "sudo mv /tmp/selfSignedCA.pem /usr/local/share/ca-certificates/${caKey}_root.crt"
			vscp "$idx" "${NODE_CA_MAP[$caKey]}" "/tmp/ca.pem"
			${VSSH[$idx]} "sudo mv /tmp/ca.pem /usr/local/share/ca-certificates/${caKey}_node.crt"
		done
		#vscp "$idx" "/tmp/selfSignedCA.pem" "/tmp/ca.pem"
		#${VSSH[$idx]} "sudo mv /tmp/ca.pem /usr/local/share/ca-certificates/selfSignedCA.crt"

		${VSSH[$idx]} "sudo update-ca-certificates"

		# Copy chain file
		${VSSH[$idx]} "sudo mkdir -p /opt/couchbase/var/lib/couchbase/inbox"
		# Vagrant scp does not have root priviledge
		vscp "$idx" "${NODE_CA_MAP[$clusterName]}" "/tmp/ca.pem"
		${VSSH[$idx]} "curl -X POST --data-binary '@/tmp/ca.pem' http://$DEFAULT_ADMIN:$DEFAULT_PW@127.0.0.1:8091/controller/uploadClusterCA"

		vscp "$idx" "${NODE_CERT_MAP[$clusterName]}" "/tmp/chain.pem"
		${VSSH[$idx]} "sudo mv /tmp/chain.pem /opt/couchbase/var/lib/couchbase/inbox/chain.pem"
		vscp "$idx" "${NODE_KEY_MAP[$clusterName]}" "/tmp/pkey.key"
		${VSSH[$idx]} "sudo mv /tmp/pkey.key /opt/couchbase/var/lib/couchbase/inbox/pkey.key"

	done
}

function vagrantDelAlternateAddress {
	local index="$1"

	${VSSH[$index]} "curl -X DELETE -u $DEFAULT_ADMIN:$DEFAULT_PW http://127.0.0.1:8091/node/controller/setupAlternateAddresses/external"
}

function vagrantRunCBWorkloadGenBucket {
	local clusterName=$1
	local bucketName=$2
	local numItems=${3:-10000}
	local prefix="${4:-xdcrProv_$clusterName}"
	local idx="$(getClusterIdx "$clusterName")"
	local workloadGenLoc="/opt/couchbase/bin/cbworkloadgen"
	local cmd

	echo "Running cbworkloadGen on $clusterName bucket $bucketName"
	cmd="${VSSH[$idx]} \"$workloadGenLoc -i $numItems -j -r 1 -n 127.0.0.1:8091 -b $bucketName -u $DEFAULT_ADMIN -p $DEFAULT_PW --prefix=$prefix\""
	echo "==== Running $cmd ===="
	eval $cmd
}

function vagrantRunCBWorkloadGenBucketCont {
	local clusterName=$1
	local bucketName=$2
	local numItems=${3:-10000}
	local prefix="${4:-xdcrProv_$clusterName}"
	local idx="$(getClusterIdx "$clusterName")"
	local workloadGenLoc="/opt/couchbase/bin/cbworkloadgen"
	local cmd

	echo "Running continouous cbworkloadGen on $clusterName bucket $bucketName"
	cmd="${VSSH_NOHUP[$idx]} 'nohup \$($workloadGenLoc -i $numItems -j -r 1 -n 127.0.0.1:8091 -b $bucketName -u $DEFAULT_ADMIN -p $DEFAULT_PW --prefix=$prefix -l)'"
	echo "==== Running $cmd ===="
	eval $cmd &
	sleep 3
}

function vagrantKillAllIO {
	local clusterName=$1
	local idx="$(getClusterIdx "$clusterName")"

	echo "Killing all cbworkloadGen instances on $clusterName"
	#hacky - kill all nohups first
	cmd="${VSSH[$idx]} 'killall -9 bash'"
	echo "==== Running $cmd ===="
	eval $cmd

	# kill cbworkloadgen based on python3
	cmd="${VSSH[$idx]} 'killall -9 python3'"
	echo "==== Running $cmd ===="
	eval $cmd
}

function vagrantRunCBWorkloadGenCollection {
	local clusterName=$1
	local bucketName=$2
	local prefix=$3
	local colIdHex=$4
	local workloadGenLoc="/opt/couchbase/bin/cbworkloadgen"
	local cmd
	local idx="$(getClusterIdx "$clusterName")"

	echo "Running cbworkloadGen on $clusterName bucket $bucketName collection $colIdHex"
	cmd="${VSSH[$idx]} \"$workloadGenLoc -i $CBWORKLOAD_COLLECTION_NUM_ITEMS -j -r 1 -n 127.0.0.1:8091 -b $bucketName -u $DEFAULT_ADMIN -p $DEFAULT_PW --prefix=$prefix -c $colIdHex\""
	echo "==== Running $cmd ===="
	eval $cmd
}

function setupVagrantAltPortForwarding {
	local clusterName=$1
	local idx="$(getClusterIdx "$clusterName")"

	# First install needed software
	vagrantInstallSocat "$idx"

	# For each port, need to launch a bg task to port forward
	echo "Setting up port forwarding for $clusterName"
	# mgmtPort
	cmd="${VSSH_NOHUP[$idx]} 'nohup \$(socat tcp-listen:${CLUSTER_NAME_PORT_MAP["$clusterName"]},reuseaddr,fork tcp:localhost:8091)'"
	echo "==== Running $cmd ===="
	eval $cmd &
	sleep 3

	# mgmtSSLPort
	cmd="${VSSH_NOHUP[$idx]} 'nohup \$(socat tcp-listen:${CLUSTER_NAME_SSLPORT_MAP["$clusterName"]},reuseaddr,fork tcp:localhost:18091)'"
	echo "==== Running $cmd ===="
	eval $cmd &
	sleep 3

	# kv
	cmd="${VSSH_NOHUP[$idx]} 'nohup \$(socat tcp-listen:${VAGRANT_KV_EXTERNAL_MAP["$clusterName"]},reuseaddr,fork tcp:localhost:11210)'"
	echo "==== Running $cmd ===="
	eval $cmd &
	sleep 3

	# kvSSL
	cmd="${VSSH_NOHUP[$idx]} 'nohup \$(socat tcp-listen:${VAGRANT_KVSSL_EXTERNAL_MAP["$clusterName"]},reuseaddr,fork tcp:localhost:11207)'"
	echo "==== Running $cmd ===="
	eval $cmd &
	sleep 3
}

function checkAndWaitForUnattendedUpgrade {
	local idx=$1
	local cmd
	local count=1

	cmd="${VSSH[$idx]} \"ps -ef | grep unattended-upgrade-shutdown | grep -v grep | grep -v shutdown | grep -c .\""

	echo "==== Running $cmd repeatedly until upgrade is finished ===="
	while [[ ! "$count" =~ 0 ]]; do
		count=$(eval $cmd)
		sleep 10
	done

	count=1
	cmd="${VSSH[$idx]} \"ps -ef | grep /usr/bin/unattended-upgrade | grep -v grep | grep -c .\""
	echo "==== Running $cmd repeatedly until upgrade is finished ===="
	while [[ ! "$count" =~ 0 ]]; do
		count=$(eval $cmd)
		sleep 10
	done

}

function vagrantStopSGW {
	local clusterName=$1
	local idx="$(getClusterIdx "$clusterName")"

	${VSSH[$idx]} "sudo systemctl stop sync_gateway"
}

function vagrantStartSGW {
	local clusterName=$1
	local idx="$(getClusterIdx "$clusterName")"

	${VSSH[$idx]} "sudo systemctl start sync_gateway"
}

function vagrantSetConfigSGW {
	local clusterName="$1"
	local idx="$(getClusterIdx "$clusterName")"
	local tmpFile="/tmp/sgwConfig.cfg"

	cat <<EOF >$tmpFile
{
  "bootstrap": {
    "server": "couchbase://${VAGRANT_VM_IP_MAP[$clusterName]}",
    "username": "$DEFAULT_ADMIN",
    "password": "$DEFAULT_PW",
    "use_tls_server": false
  },
  "logging": {
    "console": {
      "enabled": true,
      "log_level": "debug",
      "log_keys": ["*"]
    }
  }
}
EOF

	vscp "$idx" "$tmpFile" "$tmpFile"
	${VSSH[$idx]} "sudo mv $tmpFile /home/sync_gateway/sync_gateway.json"
}

function vagrantSetSecureConfigSGW {
	local clusterName="$1"
	local idx="$(getClusterIdx "$clusterName")"
	local tmpFile="/tmp/sgwConfig.cfg"

	cat <<EOF >$tmpFile
{
  "bootstrap": {
    "server": "couchbases://${VAGRANT_VM_IP_MAP[$clusterName]}",
    "username": "$DEFAULT_ADMIN",
    "password": "$DEFAULT_PW",
    "server_tls_skip_verify": true,
    "use_tls_server": true
  },
  "logging": {
    "console": {
      "enabled": true,
      "log_level": "debug",
      "log_keys": ["*"]
    }
  }
}
EOF

	vscp "$idx" "$tmpFile" "$tmpFile"
	${VSSH[$idx]} "sudo mv $tmpFile /home/sync_gateway/sync_gateway.json"
}

function vagrantSGWDigest {
	local digest
	digest=$(echo -n "$DEFAULT_ADMIN:$DEFAULT_PW" | base64)
	echo "$digest"
}

function vagrantSGWAddDbConfig {
	local clusterName="$1"
	local bucketName="$2"
	local dbName="$3"
	local digest=$(vagrantSGWDigest)

	local idx="$(getClusterIdx "$clusterName")"

	# The following adds a specific user in case admin is not what we want to use:
	#${VSSH[$idx]} "curl -X PUT http://127.0.0.1:8091/settings/rbac/users/local/$DEFAULT_ADMIN -u $DEFAULT_ADMIN:$DEFAULT_PW -d password=$DEFAULT_PW -d roles='mobile_sync_gateway[*]'"

	# the following will create a sync gateway database config
	${VSSH[$idx]} "curl -X PUT 'http://127.0.0.1:4985/$dbName/' --header \"Authorization: Basic $digest\"  --header 'Content-Type: application/json' --data-raw '{\"bucket\": \"$bucketName\", \"num_index_replicas\": 0, \"use_views\": true}'"
}

function vagrantInstallXdcrDiffer {
	local clusterName="$1"
	local differDir="$2"
	local idx="$(getClusterIdx "$clusterName")"

	vagrantAptInstall "$idx" "git"
	vagrantAptInstall "$idx" "golang-go"

	${VSSH[$idx]} "mkdir -p $differDir"
	${VSSH[$idx]} "git clone https://github.com/couchbaselabs/xdcrDiffer.git $differDir"
	cmd="${VSSH[$i]} \"cd /home/vagrant/xdcrDiffer; make clean; make deps; make\""
	echo "==== Running $cmd ===="
	eval $cmd
}

function vagrantValidatePrometheusPipelineStatusIs1 {
	local node=$1
	local sourceBucket=$2
	local targetBucket=$3
	local pipelineType=$4
	local statusType=$5
	local idx="$(getClusterIdx "$node")"
	local output
	local prometheusOut
	local tmpFile="/tmp/vagrantPrometheusOut"

	local idx="$(getClusterIdx "$node")"

	prometheusOut=$(${VSSH[$idx]} "curl -X GET -u $DEFAULT_ADMIN:$DEFAULT_PW http://127.0.0.1:9998/_prometheusMetrics")
	prometheusOut=$(echo "$prometheusOut" | tr -d '\r')
	validatePrometheusPipelineStatusIs1Internal "$sourceBucket" "$targetBucket" "$pipelineType" "$statusType" "$prometheusOut"
}
