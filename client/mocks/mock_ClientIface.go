// Code generated by mockery. DO NOT EDIT.

package mocks

import (
	io "io"

	gomemcached "github.com/couchbase/gomemcached"

	memcached "github.com/couchbase/gomemcached/client"

	mock "github.com/stretchr/testify/mock"

	time "time"
)

// ClientIface is an autogenerated mock type for the ClientIface type
type ClientIface struct {
	mock.Mock
}

type ClientIface_Expecter struct {
	mock *mock.Mock
}

func (_m *ClientIface) EXPECT() *ClientIface_Expecter {
	return &ClientIface_Expecter{mock: &_m.Mock}
}

// Add provides a mock function with given fields: vb, key, flags, exp, body, context
func (_m *ClientIface) Add(vb uint16, key string, flags int, exp int, body []byte, context ...*memcached.ClientContext) (*gomemcached.MCResponse, error) {
	_va := make([]interface{}, len(context))
	for _i := range context {
		_va[_i] = context[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, vb, key, flags, exp, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gomemcached.MCResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(uint16, string, int, int, []byte, ...*memcached.ClientContext) (*gomemcached.MCResponse, error)); ok {
		return rf(vb, key, flags, exp, body, context...)
	}
	if rf, ok := ret.Get(0).(func(uint16, string, int, int, []byte, ...*memcached.ClientContext) *gomemcached.MCResponse); ok {
		r0 = rf(vb, key, flags, exp, body, context...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gomemcached.MCResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(uint16, string, int, int, []byte, ...*memcached.ClientContext) error); ok {
		r1 = rf(vb, key, flags, exp, body, context...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientIface_Add_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Add'
type ClientIface_Add_Call struct {
	*mock.Call
}

// Add is a helper method to define mock.On call
//   - vb uint16
//   - key string
//   - flags int
//   - exp int
//   - body []byte
//   - context ...*memcached.ClientContext
func (_e *ClientIface_Expecter) Add(vb interface{}, key interface{}, flags interface{}, exp interface{}, body interface{}, context ...interface{}) *ClientIface_Add_Call {
	return &ClientIface_Add_Call{Call: _e.mock.On("Add",
		append([]interface{}{vb, key, flags, exp, body}, context...)...)}
}

func (_c *ClientIface_Add_Call) Run(run func(vb uint16, key string, flags int, exp int, body []byte, context ...*memcached.ClientContext)) *ClientIface_Add_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]*memcached.ClientContext, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(*memcached.ClientContext)
			}
		}
		run(args[0].(uint16), args[1].(string), args[2].(int), args[3].(int), args[4].([]byte), variadicArgs...)
	})
	return _c
}

func (_c *ClientIface_Add_Call) Return(_a0 *gomemcached.MCResponse, _a1 error) *ClientIface_Add_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientIface_Add_Call) RunAndReturn(run func(uint16, string, int, int, []byte, ...*memcached.ClientContext) (*gomemcached.MCResponse, error)) *ClientIface_Add_Call {
	_c.Call.Return(run)
	return _c
}

// Append provides a mock function with given fields: vb, key, data, context
func (_m *ClientIface) Append(vb uint16, key string, data []byte, context ...*memcached.ClientContext) (*gomemcached.MCResponse, error) {
	_va := make([]interface{}, len(context))
	for _i := range context {
		_va[_i] = context[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, vb, key, data)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gomemcached.MCResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(uint16, string, []byte, ...*memcached.ClientContext) (*gomemcached.MCResponse, error)); ok {
		return rf(vb, key, data, context...)
	}
	if rf, ok := ret.Get(0).(func(uint16, string, []byte, ...*memcached.ClientContext) *gomemcached.MCResponse); ok {
		r0 = rf(vb, key, data, context...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gomemcached.MCResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(uint16, string, []byte, ...*memcached.ClientContext) error); ok {
		r1 = rf(vb, key, data, context...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientIface_Append_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Append'
type ClientIface_Append_Call struct {
	*mock.Call
}

// Append is a helper method to define mock.On call
//   - vb uint16
//   - key string
//   - data []byte
//   - context ...*memcached.ClientContext
func (_e *ClientIface_Expecter) Append(vb interface{}, key interface{}, data interface{}, context ...interface{}) *ClientIface_Append_Call {
	return &ClientIface_Append_Call{Call: _e.mock.On("Append",
		append([]interface{}{vb, key, data}, context...)...)}
}

func (_c *ClientIface_Append_Call) Run(run func(vb uint16, key string, data []byte, context ...*memcached.ClientContext)) *ClientIface_Append_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]*memcached.ClientContext, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(*memcached.ClientContext)
			}
		}
		run(args[0].(uint16), args[1].(string), args[2].([]byte), variadicArgs...)
	})
	return _c
}

func (_c *ClientIface_Append_Call) Return(_a0 *gomemcached.MCResponse, _a1 error) *ClientIface_Append_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientIface_Append_Call) RunAndReturn(run func(uint16, string, []byte, ...*memcached.ClientContext) (*gomemcached.MCResponse, error)) *ClientIface_Append_Call {
	_c.Call.Return(run)
	return _c
}

// Auth provides a mock function with given fields: user, pass
func (_m *ClientIface) Auth(user string, pass string) (*gomemcached.MCResponse, error) {
	ret := _m.Called(user, pass)

	var r0 *gomemcached.MCResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string) (*gomemcached.MCResponse, error)); ok {
		return rf(user, pass)
	}
	if rf, ok := ret.Get(0).(func(string, string) *gomemcached.MCResponse); ok {
		r0 = rf(user, pass)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gomemcached.MCResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(user, pass)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientIface_Auth_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Auth'
type ClientIface_Auth_Call struct {
	*mock.Call
}

// Auth is a helper method to define mock.On call
//   - user string
//   - pass string
func (_e *ClientIface_Expecter) Auth(user interface{}, pass interface{}) *ClientIface_Auth_Call {
	return &ClientIface_Auth_Call{Call: _e.mock.On("Auth", user, pass)}
}

func (_c *ClientIface_Auth_Call) Run(run func(user string, pass string)) *ClientIface_Auth_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *ClientIface_Auth_Call) Return(_a0 *gomemcached.MCResponse, _a1 error) *ClientIface_Auth_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientIface_Auth_Call) RunAndReturn(run func(string, string) (*gomemcached.MCResponse, error)) *ClientIface_Auth_Call {
	_c.Call.Return(run)
	return _c
}

// AuthList provides a mock function with given fields:
func (_m *ClientIface) AuthList() (*gomemcached.MCResponse, error) {
	ret := _m.Called()

	var r0 *gomemcached.MCResponse
	var r1 error
	if rf, ok := ret.Get(0).(func() (*gomemcached.MCResponse, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() *gomemcached.MCResponse); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gomemcached.MCResponse)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientIface_AuthList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AuthList'
type ClientIface_AuthList_Call struct {
	*mock.Call
}

// AuthList is a helper method to define mock.On call
func (_e *ClientIface_Expecter) AuthList() *ClientIface_AuthList_Call {
	return &ClientIface_AuthList_Call{Call: _e.mock.On("AuthList")}
}

func (_c *ClientIface_AuthList_Call) Run(run func()) *ClientIface_AuthList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ClientIface_AuthList_Call) Return(_a0 *gomemcached.MCResponse, _a1 error) *ClientIface_AuthList_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientIface_AuthList_Call) RunAndReturn(run func() (*gomemcached.MCResponse, error)) *ClientIface_AuthList_Call {
	_c.Call.Return(run)
	return _c
}

// AuthPlain provides a mock function with given fields: user, pass
func (_m *ClientIface) AuthPlain(user string, pass string) (*gomemcached.MCResponse, error) {
	ret := _m.Called(user, pass)

	var r0 *gomemcached.MCResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string) (*gomemcached.MCResponse, error)); ok {
		return rf(user, pass)
	}
	if rf, ok := ret.Get(0).(func(string, string) *gomemcached.MCResponse); ok {
		r0 = rf(user, pass)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gomemcached.MCResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(user, pass)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientIface_AuthPlain_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AuthPlain'
type ClientIface_AuthPlain_Call struct {
	*mock.Call
}

// AuthPlain is a helper method to define mock.On call
//   - user string
//   - pass string
func (_e *ClientIface_Expecter) AuthPlain(user interface{}, pass interface{}) *ClientIface_AuthPlain_Call {
	return &ClientIface_AuthPlain_Call{Call: _e.mock.On("AuthPlain", user, pass)}
}

func (_c *ClientIface_AuthPlain_Call) Run(run func(user string, pass string)) *ClientIface_AuthPlain_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *ClientIface_AuthPlain_Call) Return(_a0 *gomemcached.MCResponse, _a1 error) *ClientIface_AuthPlain_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientIface_AuthPlain_Call) RunAndReturn(run func(string, string) (*gomemcached.MCResponse, error)) *ClientIface_AuthPlain_Call {
	_c.Call.Return(run)
	return _c
}

// AuthScramSha provides a mock function with given fields: user, pass
func (_m *ClientIface) AuthScramSha(user string, pass string) (*gomemcached.MCResponse, error) {
	ret := _m.Called(user, pass)

	var r0 *gomemcached.MCResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string) (*gomemcached.MCResponse, error)); ok {
		return rf(user, pass)
	}
	if rf, ok := ret.Get(0).(func(string, string) *gomemcached.MCResponse); ok {
		r0 = rf(user, pass)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gomemcached.MCResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(user, pass)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientIface_AuthScramSha_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AuthScramSha'
type ClientIface_AuthScramSha_Call struct {
	*mock.Call
}

// AuthScramSha is a helper method to define mock.On call
//   - user string
//   - pass string
func (_e *ClientIface_Expecter) AuthScramSha(user interface{}, pass interface{}) *ClientIface_AuthScramSha_Call {
	return &ClientIface_AuthScramSha_Call{Call: _e.mock.On("AuthScramSha", user, pass)}
}

func (_c *ClientIface_AuthScramSha_Call) Run(run func(user string, pass string)) *ClientIface_AuthScramSha_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *ClientIface_AuthScramSha_Call) Return(_a0 *gomemcached.MCResponse, _a1 error) *ClientIface_AuthScramSha_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientIface_AuthScramSha_Call) RunAndReturn(run func(string, string) (*gomemcached.MCResponse, error)) *ClientIface_AuthScramSha_Call {
	_c.Call.Return(run)
	return _c
}

// CAS provides a mock function with given fields: vb, k, f, initexp
func (_m *ClientIface) CAS(vb uint16, k string, f memcached.CasFunc, initexp int) (*gomemcached.MCResponse, error) {
	ret := _m.Called(vb, k, f, initexp)

	var r0 *gomemcached.MCResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(uint16, string, memcached.CasFunc, int) (*gomemcached.MCResponse, error)); ok {
		return rf(vb, k, f, initexp)
	}
	if rf, ok := ret.Get(0).(func(uint16, string, memcached.CasFunc, int) *gomemcached.MCResponse); ok {
		r0 = rf(vb, k, f, initexp)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gomemcached.MCResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(uint16, string, memcached.CasFunc, int) error); ok {
		r1 = rf(vb, k, f, initexp)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientIface_CAS_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CAS'
type ClientIface_CAS_Call struct {
	*mock.Call
}

// CAS is a helper method to define mock.On call
//   - vb uint16
//   - k string
//   - f memcached.CasFunc
//   - initexp int
func (_e *ClientIface_Expecter) CAS(vb interface{}, k interface{}, f interface{}, initexp interface{}) *ClientIface_CAS_Call {
	return &ClientIface_CAS_Call{Call: _e.mock.On("CAS", vb, k, f, initexp)}
}

func (_c *ClientIface_CAS_Call) Run(run func(vb uint16, k string, f memcached.CasFunc, initexp int)) *ClientIface_CAS_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint16), args[1].(string), args[2].(memcached.CasFunc), args[3].(int))
	})
	return _c
}

func (_c *ClientIface_CAS_Call) Return(_a0 *gomemcached.MCResponse, _a1 error) *ClientIface_CAS_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientIface_CAS_Call) RunAndReturn(run func(uint16, string, memcached.CasFunc, int) (*gomemcached.MCResponse, error)) *ClientIface_CAS_Call {
	_c.Call.Return(run)
	return _c
}

// CASNext provides a mock function with given fields: vb, k, exp, state
func (_m *ClientIface) CASNext(vb uint16, k string, exp int, state *memcached.CASState) bool {
	ret := _m.Called(vb, k, exp, state)

	var r0 bool
	if rf, ok := ret.Get(0).(func(uint16, string, int, *memcached.CASState) bool); ok {
		r0 = rf(vb, k, exp, state)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// ClientIface_CASNext_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CASNext'
type ClientIface_CASNext_Call struct {
	*mock.Call
}

// CASNext is a helper method to define mock.On call
//   - vb uint16
//   - k string
//   - exp int
//   - state *memcached.CASState
func (_e *ClientIface_Expecter) CASNext(vb interface{}, k interface{}, exp interface{}, state interface{}) *ClientIface_CASNext_Call {
	return &ClientIface_CASNext_Call{Call: _e.mock.On("CASNext", vb, k, exp, state)}
}

func (_c *ClientIface_CASNext_Call) Run(run func(vb uint16, k string, exp int, state *memcached.CASState)) *ClientIface_CASNext_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint16), args[1].(string), args[2].(int), args[3].(*memcached.CASState))
	})
	return _c
}

func (_c *ClientIface_CASNext_Call) Return(_a0 bool) *ClientIface_CASNext_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ClientIface_CASNext_Call) RunAndReturn(run func(uint16, string, int, *memcached.CASState) bool) *ClientIface_CASNext_Call {
	_c.Call.Return(run)
	return _c
}

// CancelRangeScan provides a mock function with given fields: vb, uuid, opaque, context
func (_m *ClientIface) CancelRangeScan(vb uint16, uuid []byte, opaque uint32, context ...*memcached.ClientContext) (*gomemcached.MCResponse, error) {
	_va := make([]interface{}, len(context))
	for _i := range context {
		_va[_i] = context[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, vb, uuid, opaque)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gomemcached.MCResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(uint16, []byte, uint32, ...*memcached.ClientContext) (*gomemcached.MCResponse, error)); ok {
		return rf(vb, uuid, opaque, context...)
	}
	if rf, ok := ret.Get(0).(func(uint16, []byte, uint32, ...*memcached.ClientContext) *gomemcached.MCResponse); ok {
		r0 = rf(vb, uuid, opaque, context...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gomemcached.MCResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(uint16, []byte, uint32, ...*memcached.ClientContext) error); ok {
		r1 = rf(vb, uuid, opaque, context...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientIface_CancelRangeScan_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CancelRangeScan'
type ClientIface_CancelRangeScan_Call struct {
	*mock.Call
}

// CancelRangeScan is a helper method to define mock.On call
//   - vb uint16
//   - uuid []byte
//   - opaque uint32
//   - context ...*memcached.ClientContext
func (_e *ClientIface_Expecter) CancelRangeScan(vb interface{}, uuid interface{}, opaque interface{}, context ...interface{}) *ClientIface_CancelRangeScan_Call {
	return &ClientIface_CancelRangeScan_Call{Call: _e.mock.On("CancelRangeScan",
		append([]interface{}{vb, uuid, opaque}, context...)...)}
}

func (_c *ClientIface_CancelRangeScan_Call) Run(run func(vb uint16, uuid []byte, opaque uint32, context ...*memcached.ClientContext)) *ClientIface_CancelRangeScan_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]*memcached.ClientContext, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(*memcached.ClientContext)
			}
		}
		run(args[0].(uint16), args[1].([]byte), args[2].(uint32), variadicArgs...)
	})
	return _c
}

func (_c *ClientIface_CancelRangeScan_Call) Return(_a0 *gomemcached.MCResponse, _a1 error) *ClientIface_CancelRangeScan_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientIface_CancelRangeScan_Call) RunAndReturn(run func(uint16, []byte, uint32, ...*memcached.ClientContext) (*gomemcached.MCResponse, error)) *ClientIface_CancelRangeScan_Call {
	_c.Call.Return(run)
	return _c
}

// Close provides a mock function with given fields:
func (_m *ClientIface) Close() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ClientIface_Close_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Close'
type ClientIface_Close_Call struct {
	*mock.Call
}

// Close is a helper method to define mock.On call
func (_e *ClientIface_Expecter) Close() *ClientIface_Close_Call {
	return &ClientIface_Close_Call{Call: _e.mock.On("Close")}
}

func (_c *ClientIface_Close_Call) Run(run func()) *ClientIface_Close_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ClientIface_Close_Call) Return(_a0 error) *ClientIface_Close_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ClientIface_Close_Call) RunAndReturn(run func() error) *ClientIface_Close_Call {
	_c.Call.Return(run)
	return _c
}

// CollectionEnabled provides a mock function with given fields:
func (_m *ClientIface) CollectionEnabled() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// ClientIface_CollectionEnabled_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CollectionEnabled'
type ClientIface_CollectionEnabled_Call struct {
	*mock.Call
}

// CollectionEnabled is a helper method to define mock.On call
func (_e *ClientIface_Expecter) CollectionEnabled() *ClientIface_CollectionEnabled_Call {
	return &ClientIface_CollectionEnabled_Call{Call: _e.mock.On("CollectionEnabled")}
}

func (_c *ClientIface_CollectionEnabled_Call) Run(run func()) *ClientIface_CollectionEnabled_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ClientIface_CollectionEnabled_Call) Return(_a0 bool) *ClientIface_CollectionEnabled_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ClientIface_CollectionEnabled_Call) RunAndReturn(run func() bool) *ClientIface_CollectionEnabled_Call {
	_c.Call.Return(run)
	return _c
}

// CollectionsGetCID provides a mock function with given fields: scope, collection
func (_m *ClientIface) CollectionsGetCID(scope string, collection string) (*gomemcached.MCResponse, error) {
	ret := _m.Called(scope, collection)

	var r0 *gomemcached.MCResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string) (*gomemcached.MCResponse, error)); ok {
		return rf(scope, collection)
	}
	if rf, ok := ret.Get(0).(func(string, string) *gomemcached.MCResponse); ok {
		r0 = rf(scope, collection)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gomemcached.MCResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(scope, collection)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientIface_CollectionsGetCID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CollectionsGetCID'
type ClientIface_CollectionsGetCID_Call struct {
	*mock.Call
}

// CollectionsGetCID is a helper method to define mock.On call
//   - scope string
//   - collection string
func (_e *ClientIface_Expecter) CollectionsGetCID(scope interface{}, collection interface{}) *ClientIface_CollectionsGetCID_Call {
	return &ClientIface_CollectionsGetCID_Call{Call: _e.mock.On("CollectionsGetCID", scope, collection)}
}

func (_c *ClientIface_CollectionsGetCID_Call) Run(run func(scope string, collection string)) *ClientIface_CollectionsGetCID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *ClientIface_CollectionsGetCID_Call) Return(_a0 *gomemcached.MCResponse, _a1 error) *ClientIface_CollectionsGetCID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientIface_CollectionsGetCID_Call) RunAndReturn(run func(string, string) (*gomemcached.MCResponse, error)) *ClientIface_CollectionsGetCID_Call {
	_c.Call.Return(run)
	return _c
}

// ContinueRangeScan provides a mock function with given fields: vb, uuid, opaque, items, maxSize, timeout, context
func (_m *ClientIface) ContinueRangeScan(vb uint16, uuid []byte, opaque uint32, items uint32, maxSize uint32, timeout uint32, context ...*memcached.ClientContext) error {
	_va := make([]interface{}, len(context))
	for _i := range context {
		_va[_i] = context[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, vb, uuid, opaque, items, maxSize, timeout)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(uint16, []byte, uint32, uint32, uint32, uint32, ...*memcached.ClientContext) error); ok {
		r0 = rf(vb, uuid, opaque, items, maxSize, timeout, context...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ClientIface_ContinueRangeScan_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ContinueRangeScan'
type ClientIface_ContinueRangeScan_Call struct {
	*mock.Call
}

// ContinueRangeScan is a helper method to define mock.On call
//   - vb uint16
//   - uuid []byte
//   - opaque uint32
//   - items uint32
//   - maxSize uint32
//   - timeout uint32
//   - context ...*memcached.ClientContext
func (_e *ClientIface_Expecter) ContinueRangeScan(vb interface{}, uuid interface{}, opaque interface{}, items interface{}, maxSize interface{}, timeout interface{}, context ...interface{}) *ClientIface_ContinueRangeScan_Call {
	return &ClientIface_ContinueRangeScan_Call{Call: _e.mock.On("ContinueRangeScan",
		append([]interface{}{vb, uuid, opaque, items, maxSize, timeout}, context...)...)}
}

func (_c *ClientIface_ContinueRangeScan_Call) Run(run func(vb uint16, uuid []byte, opaque uint32, items uint32, maxSize uint32, timeout uint32, context ...*memcached.ClientContext)) *ClientIface_ContinueRangeScan_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]*memcached.ClientContext, len(args)-6)
		for i, a := range args[6:] {
			if a != nil {
				variadicArgs[i] = a.(*memcached.ClientContext)
			}
		}
		run(args[0].(uint16), args[1].([]byte), args[2].(uint32), args[3].(uint32), args[4].(uint32), args[5].(uint32), variadicArgs...)
	})
	return _c
}

func (_c *ClientIface_ContinueRangeScan_Call) Return(_a0 error) *ClientIface_ContinueRangeScan_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ClientIface_ContinueRangeScan_Call) RunAndReturn(run func(uint16, []byte, uint32, uint32, uint32, uint32, ...*memcached.ClientContext) error) *ClientIface_ContinueRangeScan_Call {
	_c.Call.Return(run)
	return _c
}

// CreateRandomScan provides a mock function with given fields: vb, collId, sampleSize, withDocs, context
func (_m *ClientIface) CreateRandomScan(vb uint16, collId uint32, sampleSize int, withDocs bool, context ...*memcached.ClientContext) (*gomemcached.MCResponse, error) {
	_va := make([]interface{}, len(context))
	for _i := range context {
		_va[_i] = context[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, vb, collId, sampleSize, withDocs)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gomemcached.MCResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(uint16, uint32, int, bool, ...*memcached.ClientContext) (*gomemcached.MCResponse, error)); ok {
		return rf(vb, collId, sampleSize, withDocs, context...)
	}
	if rf, ok := ret.Get(0).(func(uint16, uint32, int, bool, ...*memcached.ClientContext) *gomemcached.MCResponse); ok {
		r0 = rf(vb, collId, sampleSize, withDocs, context...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gomemcached.MCResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(uint16, uint32, int, bool, ...*memcached.ClientContext) error); ok {
		r1 = rf(vb, collId, sampleSize, withDocs, context...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientIface_CreateRandomScan_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateRandomScan'
type ClientIface_CreateRandomScan_Call struct {
	*mock.Call
}

// CreateRandomScan is a helper method to define mock.On call
//   - vb uint16
//   - collId uint32
//   - sampleSize int
//   - withDocs bool
//   - context ...*memcached.ClientContext
func (_e *ClientIface_Expecter) CreateRandomScan(vb interface{}, collId interface{}, sampleSize interface{}, withDocs interface{}, context ...interface{}) *ClientIface_CreateRandomScan_Call {
	return &ClientIface_CreateRandomScan_Call{Call: _e.mock.On("CreateRandomScan",
		append([]interface{}{vb, collId, sampleSize, withDocs}, context...)...)}
}

func (_c *ClientIface_CreateRandomScan_Call) Run(run func(vb uint16, collId uint32, sampleSize int, withDocs bool, context ...*memcached.ClientContext)) *ClientIface_CreateRandomScan_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]*memcached.ClientContext, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(*memcached.ClientContext)
			}
		}
		run(args[0].(uint16), args[1].(uint32), args[2].(int), args[3].(bool), variadicArgs...)
	})
	return _c
}

func (_c *ClientIface_CreateRandomScan_Call) Return(_a0 *gomemcached.MCResponse, _a1 error) *ClientIface_CreateRandomScan_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientIface_CreateRandomScan_Call) RunAndReturn(run func(uint16, uint32, int, bool, ...*memcached.ClientContext) (*gomemcached.MCResponse, error)) *ClientIface_CreateRandomScan_Call {
	_c.Call.Return(run)
	return _c
}

// CreateRangeScan provides a mock function with given fields: vb, collId, start, excludeStart, end, excludeEnd, withDocs, context
func (_m *ClientIface) CreateRangeScan(vb uint16, collId uint32, start []byte, excludeStart bool, end []byte, excludeEnd bool, withDocs bool, context ...*memcached.ClientContext) (*gomemcached.MCResponse, error) {
	_va := make([]interface{}, len(context))
	for _i := range context {
		_va[_i] = context[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, vb, collId, start, excludeStart, end, excludeEnd, withDocs)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gomemcached.MCResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(uint16, uint32, []byte, bool, []byte, bool, bool, ...*memcached.ClientContext) (*gomemcached.MCResponse, error)); ok {
		return rf(vb, collId, start, excludeStart, end, excludeEnd, withDocs, context...)
	}
	if rf, ok := ret.Get(0).(func(uint16, uint32, []byte, bool, []byte, bool, bool, ...*memcached.ClientContext) *gomemcached.MCResponse); ok {
		r0 = rf(vb, collId, start, excludeStart, end, excludeEnd, withDocs, context...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gomemcached.MCResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(uint16, uint32, []byte, bool, []byte, bool, bool, ...*memcached.ClientContext) error); ok {
		r1 = rf(vb, collId, start, excludeStart, end, excludeEnd, withDocs, context...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientIface_CreateRangeScan_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateRangeScan'
type ClientIface_CreateRangeScan_Call struct {
	*mock.Call
}

// CreateRangeScan is a helper method to define mock.On call
//   - vb uint16
//   - collId uint32
//   - start []byte
//   - excludeStart bool
//   - end []byte
//   - excludeEnd bool
//   - withDocs bool
//   - context ...*memcached.ClientContext
func (_e *ClientIface_Expecter) CreateRangeScan(vb interface{}, collId interface{}, start interface{}, excludeStart interface{}, end interface{}, excludeEnd interface{}, withDocs interface{}, context ...interface{}) *ClientIface_CreateRangeScan_Call {
	return &ClientIface_CreateRangeScan_Call{Call: _e.mock.On("CreateRangeScan",
		append([]interface{}{vb, collId, start, excludeStart, end, excludeEnd, withDocs}, context...)...)}
}

func (_c *ClientIface_CreateRangeScan_Call) Run(run func(vb uint16, collId uint32, start []byte, excludeStart bool, end []byte, excludeEnd bool, withDocs bool, context ...*memcached.ClientContext)) *ClientIface_CreateRangeScan_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]*memcached.ClientContext, len(args)-7)
		for i, a := range args[7:] {
			if a != nil {
				variadicArgs[i] = a.(*memcached.ClientContext)
			}
		}
		run(args[0].(uint16), args[1].(uint32), args[2].([]byte), args[3].(bool), args[4].([]byte), args[5].(bool), args[6].(bool), variadicArgs...)
	})
	return _c
}

func (_c *ClientIface_CreateRangeScan_Call) Return(_a0 *gomemcached.MCResponse, _a1 error) *ClientIface_CreateRangeScan_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientIface_CreateRangeScan_Call) RunAndReturn(run func(uint16, uint32, []byte, bool, []byte, bool, bool, ...*memcached.ClientContext) (*gomemcached.MCResponse, error)) *ClientIface_CreateRangeScan_Call {
	_c.Call.Return(run)
	return _c
}

// Decr provides a mock function with given fields: vb, key, amt, def, exp, context
func (_m *ClientIface) Decr(vb uint16, key string, amt uint64, def uint64, exp int, context ...*memcached.ClientContext) (uint64, error) {
	_va := make([]interface{}, len(context))
	for _i := range context {
		_va[_i] = context[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, vb, key, amt, def, exp)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(uint16, string, uint64, uint64, int, ...*memcached.ClientContext) (uint64, error)); ok {
		return rf(vb, key, amt, def, exp, context...)
	}
	if rf, ok := ret.Get(0).(func(uint16, string, uint64, uint64, int, ...*memcached.ClientContext) uint64); ok {
		r0 = rf(vb, key, amt, def, exp, context...)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(uint16, string, uint64, uint64, int, ...*memcached.ClientContext) error); ok {
		r1 = rf(vb, key, amt, def, exp, context...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientIface_Decr_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Decr'
type ClientIface_Decr_Call struct {
	*mock.Call
}

// Decr is a helper method to define mock.On call
//   - vb uint16
//   - key string
//   - amt uint64
//   - def uint64
//   - exp int
//   - context ...*memcached.ClientContext
func (_e *ClientIface_Expecter) Decr(vb interface{}, key interface{}, amt interface{}, def interface{}, exp interface{}, context ...interface{}) *ClientIface_Decr_Call {
	return &ClientIface_Decr_Call{Call: _e.mock.On("Decr",
		append([]interface{}{vb, key, amt, def, exp}, context...)...)}
}

func (_c *ClientIface_Decr_Call) Run(run func(vb uint16, key string, amt uint64, def uint64, exp int, context ...*memcached.ClientContext)) *ClientIface_Decr_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]*memcached.ClientContext, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(*memcached.ClientContext)
			}
		}
		run(args[0].(uint16), args[1].(string), args[2].(uint64), args[3].(uint64), args[4].(int), variadicArgs...)
	})
	return _c
}

func (_c *ClientIface_Decr_Call) Return(_a0 uint64, _a1 error) *ClientIface_Decr_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientIface_Decr_Call) RunAndReturn(run func(uint16, string, uint64, uint64, int, ...*memcached.ClientContext) (uint64, error)) *ClientIface_Decr_Call {
	_c.Call.Return(run)
	return _c
}

// Del provides a mock function with given fields: vb, key, context
func (_m *ClientIface) Del(vb uint16, key string, context ...*memcached.ClientContext) (*gomemcached.MCResponse, error) {
	_va := make([]interface{}, len(context))
	for _i := range context {
		_va[_i] = context[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, vb, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gomemcached.MCResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(uint16, string, ...*memcached.ClientContext) (*gomemcached.MCResponse, error)); ok {
		return rf(vb, key, context...)
	}
	if rf, ok := ret.Get(0).(func(uint16, string, ...*memcached.ClientContext) *gomemcached.MCResponse); ok {
		r0 = rf(vb, key, context...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gomemcached.MCResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(uint16, string, ...*memcached.ClientContext) error); ok {
		r1 = rf(vb, key, context...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientIface_Del_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Del'
type ClientIface_Del_Call struct {
	*mock.Call
}

// Del is a helper method to define mock.On call
//   - vb uint16
//   - key string
//   - context ...*memcached.ClientContext
func (_e *ClientIface_Expecter) Del(vb interface{}, key interface{}, context ...interface{}) *ClientIface_Del_Call {
	return &ClientIface_Del_Call{Call: _e.mock.On("Del",
		append([]interface{}{vb, key}, context...)...)}
}

func (_c *ClientIface_Del_Call) Run(run func(vb uint16, key string, context ...*memcached.ClientContext)) *ClientIface_Del_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]*memcached.ClientContext, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(*memcached.ClientContext)
			}
		}
		run(args[0].(uint16), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *ClientIface_Del_Call) Return(_a0 *gomemcached.MCResponse, _a1 error) *ClientIface_Del_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientIface_Del_Call) RunAndReturn(run func(uint16, string, ...*memcached.ClientContext) (*gomemcached.MCResponse, error)) *ClientIface_Del_Call {
	_c.Call.Return(run)
	return _c
}

// EnableDataPool provides a mock function with given fields: getter, doneCb
func (_m *ClientIface) EnableDataPool(getter func(uint64) ([]byte, error), doneCb func([]byte)) error {
	ret := _m.Called(getter, doneCb)

	var r0 error
	if rf, ok := ret.Get(0).(func(func(uint64) ([]byte, error), func([]byte)) error); ok {
		r0 = rf(getter, doneCb)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ClientIface_EnableDataPool_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EnableDataPool'
type ClientIface_EnableDataPool_Call struct {
	*mock.Call
}

// EnableDataPool is a helper method to define mock.On call
//   - getter func(uint64)([]byte , error)
//   - doneCb func([]byte)
func (_e *ClientIface_Expecter) EnableDataPool(getter interface{}, doneCb interface{}) *ClientIface_EnableDataPool_Call {
	return &ClientIface_EnableDataPool_Call{Call: _e.mock.On("EnableDataPool", getter, doneCb)}
}

func (_c *ClientIface_EnableDataPool_Call) Run(run func(getter func(uint64) ([]byte, error), doneCb func([]byte))) *ClientIface_EnableDataPool_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(func(uint64) ([]byte, error)), args[1].(func([]byte)))
	})
	return _c
}

func (_c *ClientIface_EnableDataPool_Call) Return(_a0 error) *ClientIface_EnableDataPool_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ClientIface_EnableDataPool_Call) RunAndReturn(run func(func(uint64) ([]byte, error), func([]byte)) error) *ClientIface_EnableDataPool_Call {
	_c.Call.Return(run)
	return _c
}

// EnableFeatures provides a mock function with given fields: features
func (_m *ClientIface) EnableFeatures(features memcached.Features) (*gomemcached.MCResponse, error) {
	ret := _m.Called(features)

	var r0 *gomemcached.MCResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(memcached.Features) (*gomemcached.MCResponse, error)); ok {
		return rf(features)
	}
	if rf, ok := ret.Get(0).(func(memcached.Features) *gomemcached.MCResponse); ok {
		r0 = rf(features)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gomemcached.MCResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(memcached.Features) error); ok {
		r1 = rf(features)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientIface_EnableFeatures_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EnableFeatures'
type ClientIface_EnableFeatures_Call struct {
	*mock.Call
}

// EnableFeatures is a helper method to define mock.On call
//   - features memcached.Features
func (_e *ClientIface_Expecter) EnableFeatures(features interface{}) *ClientIface_EnableFeatures_Call {
	return &ClientIface_EnableFeatures_Call{Call: _e.mock.On("EnableFeatures", features)}
}

func (_c *ClientIface_EnableFeatures_Call) Run(run func(features memcached.Features)) *ClientIface_EnableFeatures_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(memcached.Features))
	})
	return _c
}

func (_c *ClientIface_EnableFeatures_Call) Return(_a0 *gomemcached.MCResponse, _a1 error) *ClientIface_EnableFeatures_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientIface_EnableFeatures_Call) RunAndReturn(run func(memcached.Features) (*gomemcached.MCResponse, error)) *ClientIface_EnableFeatures_Call {
	_c.Call.Return(run)
	return _c
}

// EnableMutationToken provides a mock function with given fields:
func (_m *ClientIface) EnableMutationToken() (*gomemcached.MCResponse, error) {
	ret := _m.Called()

	var r0 *gomemcached.MCResponse
	var r1 error
	if rf, ok := ret.Get(0).(func() (*gomemcached.MCResponse, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() *gomemcached.MCResponse); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gomemcached.MCResponse)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientIface_EnableMutationToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EnableMutationToken'
type ClientIface_EnableMutationToken_Call struct {
	*mock.Call
}

// EnableMutationToken is a helper method to define mock.On call
func (_e *ClientIface_Expecter) EnableMutationToken() *ClientIface_EnableMutationToken_Call {
	return &ClientIface_EnableMutationToken_Call{Call: _e.mock.On("EnableMutationToken")}
}

func (_c *ClientIface_EnableMutationToken_Call) Run(run func()) *ClientIface_EnableMutationToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ClientIface_EnableMutationToken_Call) Return(_a0 *gomemcached.MCResponse, _a1 error) *ClientIface_EnableMutationToken_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientIface_EnableMutationToken_Call) RunAndReturn(run func() (*gomemcached.MCResponse, error)) *ClientIface_EnableMutationToken_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function with given fields: vb, key, context
func (_m *ClientIface) Get(vb uint16, key string, context ...*memcached.ClientContext) (*gomemcached.MCResponse, error) {
	_va := make([]interface{}, len(context))
	for _i := range context {
		_va[_i] = context[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, vb, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gomemcached.MCResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(uint16, string, ...*memcached.ClientContext) (*gomemcached.MCResponse, error)); ok {
		return rf(vb, key, context...)
	}
	if rf, ok := ret.Get(0).(func(uint16, string, ...*memcached.ClientContext) *gomemcached.MCResponse); ok {
		r0 = rf(vb, key, context...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gomemcached.MCResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(uint16, string, ...*memcached.ClientContext) error); ok {
		r1 = rf(vb, key, context...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientIface_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type ClientIface_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - vb uint16
//   - key string
//   - context ...*memcached.ClientContext
func (_e *ClientIface_Expecter) Get(vb interface{}, key interface{}, context ...interface{}) *ClientIface_Get_Call {
	return &ClientIface_Get_Call{Call: _e.mock.On("Get",
		append([]interface{}{vb, key}, context...)...)}
}

func (_c *ClientIface_Get_Call) Run(run func(vb uint16, key string, context ...*memcached.ClientContext)) *ClientIface_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]*memcached.ClientContext, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(*memcached.ClientContext)
			}
		}
		run(args[0].(uint16), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *ClientIface_Get_Call) Return(_a0 *gomemcached.MCResponse, _a1 error) *ClientIface_Get_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientIface_Get_Call) RunAndReturn(run func(uint16, string, ...*memcached.ClientContext) (*gomemcached.MCResponse, error)) *ClientIface_Get_Call {
	_c.Call.Return(run)
	return _c
}

// GetAllVbSeqnos provides a mock function with given fields: vbSeqnoMap, context
func (_m *ClientIface) GetAllVbSeqnos(vbSeqnoMap map[uint16]uint64, context ...*memcached.ClientContext) (map[uint16]uint64, error) {
	_va := make([]interface{}, len(context))
	for _i := range context {
		_va[_i] = context[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, vbSeqnoMap)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 map[uint16]uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(map[uint16]uint64, ...*memcached.ClientContext) (map[uint16]uint64, error)); ok {
		return rf(vbSeqnoMap, context...)
	}
	if rf, ok := ret.Get(0).(func(map[uint16]uint64, ...*memcached.ClientContext) map[uint16]uint64); ok {
		r0 = rf(vbSeqnoMap, context...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[uint16]uint64)
		}
	}

	if rf, ok := ret.Get(1).(func(map[uint16]uint64, ...*memcached.ClientContext) error); ok {
		r1 = rf(vbSeqnoMap, context...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientIface_GetAllVbSeqnos_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllVbSeqnos'
type ClientIface_GetAllVbSeqnos_Call struct {
	*mock.Call
}

// GetAllVbSeqnos is a helper method to define mock.On call
//   - vbSeqnoMap map[uint16]uint64
//   - context ...*memcached.ClientContext
func (_e *ClientIface_Expecter) GetAllVbSeqnos(vbSeqnoMap interface{}, context ...interface{}) *ClientIface_GetAllVbSeqnos_Call {
	return &ClientIface_GetAllVbSeqnos_Call{Call: _e.mock.On("GetAllVbSeqnos",
		append([]interface{}{vbSeqnoMap}, context...)...)}
}

func (_c *ClientIface_GetAllVbSeqnos_Call) Run(run func(vbSeqnoMap map[uint16]uint64, context ...*memcached.ClientContext)) *ClientIface_GetAllVbSeqnos_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]*memcached.ClientContext, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(*memcached.ClientContext)
			}
		}
		run(args[0].(map[uint16]uint64), variadicArgs...)
	})
	return _c
}

func (_c *ClientIface_GetAllVbSeqnos_Call) Return(_a0 map[uint16]uint64, _a1 error) *ClientIface_GetAllVbSeqnos_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientIface_GetAllVbSeqnos_Call) RunAndReturn(run func(map[uint16]uint64, ...*memcached.ClientContext) (map[uint16]uint64, error)) *ClientIface_GetAllVbSeqnos_Call {
	_c.Call.Return(run)
	return _c
}

// GetAndTouch provides a mock function with given fields: vb, key, exp, context
func (_m *ClientIface) GetAndTouch(vb uint16, key string, exp int, context ...*memcached.ClientContext) (*gomemcached.MCResponse, error) {
	_va := make([]interface{}, len(context))
	for _i := range context {
		_va[_i] = context[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, vb, key, exp)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gomemcached.MCResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(uint16, string, int, ...*memcached.ClientContext) (*gomemcached.MCResponse, error)); ok {
		return rf(vb, key, exp, context...)
	}
	if rf, ok := ret.Get(0).(func(uint16, string, int, ...*memcached.ClientContext) *gomemcached.MCResponse); ok {
		r0 = rf(vb, key, exp, context...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gomemcached.MCResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(uint16, string, int, ...*memcached.ClientContext) error); ok {
		r1 = rf(vb, key, exp, context...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientIface_GetAndTouch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAndTouch'
type ClientIface_GetAndTouch_Call struct {
	*mock.Call
}

// GetAndTouch is a helper method to define mock.On call
//   - vb uint16
//   - key string
//   - exp int
//   - context ...*memcached.ClientContext
func (_e *ClientIface_Expecter) GetAndTouch(vb interface{}, key interface{}, exp interface{}, context ...interface{}) *ClientIface_GetAndTouch_Call {
	return &ClientIface_GetAndTouch_Call{Call: _e.mock.On("GetAndTouch",
		append([]interface{}{vb, key, exp}, context...)...)}
}

func (_c *ClientIface_GetAndTouch_Call) Run(run func(vb uint16, key string, exp int, context ...*memcached.ClientContext)) *ClientIface_GetAndTouch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]*memcached.ClientContext, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(*memcached.ClientContext)
			}
		}
		run(args[0].(uint16), args[1].(string), args[2].(int), variadicArgs...)
	})
	return _c
}

func (_c *ClientIface_GetAndTouch_Call) Return(_a0 *gomemcached.MCResponse, _a1 error) *ClientIface_GetAndTouch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientIface_GetAndTouch_Call) RunAndReturn(run func(uint16, string, int, ...*memcached.ClientContext) (*gomemcached.MCResponse, error)) *ClientIface_GetAndTouch_Call {
	_c.Call.Return(run)
	return _c
}

// GetBulk provides a mock function with given fields: vb, keys, rv, subPaths, context
func (_m *ClientIface) GetBulk(vb uint16, keys []string, rv map[string]*gomemcached.MCResponse, subPaths []string, context ...*memcached.ClientContext) error {
	_va := make([]interface{}, len(context))
	for _i := range context {
		_va[_i] = context[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, vb, keys, rv, subPaths)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(uint16, []string, map[string]*gomemcached.MCResponse, []string, ...*memcached.ClientContext) error); ok {
		r0 = rf(vb, keys, rv, subPaths, context...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ClientIface_GetBulk_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBulk'
type ClientIface_GetBulk_Call struct {
	*mock.Call
}

// GetBulk is a helper method to define mock.On call
//   - vb uint16
//   - keys []string
//   - rv map[string]*gomemcached.MCResponse
//   - subPaths []string
//   - context ...*memcached.ClientContext
func (_e *ClientIface_Expecter) GetBulk(vb interface{}, keys interface{}, rv interface{}, subPaths interface{}, context ...interface{}) *ClientIface_GetBulk_Call {
	return &ClientIface_GetBulk_Call{Call: _e.mock.On("GetBulk",
		append([]interface{}{vb, keys, rv, subPaths}, context...)...)}
}

func (_c *ClientIface_GetBulk_Call) Run(run func(vb uint16, keys []string, rv map[string]*gomemcached.MCResponse, subPaths []string, context ...*memcached.ClientContext)) *ClientIface_GetBulk_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]*memcached.ClientContext, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(*memcached.ClientContext)
			}
		}
		run(args[0].(uint16), args[1].([]string), args[2].(map[string]*gomemcached.MCResponse), args[3].([]string), variadicArgs...)
	})
	return _c
}

func (_c *ClientIface_GetBulk_Call) Return(_a0 error) *ClientIface_GetBulk_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ClientIface_GetBulk_Call) RunAndReturn(run func(uint16, []string, map[string]*gomemcached.MCResponse, []string, ...*memcached.ClientContext) error) *ClientIface_GetBulk_Call {
	_c.Call.Return(run)
	return _c
}

// GetCollectionsManifest provides a mock function with given fields:
func (_m *ClientIface) GetCollectionsManifest() (*gomemcached.MCResponse, error) {
	ret := _m.Called()

	var r0 *gomemcached.MCResponse
	var r1 error
	if rf, ok := ret.Get(0).(func() (*gomemcached.MCResponse, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() *gomemcached.MCResponse); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gomemcached.MCResponse)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientIface_GetCollectionsManifest_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCollectionsManifest'
type ClientIface_GetCollectionsManifest_Call struct {
	*mock.Call
}

// GetCollectionsManifest is a helper method to define mock.On call
func (_e *ClientIface_Expecter) GetCollectionsManifest() *ClientIface_GetCollectionsManifest_Call {
	return &ClientIface_GetCollectionsManifest_Call{Call: _e.mock.On("GetCollectionsManifest")}
}

func (_c *ClientIface_GetCollectionsManifest_Call) Run(run func()) *ClientIface_GetCollectionsManifest_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ClientIface_GetCollectionsManifest_Call) Return(_a0 *gomemcached.MCResponse, _a1 error) *ClientIface_GetCollectionsManifest_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientIface_GetCollectionsManifest_Call) RunAndReturn(run func() (*gomemcached.MCResponse, error)) *ClientIface_GetCollectionsManifest_Call {
	_c.Call.Return(run)
	return _c
}

// GetConnName provides a mock function with given fields:
func (_m *ClientIface) GetConnName() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// ClientIface_GetConnName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetConnName'
type ClientIface_GetConnName_Call struct {
	*mock.Call
}

// GetConnName is a helper method to define mock.On call
func (_e *ClientIface_Expecter) GetConnName() *ClientIface_GetConnName_Call {
	return &ClientIface_GetConnName_Call{Call: _e.mock.On("GetConnName")}
}

func (_c *ClientIface_GetConnName_Call) Run(run func()) *ClientIface_GetConnName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ClientIface_GetConnName_Call) Return(_a0 string) *ClientIface_GetConnName_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ClientIface_GetConnName_Call) RunAndReturn(run func() string) *ClientIface_GetConnName_Call {
	_c.Call.Return(run)
	return _c
}

// GetErrorMap provides a mock function with given fields: errMapVersion
func (_m *ClientIface) GetErrorMap(errMapVersion gomemcached.ErrorMapVersion) (map[string]interface{}, error) {
	ret := _m.Called(errMapVersion)

	var r0 map[string]interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(gomemcached.ErrorMapVersion) (map[string]interface{}, error)); ok {
		return rf(errMapVersion)
	}
	if rf, ok := ret.Get(0).(func(gomemcached.ErrorMapVersion) map[string]interface{}); ok {
		r0 = rf(errMapVersion)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(gomemcached.ErrorMapVersion) error); ok {
		r1 = rf(errMapVersion)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientIface_GetErrorMap_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetErrorMap'
type ClientIface_GetErrorMap_Call struct {
	*mock.Call
}

// GetErrorMap is a helper method to define mock.On call
//   - errMapVersion gomemcached.ErrorMapVersion
func (_e *ClientIface_Expecter) GetErrorMap(errMapVersion interface{}) *ClientIface_GetErrorMap_Call {
	return &ClientIface_GetErrorMap_Call{Call: _e.mock.On("GetErrorMap", errMapVersion)}
}

func (_c *ClientIface_GetErrorMap_Call) Run(run func(errMapVersion gomemcached.ErrorMapVersion)) *ClientIface_GetErrorMap_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(gomemcached.ErrorMapVersion))
	})
	return _c
}

func (_c *ClientIface_GetErrorMap_Call) Return(_a0 map[string]interface{}, _a1 error) *ClientIface_GetErrorMap_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientIface_GetErrorMap_Call) RunAndReturn(run func(gomemcached.ErrorMapVersion) (map[string]interface{}, error)) *ClientIface_GetErrorMap_Call {
	_c.Call.Return(run)
	return _c
}

// GetMeta provides a mock function with given fields: vb, key, context
func (_m *ClientIface) GetMeta(vb uint16, key string, context ...*memcached.ClientContext) (*gomemcached.MCResponse, error) {
	_va := make([]interface{}, len(context))
	for _i := range context {
		_va[_i] = context[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, vb, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gomemcached.MCResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(uint16, string, ...*memcached.ClientContext) (*gomemcached.MCResponse, error)); ok {
		return rf(vb, key, context...)
	}
	if rf, ok := ret.Get(0).(func(uint16, string, ...*memcached.ClientContext) *gomemcached.MCResponse); ok {
		r0 = rf(vb, key, context...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gomemcached.MCResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(uint16, string, ...*memcached.ClientContext) error); ok {
		r1 = rf(vb, key, context...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientIface_GetMeta_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMeta'
type ClientIface_GetMeta_Call struct {
	*mock.Call
}

// GetMeta is a helper method to define mock.On call
//   - vb uint16
//   - key string
//   - context ...*memcached.ClientContext
func (_e *ClientIface_Expecter) GetMeta(vb interface{}, key interface{}, context ...interface{}) *ClientIface_GetMeta_Call {
	return &ClientIface_GetMeta_Call{Call: _e.mock.On("GetMeta",
		append([]interface{}{vb, key}, context...)...)}
}

func (_c *ClientIface_GetMeta_Call) Run(run func(vb uint16, key string, context ...*memcached.ClientContext)) *ClientIface_GetMeta_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]*memcached.ClientContext, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(*memcached.ClientContext)
			}
		}
		run(args[0].(uint16), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *ClientIface_GetMeta_Call) Return(_a0 *gomemcached.MCResponse, _a1 error) *ClientIface_GetMeta_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientIface_GetMeta_Call) RunAndReturn(run func(uint16, string, ...*memcached.ClientContext) (*gomemcached.MCResponse, error)) *ClientIface_GetMeta_Call {
	_c.Call.Return(run)
	return _c
}

// GetRandomDoc provides a mock function with given fields: context
func (_m *ClientIface) GetRandomDoc(context ...*memcached.ClientContext) (*gomemcached.MCResponse, error) {
	_va := make([]interface{}, len(context))
	for _i := range context {
		_va[_i] = context[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gomemcached.MCResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(...*memcached.ClientContext) (*gomemcached.MCResponse, error)); ok {
		return rf(context...)
	}
	if rf, ok := ret.Get(0).(func(...*memcached.ClientContext) *gomemcached.MCResponse); ok {
		r0 = rf(context...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gomemcached.MCResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(...*memcached.ClientContext) error); ok {
		r1 = rf(context...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientIface_GetRandomDoc_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRandomDoc'
type ClientIface_GetRandomDoc_Call struct {
	*mock.Call
}

// GetRandomDoc is a helper method to define mock.On call
//   - context ...*memcached.ClientContext
func (_e *ClientIface_Expecter) GetRandomDoc(context ...interface{}) *ClientIface_GetRandomDoc_Call {
	return &ClientIface_GetRandomDoc_Call{Call: _e.mock.On("GetRandomDoc",
		append([]interface{}{}, context...)...)}
}

func (_c *ClientIface_GetRandomDoc_Call) Run(run func(context ...*memcached.ClientContext)) *ClientIface_GetRandomDoc_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]*memcached.ClientContext, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(*memcached.ClientContext)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *ClientIface_GetRandomDoc_Call) Return(_a0 *gomemcached.MCResponse, _a1 error) *ClientIface_GetRandomDoc_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientIface_GetRandomDoc_Call) RunAndReturn(run func(...*memcached.ClientContext) (*gomemcached.MCResponse, error)) *ClientIface_GetRandomDoc_Call {
	_c.Call.Return(run)
	return _c
}

// GetSubdoc provides a mock function with given fields: vb, key, subPaths, context
func (_m *ClientIface) GetSubdoc(vb uint16, key string, subPaths []string, context ...*memcached.ClientContext) (*gomemcached.MCResponse, error) {
	_va := make([]interface{}, len(context))
	for _i := range context {
		_va[_i] = context[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, vb, key, subPaths)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gomemcached.MCResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(uint16, string, []string, ...*memcached.ClientContext) (*gomemcached.MCResponse, error)); ok {
		return rf(vb, key, subPaths, context...)
	}
	if rf, ok := ret.Get(0).(func(uint16, string, []string, ...*memcached.ClientContext) *gomemcached.MCResponse); ok {
		r0 = rf(vb, key, subPaths, context...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gomemcached.MCResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(uint16, string, []string, ...*memcached.ClientContext) error); ok {
		r1 = rf(vb, key, subPaths, context...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientIface_GetSubdoc_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSubdoc'
type ClientIface_GetSubdoc_Call struct {
	*mock.Call
}

// GetSubdoc is a helper method to define mock.On call
//   - vb uint16
//   - key string
//   - subPaths []string
//   - context ...*memcached.ClientContext
func (_e *ClientIface_Expecter) GetSubdoc(vb interface{}, key interface{}, subPaths interface{}, context ...interface{}) *ClientIface_GetSubdoc_Call {
	return &ClientIface_GetSubdoc_Call{Call: _e.mock.On("GetSubdoc",
		append([]interface{}{vb, key, subPaths}, context...)...)}
}

func (_c *ClientIface_GetSubdoc_Call) Run(run func(vb uint16, key string, subPaths []string, context ...*memcached.ClientContext)) *ClientIface_GetSubdoc_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]*memcached.ClientContext, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(*memcached.ClientContext)
			}
		}
		run(args[0].(uint16), args[1].(string), args[2].([]string), variadicArgs...)
	})
	return _c
}

func (_c *ClientIface_GetSubdoc_Call) Return(_a0 *gomemcached.MCResponse, _a1 error) *ClientIface_GetSubdoc_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientIface_GetSubdoc_Call) RunAndReturn(run func(uint16, string, []string, ...*memcached.ClientContext) (*gomemcached.MCResponse, error)) *ClientIface_GetSubdoc_Call {
	_c.Call.Return(run)
	return _c
}

// Hijack provides a mock function with given fields:
func (_m *ClientIface) Hijack() io.ReadWriteCloser {
	ret := _m.Called()

	var r0 io.ReadWriteCloser
	if rf, ok := ret.Get(0).(func() io.ReadWriteCloser); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(io.ReadWriteCloser)
		}
	}

	return r0
}

// ClientIface_Hijack_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Hijack'
type ClientIface_Hijack_Call struct {
	*mock.Call
}

// Hijack is a helper method to define mock.On call
func (_e *ClientIface_Expecter) Hijack() *ClientIface_Hijack_Call {
	return &ClientIface_Hijack_Call{Call: _e.mock.On("Hijack")}
}

func (_c *ClientIface_Hijack_Call) Run(run func()) *ClientIface_Hijack_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ClientIface_Hijack_Call) Return(_a0 io.ReadWriteCloser) *ClientIface_Hijack_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ClientIface_Hijack_Call) RunAndReturn(run func() io.ReadWriteCloser) *ClientIface_Hijack_Call {
	_c.Call.Return(run)
	return _c
}

// Incr provides a mock function with given fields: vb, key, amt, def, exp, context
func (_m *ClientIface) Incr(vb uint16, key string, amt uint64, def uint64, exp int, context ...*memcached.ClientContext) (uint64, error) {
	_va := make([]interface{}, len(context))
	for _i := range context {
		_va[_i] = context[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, vb, key, amt, def, exp)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(uint16, string, uint64, uint64, int, ...*memcached.ClientContext) (uint64, error)); ok {
		return rf(vb, key, amt, def, exp, context...)
	}
	if rf, ok := ret.Get(0).(func(uint16, string, uint64, uint64, int, ...*memcached.ClientContext) uint64); ok {
		r0 = rf(vb, key, amt, def, exp, context...)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(uint16, string, uint64, uint64, int, ...*memcached.ClientContext) error); ok {
		r1 = rf(vb, key, amt, def, exp, context...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientIface_Incr_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Incr'
type ClientIface_Incr_Call struct {
	*mock.Call
}

// Incr is a helper method to define mock.On call
//   - vb uint16
//   - key string
//   - amt uint64
//   - def uint64
//   - exp int
//   - context ...*memcached.ClientContext
func (_e *ClientIface_Expecter) Incr(vb interface{}, key interface{}, amt interface{}, def interface{}, exp interface{}, context ...interface{}) *ClientIface_Incr_Call {
	return &ClientIface_Incr_Call{Call: _e.mock.On("Incr",
		append([]interface{}{vb, key, amt, def, exp}, context...)...)}
}

func (_c *ClientIface_Incr_Call) Run(run func(vb uint16, key string, amt uint64, def uint64, exp int, context ...*memcached.ClientContext)) *ClientIface_Incr_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]*memcached.ClientContext, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(*memcached.ClientContext)
			}
		}
		run(args[0].(uint16), args[1].(string), args[2].(uint64), args[3].(uint64), args[4].(int), variadicArgs...)
	})
	return _c
}

func (_c *ClientIface_Incr_Call) Return(_a0 uint64, _a1 error) *ClientIface_Incr_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientIface_Incr_Call) RunAndReturn(run func(uint16, string, uint64, uint64, int, ...*memcached.ClientContext) (uint64, error)) *ClientIface_Incr_Call {
	_c.Call.Return(run)
	return _c
}

// LastBucket provides a mock function with given fields:
func (_m *ClientIface) LastBucket() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// ClientIface_LastBucket_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LastBucket'
type ClientIface_LastBucket_Call struct {
	*mock.Call
}

// LastBucket is a helper method to define mock.On call
func (_e *ClientIface_Expecter) LastBucket() *ClientIface_LastBucket_Call {
	return &ClientIface_LastBucket_Call{Call: _e.mock.On("LastBucket")}
}

func (_c *ClientIface_LastBucket_Call) Run(run func()) *ClientIface_LastBucket_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ClientIface_LastBucket_Call) Return(_a0 string) *ClientIface_LastBucket_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ClientIface_LastBucket_Call) RunAndReturn(run func() string) *ClientIface_LastBucket_Call {
	_c.Call.Return(run)
	return _c
}

// NewUprFeed provides a mock function with given fields:
func (_m *ClientIface) NewUprFeed() (*memcached.UprFeed, error) {
	ret := _m.Called()

	var r0 *memcached.UprFeed
	var r1 error
	if rf, ok := ret.Get(0).(func() (*memcached.UprFeed, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() *memcached.UprFeed); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*memcached.UprFeed)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientIface_NewUprFeed_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NewUprFeed'
type ClientIface_NewUprFeed_Call struct {
	*mock.Call
}

// NewUprFeed is a helper method to define mock.On call
func (_e *ClientIface_Expecter) NewUprFeed() *ClientIface_NewUprFeed_Call {
	return &ClientIface_NewUprFeed_Call{Call: _e.mock.On("NewUprFeed")}
}

func (_c *ClientIface_NewUprFeed_Call) Run(run func()) *ClientIface_NewUprFeed_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ClientIface_NewUprFeed_Call) Return(_a0 *memcached.UprFeed, _a1 error) *ClientIface_NewUprFeed_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientIface_NewUprFeed_Call) RunAndReturn(run func() (*memcached.UprFeed, error)) *ClientIface_NewUprFeed_Call {
	_c.Call.Return(run)
	return _c
}

// NewUprFeedIface provides a mock function with given fields:
func (_m *ClientIface) NewUprFeedIface() (memcached.UprFeedIface, error) {
	ret := _m.Called()

	var r0 memcached.UprFeedIface
	var r1 error
	if rf, ok := ret.Get(0).(func() (memcached.UprFeedIface, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() memcached.UprFeedIface); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(memcached.UprFeedIface)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientIface_NewUprFeedIface_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NewUprFeedIface'
type ClientIface_NewUprFeedIface_Call struct {
	*mock.Call
}

// NewUprFeedIface is a helper method to define mock.On call
func (_e *ClientIface_Expecter) NewUprFeedIface() *ClientIface_NewUprFeedIface_Call {
	return &ClientIface_NewUprFeedIface_Call{Call: _e.mock.On("NewUprFeedIface")}
}

func (_c *ClientIface_NewUprFeedIface_Call) Run(run func()) *ClientIface_NewUprFeedIface_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ClientIface_NewUprFeedIface_Call) Return(_a0 memcached.UprFeedIface, _a1 error) *ClientIface_NewUprFeedIface_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientIface_NewUprFeedIface_Call) RunAndReturn(run func() (memcached.UprFeedIface, error)) *ClientIface_NewUprFeedIface_Call {
	_c.Call.Return(run)
	return _c
}

// NewUprFeedWithConfig provides a mock function with given fields: ackByClient
func (_m *ClientIface) NewUprFeedWithConfig(ackByClient bool) (*memcached.UprFeed, error) {
	ret := _m.Called(ackByClient)

	var r0 *memcached.UprFeed
	var r1 error
	if rf, ok := ret.Get(0).(func(bool) (*memcached.UprFeed, error)); ok {
		return rf(ackByClient)
	}
	if rf, ok := ret.Get(0).(func(bool) *memcached.UprFeed); ok {
		r0 = rf(ackByClient)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*memcached.UprFeed)
		}
	}

	if rf, ok := ret.Get(1).(func(bool) error); ok {
		r1 = rf(ackByClient)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientIface_NewUprFeedWithConfig_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NewUprFeedWithConfig'
type ClientIface_NewUprFeedWithConfig_Call struct {
	*mock.Call
}

// NewUprFeedWithConfig is a helper method to define mock.On call
//   - ackByClient bool
func (_e *ClientIface_Expecter) NewUprFeedWithConfig(ackByClient interface{}) *ClientIface_NewUprFeedWithConfig_Call {
	return &ClientIface_NewUprFeedWithConfig_Call{Call: _e.mock.On("NewUprFeedWithConfig", ackByClient)}
}

func (_c *ClientIface_NewUprFeedWithConfig_Call) Run(run func(ackByClient bool)) *ClientIface_NewUprFeedWithConfig_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(bool))
	})
	return _c
}

func (_c *ClientIface_NewUprFeedWithConfig_Call) Return(_a0 *memcached.UprFeed, _a1 error) *ClientIface_NewUprFeedWithConfig_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientIface_NewUprFeedWithConfig_Call) RunAndReturn(run func(bool) (*memcached.UprFeed, error)) *ClientIface_NewUprFeedWithConfig_Call {
	_c.Call.Return(run)
	return _c
}

// NewUprFeedWithConfigIface provides a mock function with given fields: ackByClient
func (_m *ClientIface) NewUprFeedWithConfigIface(ackByClient bool) (memcached.UprFeedIface, error) {
	ret := _m.Called(ackByClient)

	var r0 memcached.UprFeedIface
	var r1 error
	if rf, ok := ret.Get(0).(func(bool) (memcached.UprFeedIface, error)); ok {
		return rf(ackByClient)
	}
	if rf, ok := ret.Get(0).(func(bool) memcached.UprFeedIface); ok {
		r0 = rf(ackByClient)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(memcached.UprFeedIface)
		}
	}

	if rf, ok := ret.Get(1).(func(bool) error); ok {
		r1 = rf(ackByClient)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientIface_NewUprFeedWithConfigIface_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NewUprFeedWithConfigIface'
type ClientIface_NewUprFeedWithConfigIface_Call struct {
	*mock.Call
}

// NewUprFeedWithConfigIface is a helper method to define mock.On call
//   - ackByClient bool
func (_e *ClientIface_Expecter) NewUprFeedWithConfigIface(ackByClient interface{}) *ClientIface_NewUprFeedWithConfigIface_Call {
	return &ClientIface_NewUprFeedWithConfigIface_Call{Call: _e.mock.On("NewUprFeedWithConfigIface", ackByClient)}
}

func (_c *ClientIface_NewUprFeedWithConfigIface_Call) Run(run func(ackByClient bool)) *ClientIface_NewUprFeedWithConfigIface_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(bool))
	})
	return _c
}

func (_c *ClientIface_NewUprFeedWithConfigIface_Call) Return(_a0 memcached.UprFeedIface, _a1 error) *ClientIface_NewUprFeedWithConfigIface_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientIface_NewUprFeedWithConfigIface_Call) RunAndReturn(run func(bool) (memcached.UprFeedIface, error)) *ClientIface_NewUprFeedWithConfigIface_Call {
	_c.Call.Return(run)
	return _c
}

// Observe provides a mock function with given fields: vb, key
func (_m *ClientIface) Observe(vb uint16, key string) (memcached.ObserveResult, error) {
	ret := _m.Called(vb, key)

	var r0 memcached.ObserveResult
	var r1 error
	if rf, ok := ret.Get(0).(func(uint16, string) (memcached.ObserveResult, error)); ok {
		return rf(vb, key)
	}
	if rf, ok := ret.Get(0).(func(uint16, string) memcached.ObserveResult); ok {
		r0 = rf(vb, key)
	} else {
		r0 = ret.Get(0).(memcached.ObserveResult)
	}

	if rf, ok := ret.Get(1).(func(uint16, string) error); ok {
		r1 = rf(vb, key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientIface_Observe_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Observe'
type ClientIface_Observe_Call struct {
	*mock.Call
}

// Observe is a helper method to define mock.On call
//   - vb uint16
//   - key string
func (_e *ClientIface_Expecter) Observe(vb interface{}, key interface{}) *ClientIface_Observe_Call {
	return &ClientIface_Observe_Call{Call: _e.mock.On("Observe", vb, key)}
}

func (_c *ClientIface_Observe_Call) Run(run func(vb uint16, key string)) *ClientIface_Observe_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint16), args[1].(string))
	})
	return _c
}

func (_c *ClientIface_Observe_Call) Return(result memcached.ObserveResult, err error) *ClientIface_Observe_Call {
	_c.Call.Return(result, err)
	return _c
}

func (_c *ClientIface_Observe_Call) RunAndReturn(run func(uint16, string) (memcached.ObserveResult, error)) *ClientIface_Observe_Call {
	_c.Call.Return(run)
	return _c
}

// ObserveSeq provides a mock function with given fields: vb, vbuuid
func (_m *ClientIface) ObserveSeq(vb uint16, vbuuid uint64) (*memcached.ObserveSeqResult, error) {
	ret := _m.Called(vb, vbuuid)

	var r0 *memcached.ObserveSeqResult
	var r1 error
	if rf, ok := ret.Get(0).(func(uint16, uint64) (*memcached.ObserveSeqResult, error)); ok {
		return rf(vb, vbuuid)
	}
	if rf, ok := ret.Get(0).(func(uint16, uint64) *memcached.ObserveSeqResult); ok {
		r0 = rf(vb, vbuuid)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*memcached.ObserveSeqResult)
		}
	}

	if rf, ok := ret.Get(1).(func(uint16, uint64) error); ok {
		r1 = rf(vb, vbuuid)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientIface_ObserveSeq_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ObserveSeq'
type ClientIface_ObserveSeq_Call struct {
	*mock.Call
}

// ObserveSeq is a helper method to define mock.On call
//   - vb uint16
//   - vbuuid uint64
func (_e *ClientIface_Expecter) ObserveSeq(vb interface{}, vbuuid interface{}) *ClientIface_ObserveSeq_Call {
	return &ClientIface_ObserveSeq_Call{Call: _e.mock.On("ObserveSeq", vb, vbuuid)}
}

func (_c *ClientIface_ObserveSeq_Call) Run(run func(vb uint16, vbuuid uint64)) *ClientIface_ObserveSeq_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint16), args[1].(uint64))
	})
	return _c
}

func (_c *ClientIface_ObserveSeq_Call) Return(result *memcached.ObserveSeqResult, err error) *ClientIface_ObserveSeq_Call {
	_c.Call.Return(result, err)
	return _c
}

func (_c *ClientIface_ObserveSeq_Call) RunAndReturn(run func(uint16, uint64) (*memcached.ObserveSeqResult, error)) *ClientIface_ObserveSeq_Call {
	_c.Call.Return(run)
	return _c
}

// Receive provides a mock function with given fields:
func (_m *ClientIface) Receive() (*gomemcached.MCResponse, error) {
	ret := _m.Called()

	var r0 *gomemcached.MCResponse
	var r1 error
	if rf, ok := ret.Get(0).(func() (*gomemcached.MCResponse, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() *gomemcached.MCResponse); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gomemcached.MCResponse)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientIface_Receive_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Receive'
type ClientIface_Receive_Call struct {
	*mock.Call
}

// Receive is a helper method to define mock.On call
func (_e *ClientIface_Expecter) Receive() *ClientIface_Receive_Call {
	return &ClientIface_Receive_Call{Call: _e.mock.On("Receive")}
}

func (_c *ClientIface_Receive_Call) Run(run func()) *ClientIface_Receive_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ClientIface_Receive_Call) Return(_a0 *gomemcached.MCResponse, _a1 error) *ClientIface_Receive_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientIface_Receive_Call) RunAndReturn(run func() (*gomemcached.MCResponse, error)) *ClientIface_Receive_Call {
	_c.Call.Return(run)
	return _c
}

// ReceiveWithDeadline provides a mock function with given fields: deadline
func (_m *ClientIface) ReceiveWithDeadline(deadline time.Time) (*gomemcached.MCResponse, error) {
	ret := _m.Called(deadline)

	var r0 *gomemcached.MCResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(time.Time) (*gomemcached.MCResponse, error)); ok {
		return rf(deadline)
	}
	if rf, ok := ret.Get(0).(func(time.Time) *gomemcached.MCResponse); ok {
		r0 = rf(deadline)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gomemcached.MCResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(time.Time) error); ok {
		r1 = rf(deadline)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientIface_ReceiveWithDeadline_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReceiveWithDeadline'
type ClientIface_ReceiveWithDeadline_Call struct {
	*mock.Call
}

// ReceiveWithDeadline is a helper method to define mock.On call
//   - deadline time.Time
func (_e *ClientIface_Expecter) ReceiveWithDeadline(deadline interface{}) *ClientIface_ReceiveWithDeadline_Call {
	return &ClientIface_ReceiveWithDeadline_Call{Call: _e.mock.On("ReceiveWithDeadline", deadline)}
}

func (_c *ClientIface_ReceiveWithDeadline_Call) Run(run func(deadline time.Time)) *ClientIface_ReceiveWithDeadline_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(time.Time))
	})
	return _c
}

func (_c *ClientIface_ReceiveWithDeadline_Call) Return(_a0 *gomemcached.MCResponse, _a1 error) *ClientIface_ReceiveWithDeadline_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientIface_ReceiveWithDeadline_Call) RunAndReturn(run func(time.Time) (*gomemcached.MCResponse, error)) *ClientIface_ReceiveWithDeadline_Call {
	_c.Call.Return(run)
	return _c
}

// Replica provides a mock function with given fields:
func (_m *ClientIface) Replica() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// ClientIface_Replica_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Replica'
type ClientIface_Replica_Call struct {
	*mock.Call
}

// Replica is a helper method to define mock.On call
func (_e *ClientIface_Expecter) Replica() *ClientIface_Replica_Call {
	return &ClientIface_Replica_Call{Call: _e.mock.On("Replica")}
}

func (_c *ClientIface_Replica_Call) Run(run func()) *ClientIface_Replica_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ClientIface_Replica_Call) Return(_a0 bool) *ClientIface_Replica_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ClientIface_Replica_Call) RunAndReturn(run func() bool) *ClientIface_Replica_Call {
	_c.Call.Return(run)
	return _c
}

// SelectBucket provides a mock function with given fields: bucket
func (_m *ClientIface) SelectBucket(bucket string) (*gomemcached.MCResponse, error) {
	ret := _m.Called(bucket)

	var r0 *gomemcached.MCResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (*gomemcached.MCResponse, error)); ok {
		return rf(bucket)
	}
	if rf, ok := ret.Get(0).(func(string) *gomemcached.MCResponse); ok {
		r0 = rf(bucket)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gomemcached.MCResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(bucket)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientIface_SelectBucket_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SelectBucket'
type ClientIface_SelectBucket_Call struct {
	*mock.Call
}

// SelectBucket is a helper method to define mock.On call
//   - bucket string
func (_e *ClientIface_Expecter) SelectBucket(bucket interface{}) *ClientIface_SelectBucket_Call {
	return &ClientIface_SelectBucket_Call{Call: _e.mock.On("SelectBucket", bucket)}
}

func (_c *ClientIface_SelectBucket_Call) Run(run func(bucket string)) *ClientIface_SelectBucket_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *ClientIface_SelectBucket_Call) Return(_a0 *gomemcached.MCResponse, _a1 error) *ClientIface_SelectBucket_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientIface_SelectBucket_Call) RunAndReturn(run func(string) (*gomemcached.MCResponse, error)) *ClientIface_SelectBucket_Call {
	_c.Call.Return(run)
	return _c
}

// Send provides a mock function with given fields: req
func (_m *ClientIface) Send(req *gomemcached.MCRequest) (*gomemcached.MCResponse, error) {
	ret := _m.Called(req)

	var r0 *gomemcached.MCResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(*gomemcached.MCRequest) (*gomemcached.MCResponse, error)); ok {
		return rf(req)
	}
	if rf, ok := ret.Get(0).(func(*gomemcached.MCRequest) *gomemcached.MCResponse); ok {
		r0 = rf(req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gomemcached.MCResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(*gomemcached.MCRequest) error); ok {
		r1 = rf(req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientIface_Send_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Send'
type ClientIface_Send_Call struct {
	*mock.Call
}

// Send is a helper method to define mock.On call
//   - req *gomemcached.MCRequest
func (_e *ClientIface_Expecter) Send(req interface{}) *ClientIface_Send_Call {
	return &ClientIface_Send_Call{Call: _e.mock.On("Send", req)}
}

func (_c *ClientIface_Send_Call) Run(run func(req *gomemcached.MCRequest)) *ClientIface_Send_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*gomemcached.MCRequest))
	})
	return _c
}

func (_c *ClientIface_Send_Call) Return(rv *gomemcached.MCResponse, err error) *ClientIface_Send_Call {
	_c.Call.Return(rv, err)
	return _c
}

func (_c *ClientIface_Send_Call) RunAndReturn(run func(*gomemcached.MCRequest) (*gomemcached.MCResponse, error)) *ClientIface_Send_Call {
	_c.Call.Return(run)
	return _c
}

// Set provides a mock function with given fields: vb, key, flags, exp, body, context
func (_m *ClientIface) Set(vb uint16, key string, flags int, exp int, body []byte, context ...*memcached.ClientContext) (*gomemcached.MCResponse, error) {
	_va := make([]interface{}, len(context))
	for _i := range context {
		_va[_i] = context[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, vb, key, flags, exp, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gomemcached.MCResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(uint16, string, int, int, []byte, ...*memcached.ClientContext) (*gomemcached.MCResponse, error)); ok {
		return rf(vb, key, flags, exp, body, context...)
	}
	if rf, ok := ret.Get(0).(func(uint16, string, int, int, []byte, ...*memcached.ClientContext) *gomemcached.MCResponse); ok {
		r0 = rf(vb, key, flags, exp, body, context...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gomemcached.MCResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(uint16, string, int, int, []byte, ...*memcached.ClientContext) error); ok {
		r1 = rf(vb, key, flags, exp, body, context...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientIface_Set_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Set'
type ClientIface_Set_Call struct {
	*mock.Call
}

// Set is a helper method to define mock.On call
//   - vb uint16
//   - key string
//   - flags int
//   - exp int
//   - body []byte
//   - context ...*memcached.ClientContext
func (_e *ClientIface_Expecter) Set(vb interface{}, key interface{}, flags interface{}, exp interface{}, body interface{}, context ...interface{}) *ClientIface_Set_Call {
	return &ClientIface_Set_Call{Call: _e.mock.On("Set",
		append([]interface{}{vb, key, flags, exp, body}, context...)...)}
}

func (_c *ClientIface_Set_Call) Run(run func(vb uint16, key string, flags int, exp int, body []byte, context ...*memcached.ClientContext)) *ClientIface_Set_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]*memcached.ClientContext, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(*memcached.ClientContext)
			}
		}
		run(args[0].(uint16), args[1].(string), args[2].(int), args[3].(int), args[4].([]byte), variadicArgs...)
	})
	return _c
}

func (_c *ClientIface_Set_Call) Return(_a0 *gomemcached.MCResponse, _a1 error) *ClientIface_Set_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientIface_Set_Call) RunAndReturn(run func(uint16, string, int, int, []byte, ...*memcached.ClientContext) (*gomemcached.MCResponse, error)) *ClientIface_Set_Call {
	_c.Call.Return(run)
	return _c
}

// SetCas provides a mock function with given fields: vb, key, flags, exp, cas, body, context
func (_m *ClientIface) SetCas(vb uint16, key string, flags int, exp int, cas uint64, body []byte, context ...*memcached.ClientContext) (*gomemcached.MCResponse, error) {
	_va := make([]interface{}, len(context))
	for _i := range context {
		_va[_i] = context[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, vb, key, flags, exp, cas, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gomemcached.MCResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(uint16, string, int, int, uint64, []byte, ...*memcached.ClientContext) (*gomemcached.MCResponse, error)); ok {
		return rf(vb, key, flags, exp, cas, body, context...)
	}
	if rf, ok := ret.Get(0).(func(uint16, string, int, int, uint64, []byte, ...*memcached.ClientContext) *gomemcached.MCResponse); ok {
		r0 = rf(vb, key, flags, exp, cas, body, context...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gomemcached.MCResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(uint16, string, int, int, uint64, []byte, ...*memcached.ClientContext) error); ok {
		r1 = rf(vb, key, flags, exp, cas, body, context...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientIface_SetCas_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetCas'
type ClientIface_SetCas_Call struct {
	*mock.Call
}

// SetCas is a helper method to define mock.On call
//   - vb uint16
//   - key string
//   - flags int
//   - exp int
//   - cas uint64
//   - body []byte
//   - context ...*memcached.ClientContext
func (_e *ClientIface_Expecter) SetCas(vb interface{}, key interface{}, flags interface{}, exp interface{}, cas interface{}, body interface{}, context ...interface{}) *ClientIface_SetCas_Call {
	return &ClientIface_SetCas_Call{Call: _e.mock.On("SetCas",
		append([]interface{}{vb, key, flags, exp, cas, body}, context...)...)}
}

func (_c *ClientIface_SetCas_Call) Run(run func(vb uint16, key string, flags int, exp int, cas uint64, body []byte, context ...*memcached.ClientContext)) *ClientIface_SetCas_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]*memcached.ClientContext, len(args)-6)
		for i, a := range args[6:] {
			if a != nil {
				variadicArgs[i] = a.(*memcached.ClientContext)
			}
		}
		run(args[0].(uint16), args[1].(string), args[2].(int), args[3].(int), args[4].(uint64), args[5].([]byte), variadicArgs...)
	})
	return _c
}

func (_c *ClientIface_SetCas_Call) Return(_a0 *gomemcached.MCResponse, _a1 error) *ClientIface_SetCas_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientIface_SetCas_Call) RunAndReturn(run func(uint16, string, int, int, uint64, []byte, ...*memcached.ClientContext) (*gomemcached.MCResponse, error)) *ClientIface_SetCas_Call {
	_c.Call.Return(run)
	return _c
}

// SetConnName provides a mock function with given fields: name
func (_m *ClientIface) SetConnName(name string) {
	_m.Called(name)
}

// ClientIface_SetConnName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetConnName'
type ClientIface_SetConnName_Call struct {
	*mock.Call
}

// SetConnName is a helper method to define mock.On call
//   - name string
func (_e *ClientIface_Expecter) SetConnName(name interface{}) *ClientIface_SetConnName_Call {
	return &ClientIface_SetConnName_Call{Call: _e.mock.On("SetConnName", name)}
}

func (_c *ClientIface_SetConnName_Call) Run(run func(name string)) *ClientIface_SetConnName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *ClientIface_SetConnName_Call) Return() *ClientIface_SetConnName_Call {
	_c.Call.Return()
	return _c
}

func (_c *ClientIface_SetConnName_Call) RunAndReturn(run func(string)) *ClientIface_SetConnName_Call {
	_c.Call.Return(run)
	return _c
}

// SetDeadline provides a mock function with given fields: t
func (_m *ClientIface) SetDeadline(t time.Time) {
	_m.Called(t)
}

// ClientIface_SetDeadline_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetDeadline'
type ClientIface_SetDeadline_Call struct {
	*mock.Call
}

// SetDeadline is a helper method to define mock.On call
//   - t time.Time
func (_e *ClientIface_Expecter) SetDeadline(t interface{}) *ClientIface_SetDeadline_Call {
	return &ClientIface_SetDeadline_Call{Call: _e.mock.On("SetDeadline", t)}
}

func (_c *ClientIface_SetDeadline_Call) Run(run func(t time.Time)) *ClientIface_SetDeadline_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(time.Time))
	})
	return _c
}

func (_c *ClientIface_SetDeadline_Call) Return() *ClientIface_SetDeadline_Call {
	_c.Call.Return()
	return _c
}

func (_c *ClientIface_SetDeadline_Call) RunAndReturn(run func(time.Time)) *ClientIface_SetDeadline_Call {
	_c.Call.Return(run)
	return _c
}

// SetKeepAliveOptions provides a mock function with given fields: interval
func (_m *ClientIface) SetKeepAliveOptions(interval time.Duration) {
	_m.Called(interval)
}

// ClientIface_SetKeepAliveOptions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetKeepAliveOptions'
type ClientIface_SetKeepAliveOptions_Call struct {
	*mock.Call
}

// SetKeepAliveOptions is a helper method to define mock.On call
//   - interval time.Duration
func (_e *ClientIface_Expecter) SetKeepAliveOptions(interval interface{}) *ClientIface_SetKeepAliveOptions_Call {
	return &ClientIface_SetKeepAliveOptions_Call{Call: _e.mock.On("SetKeepAliveOptions", interval)}
}

func (_c *ClientIface_SetKeepAliveOptions_Call) Run(run func(interval time.Duration)) *ClientIface_SetKeepAliveOptions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(time.Duration))
	})
	return _c
}

func (_c *ClientIface_SetKeepAliveOptions_Call) Return() *ClientIface_SetKeepAliveOptions_Call {
	_c.Call.Return()
	return _c
}

func (_c *ClientIface_SetKeepAliveOptions_Call) RunAndReturn(run func(time.Duration)) *ClientIface_SetKeepAliveOptions_Call {
	_c.Call.Return(run)
	return _c
}

// SetReadDeadline provides a mock function with given fields: t
func (_m *ClientIface) SetReadDeadline(t time.Time) {
	_m.Called(t)
}

// ClientIface_SetReadDeadline_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetReadDeadline'
type ClientIface_SetReadDeadline_Call struct {
	*mock.Call
}

// SetReadDeadline is a helper method to define mock.On call
//   - t time.Time
func (_e *ClientIface_Expecter) SetReadDeadline(t interface{}) *ClientIface_SetReadDeadline_Call {
	return &ClientIface_SetReadDeadline_Call{Call: _e.mock.On("SetReadDeadline", t)}
}

func (_c *ClientIface_SetReadDeadline_Call) Run(run func(t time.Time)) *ClientIface_SetReadDeadline_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(time.Time))
	})
	return _c
}

func (_c *ClientIface_SetReadDeadline_Call) Return() *ClientIface_SetReadDeadline_Call {
	_c.Call.Return()
	return _c
}

func (_c *ClientIface_SetReadDeadline_Call) RunAndReturn(run func(time.Time)) *ClientIface_SetReadDeadline_Call {
	_c.Call.Return(run)
	return _c
}

// SetReplica provides a mock function with given fields: r
func (_m *ClientIface) SetReplica(r bool) {
	_m.Called(r)
}

// ClientIface_SetReplica_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetReplica'
type ClientIface_SetReplica_Call struct {
	*mock.Call
}

// SetReplica is a helper method to define mock.On call
//   - r bool
func (_e *ClientIface_Expecter) SetReplica(r interface{}) *ClientIface_SetReplica_Call {
	return &ClientIface_SetReplica_Call{Call: _e.mock.On("SetReplica", r)}
}

func (_c *ClientIface_SetReplica_Call) Run(run func(r bool)) *ClientIface_SetReplica_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(bool))
	})
	return _c
}

func (_c *ClientIface_SetReplica_Call) Return() *ClientIface_SetReplica_Call {
	_c.Call.Return()
	return _c
}

func (_c *ClientIface_SetReplica_Call) RunAndReturn(run func(bool)) *ClientIface_SetReplica_Call {
	_c.Call.Return(run)
	return _c
}

// SetSubdoc provides a mock function with given fields: vb, key, ops, context
func (_m *ClientIface) SetSubdoc(vb uint16, key string, ops []memcached.SubDocOp, context ...*memcached.ClientContext) (*gomemcached.MCResponse, error) {
	_va := make([]interface{}, len(context))
	for _i := range context {
		_va[_i] = context[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, vb, key, ops)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gomemcached.MCResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(uint16, string, []memcached.SubDocOp, ...*memcached.ClientContext) (*gomemcached.MCResponse, error)); ok {
		return rf(vb, key, ops, context...)
	}
	if rf, ok := ret.Get(0).(func(uint16, string, []memcached.SubDocOp, ...*memcached.ClientContext) *gomemcached.MCResponse); ok {
		r0 = rf(vb, key, ops, context...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gomemcached.MCResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(uint16, string, []memcached.SubDocOp, ...*memcached.ClientContext) error); ok {
		r1 = rf(vb, key, ops, context...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientIface_SetSubdoc_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetSubdoc'
type ClientIface_SetSubdoc_Call struct {
	*mock.Call
}

// SetSubdoc is a helper method to define mock.On call
//   - vb uint16
//   - key string
//   - ops []memcached.SubDocOp
//   - context ...*memcached.ClientContext
func (_e *ClientIface_Expecter) SetSubdoc(vb interface{}, key interface{}, ops interface{}, context ...interface{}) *ClientIface_SetSubdoc_Call {
	return &ClientIface_SetSubdoc_Call{Call: _e.mock.On("SetSubdoc",
		append([]interface{}{vb, key, ops}, context...)...)}
}

func (_c *ClientIface_SetSubdoc_Call) Run(run func(vb uint16, key string, ops []memcached.SubDocOp, context ...*memcached.ClientContext)) *ClientIface_SetSubdoc_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]*memcached.ClientContext, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(*memcached.ClientContext)
			}
		}
		run(args[0].(uint16), args[1].(string), args[2].([]memcached.SubDocOp), variadicArgs...)
	})
	return _c
}

func (_c *ClientIface_SetSubdoc_Call) Return(_a0 *gomemcached.MCResponse, _a1 error) *ClientIface_SetSubdoc_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientIface_SetSubdoc_Call) RunAndReturn(run func(uint16, string, []memcached.SubDocOp, ...*memcached.ClientContext) (*gomemcached.MCResponse, error)) *ClientIface_SetSubdoc_Call {
	_c.Call.Return(run)
	return _c
}

// Stats provides a mock function with given fields: key
func (_m *ClientIface) Stats(key string) ([]memcached.StatValue, error) {
	ret := _m.Called(key)

	var r0 []memcached.StatValue
	var r1 error
	if rf, ok := ret.Get(0).(func(string) ([]memcached.StatValue, error)); ok {
		return rf(key)
	}
	if rf, ok := ret.Get(0).(func(string) []memcached.StatValue); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]memcached.StatValue)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientIface_Stats_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Stats'
type ClientIface_Stats_Call struct {
	*mock.Call
}

// Stats is a helper method to define mock.On call
//   - key string
func (_e *ClientIface_Expecter) Stats(key interface{}) *ClientIface_Stats_Call {
	return &ClientIface_Stats_Call{Call: _e.mock.On("Stats", key)}
}

func (_c *ClientIface_Stats_Call) Run(run func(key string)) *ClientIface_Stats_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *ClientIface_Stats_Call) Return(_a0 []memcached.StatValue, _a1 error) *ClientIface_Stats_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientIface_Stats_Call) RunAndReturn(run func(string) ([]memcached.StatValue, error)) *ClientIface_Stats_Call {
	_c.Call.Return(run)
	return _c
}

// StatsFunc provides a mock function with given fields: key, fn
func (_m *ClientIface) StatsFunc(key string, fn func([]byte, []byte)) error {
	ret := _m.Called(key, fn)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, func([]byte, []byte)) error); ok {
		r0 = rf(key, fn)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ClientIface_StatsFunc_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StatsFunc'
type ClientIface_StatsFunc_Call struct {
	*mock.Call
}

// StatsFunc is a helper method to define mock.On call
//   - key string
//   - fn func([]byte , []byte)
func (_e *ClientIface_Expecter) StatsFunc(key interface{}, fn interface{}) *ClientIface_StatsFunc_Call {
	return &ClientIface_StatsFunc_Call{Call: _e.mock.On("StatsFunc", key, fn)}
}

func (_c *ClientIface_StatsFunc_Call) Run(run func(key string, fn func([]byte, []byte))) *ClientIface_StatsFunc_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(func([]byte, []byte)))
	})
	return _c
}

func (_c *ClientIface_StatsFunc_Call) Return(_a0 error) *ClientIface_StatsFunc_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ClientIface_StatsFunc_Call) RunAndReturn(run func(string, func([]byte, []byte)) error) *ClientIface_StatsFunc_Call {
	_c.Call.Return(run)
	return _c
}

// StatsMap provides a mock function with given fields: key
func (_m *ClientIface) StatsMap(key string) (map[string]string, error) {
	ret := _m.Called(key)

	var r0 map[string]string
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (map[string]string, error)); ok {
		return rf(key)
	}
	if rf, ok := ret.Get(0).(func(string) map[string]string); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]string)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientIface_StatsMap_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StatsMap'
type ClientIface_StatsMap_Call struct {
	*mock.Call
}

// StatsMap is a helper method to define mock.On call
//   - key string
func (_e *ClientIface_Expecter) StatsMap(key interface{}) *ClientIface_StatsMap_Call {
	return &ClientIface_StatsMap_Call{Call: _e.mock.On("StatsMap", key)}
}

func (_c *ClientIface_StatsMap_Call) Run(run func(key string)) *ClientIface_StatsMap_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *ClientIface_StatsMap_Call) Return(_a0 map[string]string, _a1 error) *ClientIface_StatsMap_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientIface_StatsMap_Call) RunAndReturn(run func(string) (map[string]string, error)) *ClientIface_StatsMap_Call {
	_c.Call.Return(run)
	return _c
}

// StatsMapForSpecifiedStats provides a mock function with given fields: key, statsMap
func (_m *ClientIface) StatsMapForSpecifiedStats(key string, statsMap map[string]string) error {
	ret := _m.Called(key, statsMap)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, map[string]string) error); ok {
		r0 = rf(key, statsMap)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ClientIface_StatsMapForSpecifiedStats_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StatsMapForSpecifiedStats'
type ClientIface_StatsMapForSpecifiedStats_Call struct {
	*mock.Call
}

// StatsMapForSpecifiedStats is a helper method to define mock.On call
//   - key string
//   - statsMap map[string]string
func (_e *ClientIface_Expecter) StatsMapForSpecifiedStats(key interface{}, statsMap interface{}) *ClientIface_StatsMapForSpecifiedStats_Call {
	return &ClientIface_StatsMapForSpecifiedStats_Call{Call: _e.mock.On("StatsMapForSpecifiedStats", key, statsMap)}
}

func (_c *ClientIface_StatsMapForSpecifiedStats_Call) Run(run func(key string, statsMap map[string]string)) *ClientIface_StatsMapForSpecifiedStats_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(map[string]string))
	})
	return _c
}

func (_c *ClientIface_StatsMapForSpecifiedStats_Call) Return(_a0 error) *ClientIface_StatsMapForSpecifiedStats_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ClientIface_StatsMapForSpecifiedStats_Call) RunAndReturn(run func(string, map[string]string) error) *ClientIface_StatsMapForSpecifiedStats_Call {
	_c.Call.Return(run)
	return _c
}

// Transmit provides a mock function with given fields: req
func (_m *ClientIface) Transmit(req *gomemcached.MCRequest) error {
	ret := _m.Called(req)

	var r0 error
	if rf, ok := ret.Get(0).(func(*gomemcached.MCRequest) error); ok {
		r0 = rf(req)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ClientIface_Transmit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Transmit'
type ClientIface_Transmit_Call struct {
	*mock.Call
}

// Transmit is a helper method to define mock.On call
//   - req *gomemcached.MCRequest
func (_e *ClientIface_Expecter) Transmit(req interface{}) *ClientIface_Transmit_Call {
	return &ClientIface_Transmit_Call{Call: _e.mock.On("Transmit", req)}
}

func (_c *ClientIface_Transmit_Call) Run(run func(req *gomemcached.MCRequest)) *ClientIface_Transmit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*gomemcached.MCRequest))
	})
	return _c
}

func (_c *ClientIface_Transmit_Call) Return(_a0 error) *ClientIface_Transmit_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ClientIface_Transmit_Call) RunAndReturn(run func(*gomemcached.MCRequest) error) *ClientIface_Transmit_Call {
	_c.Call.Return(run)
	return _c
}

// TransmitResponse provides a mock function with given fields: res
func (_m *ClientIface) TransmitResponse(res *gomemcached.MCResponse) error {
	ret := _m.Called(res)

	var r0 error
	if rf, ok := ret.Get(0).(func(*gomemcached.MCResponse) error); ok {
		r0 = rf(res)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ClientIface_TransmitResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TransmitResponse'
type ClientIface_TransmitResponse_Call struct {
	*mock.Call
}

// TransmitResponse is a helper method to define mock.On call
//   - res *gomemcached.MCResponse
func (_e *ClientIface_Expecter) TransmitResponse(res interface{}) *ClientIface_TransmitResponse_Call {
	return &ClientIface_TransmitResponse_Call{Call: _e.mock.On("TransmitResponse", res)}
}

func (_c *ClientIface_TransmitResponse_Call) Run(run func(res *gomemcached.MCResponse)) *ClientIface_TransmitResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*gomemcached.MCResponse))
	})
	return _c
}

func (_c *ClientIface_TransmitResponse_Call) Return(_a0 error) *ClientIface_TransmitResponse_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ClientIface_TransmitResponse_Call) RunAndReturn(run func(*gomemcached.MCResponse) error) *ClientIface_TransmitResponse_Call {
	_c.Call.Return(run)
	return _c
}

// TransmitWithDeadline provides a mock function with given fields: req, deadline
func (_m *ClientIface) TransmitWithDeadline(req *gomemcached.MCRequest, deadline time.Time) error {
	ret := _m.Called(req, deadline)

	var r0 error
	if rf, ok := ret.Get(0).(func(*gomemcached.MCRequest, time.Time) error); ok {
		r0 = rf(req, deadline)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ClientIface_TransmitWithDeadline_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TransmitWithDeadline'
type ClientIface_TransmitWithDeadline_Call struct {
	*mock.Call
}

// TransmitWithDeadline is a helper method to define mock.On call
//   - req *gomemcached.MCRequest
//   - deadline time.Time
func (_e *ClientIface_Expecter) TransmitWithDeadline(req interface{}, deadline interface{}) *ClientIface_TransmitWithDeadline_Call {
	return &ClientIface_TransmitWithDeadline_Call{Call: _e.mock.On("TransmitWithDeadline", req, deadline)}
}

func (_c *ClientIface_TransmitWithDeadline_Call) Run(run func(req *gomemcached.MCRequest, deadline time.Time)) *ClientIface_TransmitWithDeadline_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*gomemcached.MCRequest), args[1].(time.Time))
	})
	return _c
}

func (_c *ClientIface_TransmitWithDeadline_Call) Return(_a0 error) *ClientIface_TransmitWithDeadline_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ClientIface_TransmitWithDeadline_Call) RunAndReturn(run func(*gomemcached.MCRequest, time.Time) error) *ClientIface_TransmitWithDeadline_Call {
	_c.Call.Return(run)
	return _c
}

// UprGetFailoverLog provides a mock function with given fields: vb
func (_m *ClientIface) UprGetFailoverLog(vb []uint16) (map[uint16]*memcached.FailoverLog, error) {
	ret := _m.Called(vb)

	var r0 map[uint16]*memcached.FailoverLog
	var r1 error
	if rf, ok := ret.Get(0).(func([]uint16) (map[uint16]*memcached.FailoverLog, error)); ok {
		return rf(vb)
	}
	if rf, ok := ret.Get(0).(func([]uint16) map[uint16]*memcached.FailoverLog); ok {
		r0 = rf(vb)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[uint16]*memcached.FailoverLog)
		}
	}

	if rf, ok := ret.Get(1).(func([]uint16) error); ok {
		r1 = rf(vb)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientIface_UprGetFailoverLog_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UprGetFailoverLog'
type ClientIface_UprGetFailoverLog_Call struct {
	*mock.Call
}

// UprGetFailoverLog is a helper method to define mock.On call
//   - vb []uint16
func (_e *ClientIface_Expecter) UprGetFailoverLog(vb interface{}) *ClientIface_UprGetFailoverLog_Call {
	return &ClientIface_UprGetFailoverLog_Call{Call: _e.mock.On("UprGetFailoverLog", vb)}
}

func (_c *ClientIface_UprGetFailoverLog_Call) Run(run func(vb []uint16)) *ClientIface_UprGetFailoverLog_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]uint16))
	})
	return _c
}

func (_c *ClientIface_UprGetFailoverLog_Call) Return(_a0 map[uint16]*memcached.FailoverLog, _a1 error) *ClientIface_UprGetFailoverLog_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientIface_UprGetFailoverLog_Call) RunAndReturn(run func([]uint16) (map[uint16]*memcached.FailoverLog, error)) *ClientIface_UprGetFailoverLog_Call {
	_c.Call.Return(run)
	return _c
}

// ValidateKey provides a mock function with given fields: vb, key, context
func (_m *ClientIface) ValidateKey(vb uint16, key string, context ...*memcached.ClientContext) (bool, error) {
	_va := make([]interface{}, len(context))
	for _i := range context {
		_va[_i] = context[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, vb, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(uint16, string, ...*memcached.ClientContext) (bool, error)); ok {
		return rf(vb, key, context...)
	}
	if rf, ok := ret.Get(0).(func(uint16, string, ...*memcached.ClientContext) bool); ok {
		r0 = rf(vb, key, context...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(uint16, string, ...*memcached.ClientContext) error); ok {
		r1 = rf(vb, key, context...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientIface_ValidateKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ValidateKey'
type ClientIface_ValidateKey_Call struct {
	*mock.Call
}

// ValidateKey is a helper method to define mock.On call
//   - vb uint16
//   - key string
//   - context ...*memcached.ClientContext
func (_e *ClientIface_Expecter) ValidateKey(vb interface{}, key interface{}, context ...interface{}) *ClientIface_ValidateKey_Call {
	return &ClientIface_ValidateKey_Call{Call: _e.mock.On("ValidateKey",
		append([]interface{}{vb, key}, context...)...)}
}

func (_c *ClientIface_ValidateKey_Call) Run(run func(vb uint16, key string, context ...*memcached.ClientContext)) *ClientIface_ValidateKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]*memcached.ClientContext, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(*memcached.ClientContext)
			}
		}
		run(args[0].(uint16), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *ClientIface_ValidateKey_Call) Return(_a0 bool, _a1 error) *ClientIface_ValidateKey_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientIface_ValidateKey_Call) RunAndReturn(run func(uint16, string, ...*memcached.ClientContext) (bool, error)) *ClientIface_ValidateKey_Call {
	_c.Call.Return(run)
	return _c
}

// NewClientIface creates a new instance of ClientIface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewClientIface(t interface {
	mock.TestingT
	Cleanup(func())
}) *ClientIface {
	mock := &ClientIface{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
