// Code generated by mockery. DO NOT EDIT.

package mocks

import (
	base "github.com/couchbase/goxdcr/base"
	common "github.com/couchbase/goxdcr/common"

	metadata "github.com/couchbase/goxdcr/metadata"

	mock "github.com/stretchr/testify/mock"
)

// XDCRFactoryIface is an autogenerated mock type for the XDCRFactoryIface type
type XDCRFactoryIface struct {
	mock.Mock
}

type XDCRFactoryIface_Expecter struct {
	mock *mock.Mock
}

func (_m *XDCRFactoryIface) EXPECT() *XDCRFactoryIface_Expecter {
	return &XDCRFactoryIface_Expecter{mock: &_m.Mock}
}

// CheckpointBeforeStop provides a mock function with given fields: pipeline
func (_m *XDCRFactoryIface) CheckpointBeforeStop(pipeline common.Pipeline) error {
	ret := _m.Called(pipeline)

	if len(ret) == 0 {
		panic("no return value specified for CheckpointBeforeStop")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(common.Pipeline) error); ok {
		r0 = rf(pipeline)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// XDCRFactoryIface_CheckpointBeforeStop_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CheckpointBeforeStop'
type XDCRFactoryIface_CheckpointBeforeStop_Call struct {
	*mock.Call
}

// CheckpointBeforeStop is a helper method to define mock.On call
//   - pipeline common.Pipeline
func (_e *XDCRFactoryIface_Expecter) CheckpointBeforeStop(pipeline interface{}) *XDCRFactoryIface_CheckpointBeforeStop_Call {
	return &XDCRFactoryIface_CheckpointBeforeStop_Call{Call: _e.mock.On("CheckpointBeforeStop", pipeline)}
}

func (_c *XDCRFactoryIface_CheckpointBeforeStop_Call) Run(run func(pipeline common.Pipeline)) *XDCRFactoryIface_CheckpointBeforeStop_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(common.Pipeline))
	})
	return _c
}

func (_c *XDCRFactoryIface_CheckpointBeforeStop_Call) Return(_a0 error) *XDCRFactoryIface_CheckpointBeforeStop_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *XDCRFactoryIface_CheckpointBeforeStop_Call) RunAndReturn(run func(common.Pipeline) error) *XDCRFactoryIface_CheckpointBeforeStop_Call {
	_c.Call.Return(run)
	return _c
}

// ConstructSSLPortMap provides a mock function with given fields: targetClusterRef, spec
func (_m *XDCRFactoryIface) ConstructSSLPortMap(targetClusterRef *metadata.RemoteClusterReference, spec *metadata.ReplicationSpecification) (map[string]uint16, bool, error) {
	ret := _m.Called(targetClusterRef, spec)

	if len(ret) == 0 {
		panic("no return value specified for ConstructSSLPortMap")
	}

	var r0 map[string]uint16
	var r1 bool
	var r2 error
	if rf, ok := ret.Get(0).(func(*metadata.RemoteClusterReference, *metadata.ReplicationSpecification) (map[string]uint16, bool, error)); ok {
		return rf(targetClusterRef, spec)
	}
	if rf, ok := ret.Get(0).(func(*metadata.RemoteClusterReference, *metadata.ReplicationSpecification) map[string]uint16); ok {
		r0 = rf(targetClusterRef, spec)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]uint16)
		}
	}

	if rf, ok := ret.Get(1).(func(*metadata.RemoteClusterReference, *metadata.ReplicationSpecification) bool); ok {
		r1 = rf(targetClusterRef, spec)
	} else {
		r1 = ret.Get(1).(bool)
	}

	if rf, ok := ret.Get(2).(func(*metadata.RemoteClusterReference, *metadata.ReplicationSpecification) error); ok {
		r2 = rf(targetClusterRef, spec)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// XDCRFactoryIface_ConstructSSLPortMap_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConstructSSLPortMap'
type XDCRFactoryIface_ConstructSSLPortMap_Call struct {
	*mock.Call
}

// ConstructSSLPortMap is a helper method to define mock.On call
//   - targetClusterRef *metadata.RemoteClusterReference
//   - spec *metadata.ReplicationSpecification
func (_e *XDCRFactoryIface_Expecter) ConstructSSLPortMap(targetClusterRef interface{}, spec interface{}) *XDCRFactoryIface_ConstructSSLPortMap_Call {
	return &XDCRFactoryIface_ConstructSSLPortMap_Call{Call: _e.mock.On("ConstructSSLPortMap", targetClusterRef, spec)}
}

func (_c *XDCRFactoryIface_ConstructSSLPortMap_Call) Run(run func(targetClusterRef *metadata.RemoteClusterReference, spec *metadata.ReplicationSpecification)) *XDCRFactoryIface_ConstructSSLPortMap_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*metadata.RemoteClusterReference), args[1].(*metadata.ReplicationSpecification))
	})
	return _c
}

func (_c *XDCRFactoryIface_ConstructSSLPortMap_Call) Return(_a0 map[string]uint16, _a1 bool, _a2 error) *XDCRFactoryIface_ConstructSSLPortMap_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *XDCRFactoryIface_ConstructSSLPortMap_Call) RunAndReturn(run func(*metadata.RemoteClusterReference, *metadata.ReplicationSpecification) (map[string]uint16, bool, error)) *XDCRFactoryIface_ConstructSSLPortMap_Call {
	_c.Call.Return(run)
	return _c
}

// ConstructSettingsForConnector provides a mock function with given fields: pipeline, connector, settings
func (_m *XDCRFactoryIface) ConstructSettingsForConnector(pipeline common.Pipeline, connector common.Connector, settings metadata.ReplicationSettingsMap) (metadata.ReplicationSettingsMap, error) {
	ret := _m.Called(pipeline, connector, settings)

	if len(ret) == 0 {
		panic("no return value specified for ConstructSettingsForConnector")
	}

	var r0 metadata.ReplicationSettingsMap
	var r1 error
	if rf, ok := ret.Get(0).(func(common.Pipeline, common.Connector, metadata.ReplicationSettingsMap) (metadata.ReplicationSettingsMap, error)); ok {
		return rf(pipeline, connector, settings)
	}
	if rf, ok := ret.Get(0).(func(common.Pipeline, common.Connector, metadata.ReplicationSettingsMap) metadata.ReplicationSettingsMap); ok {
		r0 = rf(pipeline, connector, settings)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(metadata.ReplicationSettingsMap)
		}
	}

	if rf, ok := ret.Get(1).(func(common.Pipeline, common.Connector, metadata.ReplicationSettingsMap) error); ok {
		r1 = rf(pipeline, connector, settings)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// XDCRFactoryIface_ConstructSettingsForConnector_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConstructSettingsForConnector'
type XDCRFactoryIface_ConstructSettingsForConnector_Call struct {
	*mock.Call
}

// ConstructSettingsForConnector is a helper method to define mock.On call
//   - pipeline common.Pipeline
//   - connector common.Connector
//   - settings metadata.ReplicationSettingsMap
func (_e *XDCRFactoryIface_Expecter) ConstructSettingsForConnector(pipeline interface{}, connector interface{}, settings interface{}) *XDCRFactoryIface_ConstructSettingsForConnector_Call {
	return &XDCRFactoryIface_ConstructSettingsForConnector_Call{Call: _e.mock.On("ConstructSettingsForConnector", pipeline, connector, settings)}
}

func (_c *XDCRFactoryIface_ConstructSettingsForConnector_Call) Run(run func(pipeline common.Pipeline, connector common.Connector, settings metadata.ReplicationSettingsMap)) *XDCRFactoryIface_ConstructSettingsForConnector_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(common.Pipeline), args[1].(common.Connector), args[2].(metadata.ReplicationSettingsMap))
	})
	return _c
}

func (_c *XDCRFactoryIface_ConstructSettingsForConnector_Call) Return(_a0 metadata.ReplicationSettingsMap, _a1 error) *XDCRFactoryIface_ConstructSettingsForConnector_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *XDCRFactoryIface_ConstructSettingsForConnector_Call) RunAndReturn(run func(common.Pipeline, common.Connector, metadata.ReplicationSettingsMap) (metadata.ReplicationSettingsMap, error)) *XDCRFactoryIface_ConstructSettingsForConnector_Call {
	_c.Call.Return(run)
	return _c
}

// ConstructSettingsForPart provides a mock function with given fields: pipeline, part, settings, targetClusterRef, ssl_port_map, isSSLOverMem
func (_m *XDCRFactoryIface) ConstructSettingsForPart(pipeline common.Pipeline, part common.Part, settings metadata.ReplicationSettingsMap, targetClusterRef *metadata.RemoteClusterReference, ssl_port_map map[string]uint16, isSSLOverMem bool) (metadata.ReplicationSettingsMap, error) {
	ret := _m.Called(pipeline, part, settings, targetClusterRef, ssl_port_map, isSSLOverMem)

	if len(ret) == 0 {
		panic("no return value specified for ConstructSettingsForPart")
	}

	var r0 metadata.ReplicationSettingsMap
	var r1 error
	if rf, ok := ret.Get(0).(func(common.Pipeline, common.Part, metadata.ReplicationSettingsMap, *metadata.RemoteClusterReference, map[string]uint16, bool) (metadata.ReplicationSettingsMap, error)); ok {
		return rf(pipeline, part, settings, targetClusterRef, ssl_port_map, isSSLOverMem)
	}
	if rf, ok := ret.Get(0).(func(common.Pipeline, common.Part, metadata.ReplicationSettingsMap, *metadata.RemoteClusterReference, map[string]uint16, bool) metadata.ReplicationSettingsMap); ok {
		r0 = rf(pipeline, part, settings, targetClusterRef, ssl_port_map, isSSLOverMem)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(metadata.ReplicationSettingsMap)
		}
	}

	if rf, ok := ret.Get(1).(func(common.Pipeline, common.Part, metadata.ReplicationSettingsMap, *metadata.RemoteClusterReference, map[string]uint16, bool) error); ok {
		r1 = rf(pipeline, part, settings, targetClusterRef, ssl_port_map, isSSLOverMem)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// XDCRFactoryIface_ConstructSettingsForPart_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConstructSettingsForPart'
type XDCRFactoryIface_ConstructSettingsForPart_Call struct {
	*mock.Call
}

// ConstructSettingsForPart is a helper method to define mock.On call
//   - pipeline common.Pipeline
//   - part common.Part
//   - settings metadata.ReplicationSettingsMap
//   - targetClusterRef *metadata.RemoteClusterReference
//   - ssl_port_map map[string]uint16
//   - isSSLOverMem bool
func (_e *XDCRFactoryIface_Expecter) ConstructSettingsForPart(pipeline interface{}, part interface{}, settings interface{}, targetClusterRef interface{}, ssl_port_map interface{}, isSSLOverMem interface{}) *XDCRFactoryIface_ConstructSettingsForPart_Call {
	return &XDCRFactoryIface_ConstructSettingsForPart_Call{Call: _e.mock.On("ConstructSettingsForPart", pipeline, part, settings, targetClusterRef, ssl_port_map, isSSLOverMem)}
}

func (_c *XDCRFactoryIface_ConstructSettingsForPart_Call) Run(run func(pipeline common.Pipeline, part common.Part, settings metadata.ReplicationSettingsMap, targetClusterRef *metadata.RemoteClusterReference, ssl_port_map map[string]uint16, isSSLOverMem bool)) *XDCRFactoryIface_ConstructSettingsForPart_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(common.Pipeline), args[1].(common.Part), args[2].(metadata.ReplicationSettingsMap), args[3].(*metadata.RemoteClusterReference), args[4].(map[string]uint16), args[5].(bool))
	})
	return _c
}

func (_c *XDCRFactoryIface_ConstructSettingsForPart_Call) Return(_a0 metadata.ReplicationSettingsMap, _a1 error) *XDCRFactoryIface_ConstructSettingsForPart_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *XDCRFactoryIface_ConstructSettingsForPart_Call) RunAndReturn(run func(common.Pipeline, common.Part, metadata.ReplicationSettingsMap, *metadata.RemoteClusterReference, map[string]uint16, bool) (metadata.ReplicationSettingsMap, error)) *XDCRFactoryIface_ConstructSettingsForPart_Call {
	_c.Call.Return(run)
	return _c
}

// ConstructUpdateSettingsForConnector provides a mock function with given fields: pipeline, connector, settings
func (_m *XDCRFactoryIface) ConstructUpdateSettingsForConnector(pipeline common.Pipeline, connector common.Connector, settings metadata.ReplicationSettingsMap) (metadata.ReplicationSettingsMap, error) {
	ret := _m.Called(pipeline, connector, settings)

	if len(ret) == 0 {
		panic("no return value specified for ConstructUpdateSettingsForConnector")
	}

	var r0 metadata.ReplicationSettingsMap
	var r1 error
	if rf, ok := ret.Get(0).(func(common.Pipeline, common.Connector, metadata.ReplicationSettingsMap) (metadata.ReplicationSettingsMap, error)); ok {
		return rf(pipeline, connector, settings)
	}
	if rf, ok := ret.Get(0).(func(common.Pipeline, common.Connector, metadata.ReplicationSettingsMap) metadata.ReplicationSettingsMap); ok {
		r0 = rf(pipeline, connector, settings)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(metadata.ReplicationSettingsMap)
		}
	}

	if rf, ok := ret.Get(1).(func(common.Pipeline, common.Connector, metadata.ReplicationSettingsMap) error); ok {
		r1 = rf(pipeline, connector, settings)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// XDCRFactoryIface_ConstructUpdateSettingsForConnector_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConstructUpdateSettingsForConnector'
type XDCRFactoryIface_ConstructUpdateSettingsForConnector_Call struct {
	*mock.Call
}

// ConstructUpdateSettingsForConnector is a helper method to define mock.On call
//   - pipeline common.Pipeline
//   - connector common.Connector
//   - settings metadata.ReplicationSettingsMap
func (_e *XDCRFactoryIface_Expecter) ConstructUpdateSettingsForConnector(pipeline interface{}, connector interface{}, settings interface{}) *XDCRFactoryIface_ConstructUpdateSettingsForConnector_Call {
	return &XDCRFactoryIface_ConstructUpdateSettingsForConnector_Call{Call: _e.mock.On("ConstructUpdateSettingsForConnector", pipeline, connector, settings)}
}

func (_c *XDCRFactoryIface_ConstructUpdateSettingsForConnector_Call) Run(run func(pipeline common.Pipeline, connector common.Connector, settings metadata.ReplicationSettingsMap)) *XDCRFactoryIface_ConstructUpdateSettingsForConnector_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(common.Pipeline), args[1].(common.Connector), args[2].(metadata.ReplicationSettingsMap))
	})
	return _c
}

func (_c *XDCRFactoryIface_ConstructUpdateSettingsForConnector_Call) Return(_a0 metadata.ReplicationSettingsMap, _a1 error) *XDCRFactoryIface_ConstructUpdateSettingsForConnector_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *XDCRFactoryIface_ConstructUpdateSettingsForConnector_Call) RunAndReturn(run func(common.Pipeline, common.Connector, metadata.ReplicationSettingsMap) (metadata.ReplicationSettingsMap, error)) *XDCRFactoryIface_ConstructUpdateSettingsForConnector_Call {
	_c.Call.Return(run)
	return _c
}

// ConstructUpdateSettingsForPart provides a mock function with given fields: pipeline, part, settings
func (_m *XDCRFactoryIface) ConstructUpdateSettingsForPart(pipeline common.Pipeline, part common.Part, settings metadata.ReplicationSettingsMap) (metadata.ReplicationSettingsMap, error) {
	ret := _m.Called(pipeline, part, settings)

	if len(ret) == 0 {
		panic("no return value specified for ConstructUpdateSettingsForPart")
	}

	var r0 metadata.ReplicationSettingsMap
	var r1 error
	if rf, ok := ret.Get(0).(func(common.Pipeline, common.Part, metadata.ReplicationSettingsMap) (metadata.ReplicationSettingsMap, error)); ok {
		return rf(pipeline, part, settings)
	}
	if rf, ok := ret.Get(0).(func(common.Pipeline, common.Part, metadata.ReplicationSettingsMap) metadata.ReplicationSettingsMap); ok {
		r0 = rf(pipeline, part, settings)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(metadata.ReplicationSettingsMap)
		}
	}

	if rf, ok := ret.Get(1).(func(common.Pipeline, common.Part, metadata.ReplicationSettingsMap) error); ok {
		r1 = rf(pipeline, part, settings)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// XDCRFactoryIface_ConstructUpdateSettingsForPart_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConstructUpdateSettingsForPart'
type XDCRFactoryIface_ConstructUpdateSettingsForPart_Call struct {
	*mock.Call
}

// ConstructUpdateSettingsForPart is a helper method to define mock.On call
//   - pipeline common.Pipeline
//   - part common.Part
//   - settings metadata.ReplicationSettingsMap
func (_e *XDCRFactoryIface_Expecter) ConstructUpdateSettingsForPart(pipeline interface{}, part interface{}, settings interface{}) *XDCRFactoryIface_ConstructUpdateSettingsForPart_Call {
	return &XDCRFactoryIface_ConstructUpdateSettingsForPart_Call{Call: _e.mock.On("ConstructUpdateSettingsForPart", pipeline, part, settings)}
}

func (_c *XDCRFactoryIface_ConstructUpdateSettingsForPart_Call) Run(run func(pipeline common.Pipeline, part common.Part, settings metadata.ReplicationSettingsMap)) *XDCRFactoryIface_ConstructUpdateSettingsForPart_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(common.Pipeline), args[1].(common.Part), args[2].(metadata.ReplicationSettingsMap))
	})
	return _c
}

func (_c *XDCRFactoryIface_ConstructUpdateSettingsForPart_Call) Return(_a0 metadata.ReplicationSettingsMap, _a1 error) *XDCRFactoryIface_ConstructUpdateSettingsForPart_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *XDCRFactoryIface_ConstructUpdateSettingsForPart_Call) RunAndReturn(run func(common.Pipeline, common.Part, metadata.ReplicationSettingsMap) (metadata.ReplicationSettingsMap, error)) *XDCRFactoryIface_ConstructUpdateSettingsForPart_Call {
	_c.Call.Return(run)
	return _c
}

// ConstructUpdateSettingsForService provides a mock function with given fields: pipeline, service, settings
func (_m *XDCRFactoryIface) ConstructUpdateSettingsForService(pipeline common.Pipeline, service common.PipelineService, settings metadata.ReplicationSettingsMap) (metadata.ReplicationSettingsMap, error) {
	ret := _m.Called(pipeline, service, settings)

	if len(ret) == 0 {
		panic("no return value specified for ConstructUpdateSettingsForService")
	}

	var r0 metadata.ReplicationSettingsMap
	var r1 error
	if rf, ok := ret.Get(0).(func(common.Pipeline, common.PipelineService, metadata.ReplicationSettingsMap) (metadata.ReplicationSettingsMap, error)); ok {
		return rf(pipeline, service, settings)
	}
	if rf, ok := ret.Get(0).(func(common.Pipeline, common.PipelineService, metadata.ReplicationSettingsMap) metadata.ReplicationSettingsMap); ok {
		r0 = rf(pipeline, service, settings)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(metadata.ReplicationSettingsMap)
		}
	}

	if rf, ok := ret.Get(1).(func(common.Pipeline, common.PipelineService, metadata.ReplicationSettingsMap) error); ok {
		r1 = rf(pipeline, service, settings)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// XDCRFactoryIface_ConstructUpdateSettingsForService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConstructUpdateSettingsForService'
type XDCRFactoryIface_ConstructUpdateSettingsForService_Call struct {
	*mock.Call
}

// ConstructUpdateSettingsForService is a helper method to define mock.On call
//   - pipeline common.Pipeline
//   - service common.PipelineService
//   - settings metadata.ReplicationSettingsMap
func (_e *XDCRFactoryIface_Expecter) ConstructUpdateSettingsForService(pipeline interface{}, service interface{}, settings interface{}) *XDCRFactoryIface_ConstructUpdateSettingsForService_Call {
	return &XDCRFactoryIface_ConstructUpdateSettingsForService_Call{Call: _e.mock.On("ConstructUpdateSettingsForService", pipeline, service, settings)}
}

func (_c *XDCRFactoryIface_ConstructUpdateSettingsForService_Call) Run(run func(pipeline common.Pipeline, service common.PipelineService, settings metadata.ReplicationSettingsMap)) *XDCRFactoryIface_ConstructUpdateSettingsForService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(common.Pipeline), args[1].(common.PipelineService), args[2].(metadata.ReplicationSettingsMap))
	})
	return _c
}

func (_c *XDCRFactoryIface_ConstructUpdateSettingsForService_Call) Return(_a0 metadata.ReplicationSettingsMap, _a1 error) *XDCRFactoryIface_ConstructUpdateSettingsForService_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *XDCRFactoryIface_ConstructUpdateSettingsForService_Call) RunAndReturn(run func(common.Pipeline, common.PipelineService, metadata.ReplicationSettingsMap) (metadata.ReplicationSettingsMap, error)) *XDCRFactoryIface_ConstructUpdateSettingsForService_Call {
	_c.Call.Return(run)
	return _c
}

// NewPipeline provides a mock function with given fields: topic, progressRecorder
func (_m *XDCRFactoryIface) NewPipeline(topic string, progressRecorder common.PipelineProgressRecorder) (common.Pipeline, error) {
	ret := _m.Called(topic, progressRecorder)

	if len(ret) == 0 {
		panic("no return value specified for NewPipeline")
	}

	var r0 common.Pipeline
	var r1 error
	if rf, ok := ret.Get(0).(func(string, common.PipelineProgressRecorder) (common.Pipeline, error)); ok {
		return rf(topic, progressRecorder)
	}
	if rf, ok := ret.Get(0).(func(string, common.PipelineProgressRecorder) common.Pipeline); ok {
		r0 = rf(topic, progressRecorder)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Pipeline)
		}
	}

	if rf, ok := ret.Get(1).(func(string, common.PipelineProgressRecorder) error); ok {
		r1 = rf(topic, progressRecorder)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// XDCRFactoryIface_NewPipeline_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NewPipeline'
type XDCRFactoryIface_NewPipeline_Call struct {
	*mock.Call
}

// NewPipeline is a helper method to define mock.On call
//   - topic string
//   - progressRecorder common.PipelineProgressRecorder
func (_e *XDCRFactoryIface_Expecter) NewPipeline(topic interface{}, progressRecorder interface{}) *XDCRFactoryIface_NewPipeline_Call {
	return &XDCRFactoryIface_NewPipeline_Call{Call: _e.mock.On("NewPipeline", topic, progressRecorder)}
}

func (_c *XDCRFactoryIface_NewPipeline_Call) Run(run func(topic string, progressRecorder common.PipelineProgressRecorder)) *XDCRFactoryIface_NewPipeline_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(common.PipelineProgressRecorder))
	})
	return _c
}

func (_c *XDCRFactoryIface_NewPipeline_Call) Return(_a0 common.Pipeline, _a1 error) *XDCRFactoryIface_NewPipeline_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *XDCRFactoryIface_NewPipeline_Call) RunAndReturn(run func(string, common.PipelineProgressRecorder) (common.Pipeline, error)) *XDCRFactoryIface_NewPipeline_Call {
	_c.Call.Return(run)
	return _c
}

// NewSecondaryPipeline provides a mock function with given fields: topic, primaryPipeline, progress_recorder, pipelineType
func (_m *XDCRFactoryIface) NewSecondaryPipeline(topic string, primaryPipeline common.Pipeline, progress_recorder common.PipelineProgressRecorder, pipelineType common.PipelineType) (common.Pipeline, error) {
	ret := _m.Called(topic, primaryPipeline, progress_recorder, pipelineType)

	if len(ret) == 0 {
		panic("no return value specified for NewSecondaryPipeline")
	}

	var r0 common.Pipeline
	var r1 error
	if rf, ok := ret.Get(0).(func(string, common.Pipeline, common.PipelineProgressRecorder, common.PipelineType) (common.Pipeline, error)); ok {
		return rf(topic, primaryPipeline, progress_recorder, pipelineType)
	}
	if rf, ok := ret.Get(0).(func(string, common.Pipeline, common.PipelineProgressRecorder, common.PipelineType) common.Pipeline); ok {
		r0 = rf(topic, primaryPipeline, progress_recorder, pipelineType)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Pipeline)
		}
	}

	if rf, ok := ret.Get(1).(func(string, common.Pipeline, common.PipelineProgressRecorder, common.PipelineType) error); ok {
		r1 = rf(topic, primaryPipeline, progress_recorder, pipelineType)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// XDCRFactoryIface_NewSecondaryPipeline_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NewSecondaryPipeline'
type XDCRFactoryIface_NewSecondaryPipeline_Call struct {
	*mock.Call
}

// NewSecondaryPipeline is a helper method to define mock.On call
//   - topic string
//   - primaryPipeline common.Pipeline
//   - progress_recorder common.PipelineProgressRecorder
//   - pipelineType common.PipelineType
func (_e *XDCRFactoryIface_Expecter) NewSecondaryPipeline(topic interface{}, primaryPipeline interface{}, progress_recorder interface{}, pipelineType interface{}) *XDCRFactoryIface_NewSecondaryPipeline_Call {
	return &XDCRFactoryIface_NewSecondaryPipeline_Call{Call: _e.mock.On("NewSecondaryPipeline", topic, primaryPipeline, progress_recorder, pipelineType)}
}

func (_c *XDCRFactoryIface_NewSecondaryPipeline_Call) Run(run func(topic string, primaryPipeline common.Pipeline, progress_recorder common.PipelineProgressRecorder, pipelineType common.PipelineType)) *XDCRFactoryIface_NewSecondaryPipeline_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(common.Pipeline), args[2].(common.PipelineProgressRecorder), args[3].(common.PipelineType))
	})
	return _c
}

func (_c *XDCRFactoryIface_NewSecondaryPipeline_Call) Return(_a0 common.Pipeline, _a1 error) *XDCRFactoryIface_NewSecondaryPipeline_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *XDCRFactoryIface_NewSecondaryPipeline_Call) RunAndReturn(run func(string, common.Pipeline, common.PipelineProgressRecorder, common.PipelineType) (common.Pipeline, error)) *XDCRFactoryIface_NewSecondaryPipeline_Call {
	_c.Call.Return(run)
	return _c
}

// SetPipelineStopCallback provides a mock function with given fields: cbType
func (_m *XDCRFactoryIface) SetPipelineStopCallback(cbType base.PipelineMgrStopCbType) {
	_m.Called(cbType)
}

// XDCRFactoryIface_SetPipelineStopCallback_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetPipelineStopCallback'
type XDCRFactoryIface_SetPipelineStopCallback_Call struct {
	*mock.Call
}

// SetPipelineStopCallback is a helper method to define mock.On call
//   - cbType base.PipelineMgrStopCbType
func (_e *XDCRFactoryIface_Expecter) SetPipelineStopCallback(cbType interface{}) *XDCRFactoryIface_SetPipelineStopCallback_Call {
	return &XDCRFactoryIface_SetPipelineStopCallback_Call{Call: _e.mock.On("SetPipelineStopCallback", cbType)}
}

func (_c *XDCRFactoryIface_SetPipelineStopCallback_Call) Run(run func(cbType base.PipelineMgrStopCbType)) *XDCRFactoryIface_SetPipelineStopCallback_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(base.PipelineMgrStopCbType))
	})
	return _c
}

func (_c *XDCRFactoryIface_SetPipelineStopCallback_Call) Return() *XDCRFactoryIface_SetPipelineStopCallback_Call {
	_c.Call.Return()
	return _c
}

func (_c *XDCRFactoryIface_SetPipelineStopCallback_Call) RunAndReturn(run func(base.PipelineMgrStopCbType)) *XDCRFactoryIface_SetPipelineStopCallback_Call {
	_c.Call.Return(run)
	return _c
}

// SetStartSeqno provides a mock function with given fields: pipeline
func (_m *XDCRFactoryIface) SetStartSeqno(pipeline common.Pipeline) error {
	ret := _m.Called(pipeline)

	if len(ret) == 0 {
		panic("no return value specified for SetStartSeqno")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(common.Pipeline) error); ok {
		r0 = rf(pipeline)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// XDCRFactoryIface_SetStartSeqno_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetStartSeqno'
type XDCRFactoryIface_SetStartSeqno_Call struct {
	*mock.Call
}

// SetStartSeqno is a helper method to define mock.On call
//   - pipeline common.Pipeline
func (_e *XDCRFactoryIface_Expecter) SetStartSeqno(pipeline interface{}) *XDCRFactoryIface_SetStartSeqno_Call {
	return &XDCRFactoryIface_SetStartSeqno_Call{Call: _e.mock.On("SetStartSeqno", pipeline)}
}

func (_c *XDCRFactoryIface_SetStartSeqno_Call) Run(run func(pipeline common.Pipeline)) *XDCRFactoryIface_SetStartSeqno_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(common.Pipeline))
	})
	return _c
}

func (_c *XDCRFactoryIface_SetStartSeqno_Call) Return(_a0 error) *XDCRFactoryIface_SetStartSeqno_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *XDCRFactoryIface_SetStartSeqno_Call) RunAndReturn(run func(common.Pipeline) error) *XDCRFactoryIface_SetStartSeqno_Call {
	_c.Call.Return(run)
	return _c
}

// NewXDCRFactoryIface creates a new instance of XDCRFactoryIface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewXDCRFactoryIface(t interface {
	mock.TestingT
	Cleanup(func())
}) *XDCRFactoryIface {
	mock := &XDCRFactoryIface{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
