// Code generated by mockery. DO NOT EDIT.

package mocks

import (
	couchbase "github.com/couchbase/go-couchbase"
	base "github.com/couchbase/goxdcr/base"

	expvar "expvar"

	gomemcached "github.com/couchbase/gomemcached"

	http "net/http"

	log "github.com/couchbase/goxdcr/log"

	memcached "github.com/couchbase/gomemcached/client"

	metadata "github.com/couchbase/goxdcr/metadata"

	mock "github.com/stretchr/testify/mock"

	net "net"

	time "time"

	utils "github.com/couchbase/goxdcr/utils"
)

// UtilsIface is an autogenerated mock type for the UtilsIface type
type UtilsIface struct {
	mock.Mock
}

type UtilsIface_Expecter struct {
	mock *mock.Mock
}

func (_m *UtilsIface) EXPECT() *UtilsIface_Expecter {
	return &UtilsIface_Expecter{mock: &_m.Mock}
}

// AddKeyToBeFiltered provides a mock function with given fields: currentValue, key, dpGetter, toBeReleased, currentValueEndBody
func (_m *UtilsIface) AddKeyToBeFiltered(currentValue []byte, key []byte, dpGetter base.DpGetterFunc, toBeReleased *[][]byte, currentValueEndBody int) ([]byte, error, int64, int) {
	ret := _m.Called(currentValue, key, dpGetter, toBeReleased, currentValueEndBody)

	var r0 []byte
	var r1 error
	var r2 int64
	var r3 int
	if rf, ok := ret.Get(0).(func([]byte, []byte, base.DpGetterFunc, *[][]byte, int) ([]byte, error, int64, int)); ok {
		return rf(currentValue, key, dpGetter, toBeReleased, currentValueEndBody)
	}
	if rf, ok := ret.Get(0).(func([]byte, []byte, base.DpGetterFunc, *[][]byte, int) []byte); ok {
		r0 = rf(currentValue, key, dpGetter, toBeReleased, currentValueEndBody)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func([]byte, []byte, base.DpGetterFunc, *[][]byte, int) error); ok {
		r1 = rf(currentValue, key, dpGetter, toBeReleased, currentValueEndBody)
	} else {
		r1 = ret.Error(1)
	}

	if rf, ok := ret.Get(2).(func([]byte, []byte, base.DpGetterFunc, *[][]byte, int) int64); ok {
		r2 = rf(currentValue, key, dpGetter, toBeReleased, currentValueEndBody)
	} else {
		r2 = ret.Get(2).(int64)
	}

	if rf, ok := ret.Get(3).(func([]byte, []byte, base.DpGetterFunc, *[][]byte, int) int); ok {
		r3 = rf(currentValue, key, dpGetter, toBeReleased, currentValueEndBody)
	} else {
		r3 = ret.Get(3).(int)
	}

	return r0, r1, r2, r3
}

// UtilsIface_AddKeyToBeFiltered_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddKeyToBeFiltered'
type UtilsIface_AddKeyToBeFiltered_Call struct {
	*mock.Call
}

// AddKeyToBeFiltered is a helper method to define mock.On call
//   - currentValue []byte
//   - key []byte
//   - dpGetter base.DpGetterFunc
//   - toBeReleased *[][]byte
//   - currentValueEndBody int
func (_e *UtilsIface_Expecter) AddKeyToBeFiltered(currentValue interface{}, key interface{}, dpGetter interface{}, toBeReleased interface{}, currentValueEndBody interface{}) *UtilsIface_AddKeyToBeFiltered_Call {
	return &UtilsIface_AddKeyToBeFiltered_Call{Call: _e.mock.On("AddKeyToBeFiltered", currentValue, key, dpGetter, toBeReleased, currentValueEndBody)}
}

func (_c *UtilsIface_AddKeyToBeFiltered_Call) Run(run func(currentValue []byte, key []byte, dpGetter base.DpGetterFunc, toBeReleased *[][]byte, currentValueEndBody int)) *UtilsIface_AddKeyToBeFiltered_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]byte), args[1].([]byte), args[2].(base.DpGetterFunc), args[3].(*[][]byte), args[4].(int))
	})
	return _c
}

func (_c *UtilsIface_AddKeyToBeFiltered_Call) Return(_a0 []byte, _a1 error, _a2 int64, _a3 int) *UtilsIface_AddKeyToBeFiltered_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3)
	return _c
}

func (_c *UtilsIface_AddKeyToBeFiltered_Call) RunAndReturn(run func([]byte, []byte, base.DpGetterFunc, *[][]byte, int) ([]byte, error, int64, int)) *UtilsIface_AddKeyToBeFiltered_Call {
	_c.Call.Return(run)
	return _c
}

// BucketInfoParseError provides a mock function with given fields: bucketInfo, errMsg, logger
func (_m *UtilsIface) BucketInfoParseError(bucketInfo map[string]interface{}, errMsg string, logger *log.CommonLogger) error {
	ret := _m.Called(bucketInfo, errMsg, logger)

	var r0 error
	if rf, ok := ret.Get(0).(func(map[string]interface{}, string, *log.CommonLogger) error); ok {
		r0 = rf(bucketInfo, errMsg, logger)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UtilsIface_BucketInfoParseError_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BucketInfoParseError'
type UtilsIface_BucketInfoParseError_Call struct {
	*mock.Call
}

// BucketInfoParseError is a helper method to define mock.On call
//   - bucketInfo map[string]interface{}
//   - errMsg string
//   - logger *log.CommonLogger
func (_e *UtilsIface_Expecter) BucketInfoParseError(bucketInfo interface{}, errMsg interface{}, logger interface{}) *UtilsIface_BucketInfoParseError_Call {
	return &UtilsIface_BucketInfoParseError_Call{Call: _e.mock.On("BucketInfoParseError", bucketInfo, errMsg, logger)}
}

func (_c *UtilsIface_BucketInfoParseError_Call) Run(run func(bucketInfo map[string]interface{}, errMsg string, logger *log.CommonLogger)) *UtilsIface_BucketInfoParseError_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(map[string]interface{}), args[1].(string), args[2].(*log.CommonLogger))
	})
	return _c
}

func (_c *UtilsIface_BucketInfoParseError_Call) Return(_a0 error) *UtilsIface_BucketInfoParseError_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *UtilsIface_BucketInfoParseError_Call) RunAndReturn(run func(map[string]interface{}, string, *log.CommonLogger) error) *UtilsIface_BucketInfoParseError_Call {
	_c.Call.Return(run)
	return _c
}

// BucketNotFoundError provides a mock function with given fields: bucketName
func (_m *UtilsIface) BucketNotFoundError(bucketName string) error {
	ret := _m.Called(bucketName)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(bucketName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UtilsIface_BucketNotFoundError_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BucketNotFoundError'
type UtilsIface_BucketNotFoundError_Call struct {
	*mock.Call
}

// BucketNotFoundError is a helper method to define mock.On call
//   - bucketName string
func (_e *UtilsIface_Expecter) BucketNotFoundError(bucketName interface{}) *UtilsIface_BucketNotFoundError_Call {
	return &UtilsIface_BucketNotFoundError_Call{Call: _e.mock.On("BucketNotFoundError", bucketName)}
}

func (_c *UtilsIface_BucketNotFoundError_Call) Run(run func(bucketName string)) *UtilsIface_BucketNotFoundError_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *UtilsIface_BucketNotFoundError_Call) Return(_a0 error) *UtilsIface_BucketNotFoundError_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *UtilsIface_BucketNotFoundError_Call) RunAndReturn(run func(string) error) *UtilsIface_BucketNotFoundError_Call {
	_c.Call.Return(run)
	return _c
}

// BucketStorageBackend provides a mock function with given fields: bucketInfo
func (_m *UtilsIface) BucketStorageBackend(bucketInfo map[string]interface{}) (string, error) {
	ret := _m.Called(bucketInfo)

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(map[string]interface{}) (string, error)); ok {
		return rf(bucketInfo)
	}
	if rf, ok := ret.Get(0).(func(map[string]interface{}) string); ok {
		r0 = rf(bucketInfo)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(map[string]interface{}) error); ok {
		r1 = rf(bucketInfo)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UtilsIface_BucketStorageBackend_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BucketStorageBackend'
type UtilsIface_BucketStorageBackend_Call struct {
	*mock.Call
}

// BucketStorageBackend is a helper method to define mock.On call
//   - bucketInfo map[string]interface{}
func (_e *UtilsIface_Expecter) BucketStorageBackend(bucketInfo interface{}) *UtilsIface_BucketStorageBackend_Call {
	return &UtilsIface_BucketStorageBackend_Call{Call: _e.mock.On("BucketStorageBackend", bucketInfo)}
}

func (_c *UtilsIface_BucketStorageBackend_Call) Run(run func(bucketInfo map[string]interface{})) *UtilsIface_BucketStorageBackend_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(map[string]interface{}))
	})
	return _c
}

func (_c *UtilsIface_BucketStorageBackend_Call) Return(_a0 string, _a1 error) *UtilsIface_BucketStorageBackend_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *UtilsIface_BucketStorageBackend_Call) RunAndReturn(run func(map[string]interface{}) (string, error)) *UtilsIface_BucketStorageBackend_Call {
	_c.Call.Return(run)
	return _c
}

// BucketUUID provides a mock function with given fields: hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger
func (_m *UtilsIface) BucketUUID(hostAddr string, bucketName string, username string, password string, authMech base.HttpAuthMech, certificate []byte, sanInCertificate bool, clientCertificate []byte, clientKey []byte, logger *log.CommonLogger) (string, error) {
	ret := _m.Called(hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) (string, error)); ok {
		return rf(hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	}
	if rf, ok := ret.Get(0).(func(string, string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) string); ok {
		r0 = rf(hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string, string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) error); ok {
		r1 = rf(hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UtilsIface_BucketUUID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BucketUUID'
type UtilsIface_BucketUUID_Call struct {
	*mock.Call
}

// BucketUUID is a helper method to define mock.On call
//   - hostAddr string
//   - bucketName string
//   - username string
//   - password string
//   - authMech base.HttpAuthMech
//   - certificate []byte
//   - sanInCertificate bool
//   - clientCertificate []byte
//   - clientKey []byte
//   - logger *log.CommonLogger
func (_e *UtilsIface_Expecter) BucketUUID(hostAddr interface{}, bucketName interface{}, username interface{}, password interface{}, authMech interface{}, certificate interface{}, sanInCertificate interface{}, clientCertificate interface{}, clientKey interface{}, logger interface{}) *UtilsIface_BucketUUID_Call {
	return &UtilsIface_BucketUUID_Call{Call: _e.mock.On("BucketUUID", hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)}
}

func (_c *UtilsIface_BucketUUID_Call) Run(run func(hostAddr string, bucketName string, username string, password string, authMech base.HttpAuthMech, certificate []byte, sanInCertificate bool, clientCertificate []byte, clientKey []byte, logger *log.CommonLogger)) *UtilsIface_BucketUUID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].(string), args[3].(string), args[4].(base.HttpAuthMech), args[5].([]byte), args[6].(bool), args[7].([]byte), args[8].([]byte), args[9].(*log.CommonLogger))
	})
	return _c
}

func (_c *UtilsIface_BucketUUID_Call) Return(_a0 string, _a1 error) *UtilsIface_BucketUUID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *UtilsIface_BucketUUID_Call) RunAndReturn(run func(string, string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) (string, error)) *UtilsIface_BucketUUID_Call {
	_c.Call.Return(run)
	return _c
}

// BucketValidationInfo provides a mock function with given fields: hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger
func (_m *UtilsIface) BucketValidationInfo(hostAddr string, bucketName string, username string, password string, authMech base.HttpAuthMech, certificate []byte, sanInCertificate bool, clientCertificate []byte, clientKey []byte, logger *log.CommonLogger) (map[string]interface{}, string, string, string, string, map[string][]uint16, error) {
	ret := _m.Called(hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)

	var r0 map[string]interface{}
	var r1 string
	var r2 string
	var r3 string
	var r4 string
	var r5 map[string][]uint16
	var r6 error
	if rf, ok := ret.Get(0).(func(string, string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) (map[string]interface{}, string, string, string, string, map[string][]uint16, error)); ok {
		return rf(hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	}
	if rf, ok := ret.Get(0).(func(string, string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) map[string]interface{}); ok {
		r0 = rf(hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) string); ok {
		r1 = rf(hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(string, string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) string); ok {
		r2 = rf(hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	} else {
		r2 = ret.Get(2).(string)
	}

	if rf, ok := ret.Get(3).(func(string, string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) string); ok {
		r3 = rf(hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	} else {
		r3 = ret.Get(3).(string)
	}

	if rf, ok := ret.Get(4).(func(string, string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) string); ok {
		r4 = rf(hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	} else {
		r4 = ret.Get(4).(string)
	}

	if rf, ok := ret.Get(5).(func(string, string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) map[string][]uint16); ok {
		r5 = rf(hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	} else {
		if ret.Get(5) != nil {
			r5 = ret.Get(5).(map[string][]uint16)
		}
	}

	if rf, ok := ret.Get(6).(func(string, string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) error); ok {
		r6 = rf(hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	} else {
		r6 = ret.Error(6)
	}

	return r0, r1, r2, r3, r4, r5, r6
}

// UtilsIface_BucketValidationInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BucketValidationInfo'
type UtilsIface_BucketValidationInfo_Call struct {
	*mock.Call
}

// BucketValidationInfo is a helper method to define mock.On call
//   - hostAddr string
//   - bucketName string
//   - username string
//   - password string
//   - authMech base.HttpAuthMech
//   - certificate []byte
//   - sanInCertificate bool
//   - clientCertificate []byte
//   - clientKey []byte
//   - logger *log.CommonLogger
func (_e *UtilsIface_Expecter) BucketValidationInfo(hostAddr interface{}, bucketName interface{}, username interface{}, password interface{}, authMech interface{}, certificate interface{}, sanInCertificate interface{}, clientCertificate interface{}, clientKey interface{}, logger interface{}) *UtilsIface_BucketValidationInfo_Call {
	return &UtilsIface_BucketValidationInfo_Call{Call: _e.mock.On("BucketValidationInfo", hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)}
}

func (_c *UtilsIface_BucketValidationInfo_Call) Run(run func(hostAddr string, bucketName string, username string, password string, authMech base.HttpAuthMech, certificate []byte, sanInCertificate bool, clientCertificate []byte, clientKey []byte, logger *log.CommonLogger)) *UtilsIface_BucketValidationInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].(string), args[3].(string), args[4].(base.HttpAuthMech), args[5].([]byte), args[6].(bool), args[7].([]byte), args[8].([]byte), args[9].(*log.CommonLogger))
	})
	return _c
}

func (_c *UtilsIface_BucketValidationInfo_Call) Return(bucketInfo map[string]interface{}, bucketType string, bucketUUID string, bucketConflictResolutionType string, bucketEvictionPolicy string, bucketKVVBMap map[string][]uint16, err error) *UtilsIface_BucketValidationInfo_Call {
	_c.Call.Return(bucketInfo, bucketType, bucketUUID, bucketConflictResolutionType, bucketEvictionPolicy, bucketKVVBMap, err)
	return _c
}

func (_c *UtilsIface_BucketValidationInfo_Call) RunAndReturn(run func(string, string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) (map[string]interface{}, string, string, string, string, map[string][]uint16, error)) *UtilsIface_BucketValidationInfo_Call {
	_c.Call.Return(run)
	return _c
}

// CheckForTransactionXattrsInUprEvent provides a mock function with given fields: uprEvent, dp, slicesToBeReleased, needToFilterBody
func (_m *UtilsIface) CheckForTransactionXattrsInUprEvent(uprEvent *memcached.UprEvent, dp base.DataPool, slicesToBeReleased *[][]byte, needToFilterBody bool) (bool, []byte, int, error, string, int64, []byte) {
	ret := _m.Called(uprEvent, dp, slicesToBeReleased, needToFilterBody)

	var r0 bool
	var r1 []byte
	var r2 int
	var r3 error
	var r4 string
	var r5 int64
	var r6 []byte
	if rf, ok := ret.Get(0).(func(*memcached.UprEvent, base.DataPool, *[][]byte, bool) (bool, []byte, int, error, string, int64, []byte)); ok {
		return rf(uprEvent, dp, slicesToBeReleased, needToFilterBody)
	}
	if rf, ok := ret.Get(0).(func(*memcached.UprEvent, base.DataPool, *[][]byte, bool) bool); ok {
		r0 = rf(uprEvent, dp, slicesToBeReleased, needToFilterBody)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(*memcached.UprEvent, base.DataPool, *[][]byte, bool) []byte); ok {
		r1 = rf(uprEvent, dp, slicesToBeReleased, needToFilterBody)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]byte)
		}
	}

	if rf, ok := ret.Get(2).(func(*memcached.UprEvent, base.DataPool, *[][]byte, bool) int); ok {
		r2 = rf(uprEvent, dp, slicesToBeReleased, needToFilterBody)
	} else {
		r2 = ret.Get(2).(int)
	}

	if rf, ok := ret.Get(3).(func(*memcached.UprEvent, base.DataPool, *[][]byte, bool) error); ok {
		r3 = rf(uprEvent, dp, slicesToBeReleased, needToFilterBody)
	} else {
		r3 = ret.Error(3)
	}

	if rf, ok := ret.Get(4).(func(*memcached.UprEvent, base.DataPool, *[][]byte, bool) string); ok {
		r4 = rf(uprEvent, dp, slicesToBeReleased, needToFilterBody)
	} else {
		r4 = ret.Get(4).(string)
	}

	if rf, ok := ret.Get(5).(func(*memcached.UprEvent, base.DataPool, *[][]byte, bool) int64); ok {
		r5 = rf(uprEvent, dp, slicesToBeReleased, needToFilterBody)
	} else {
		r5 = ret.Get(5).(int64)
	}

	if rf, ok := ret.Get(6).(func(*memcached.UprEvent, base.DataPool, *[][]byte, bool) []byte); ok {
		r6 = rf(uprEvent, dp, slicesToBeReleased, needToFilterBody)
	} else {
		if ret.Get(6) != nil {
			r6 = ret.Get(6).([]byte)
		}
	}

	return r0, r1, r2, r3, r4, r5, r6
}

// UtilsIface_CheckForTransactionXattrsInUprEvent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CheckForTransactionXattrsInUprEvent'
type UtilsIface_CheckForTransactionXattrsInUprEvent_Call struct {
	*mock.Call
}

// CheckForTransactionXattrsInUprEvent is a helper method to define mock.On call
//   - uprEvent *memcached.UprEvent
//   - dp base.DataPool
//   - slicesToBeReleased *[][]byte
//   - needToFilterBody bool
func (_e *UtilsIface_Expecter) CheckForTransactionXattrsInUprEvent(uprEvent interface{}, dp interface{}, slicesToBeReleased interface{}, needToFilterBody interface{}) *UtilsIface_CheckForTransactionXattrsInUprEvent_Call {
	return &UtilsIface_CheckForTransactionXattrsInUprEvent_Call{Call: _e.mock.On("CheckForTransactionXattrsInUprEvent", uprEvent, dp, slicesToBeReleased, needToFilterBody)}
}

func (_c *UtilsIface_CheckForTransactionXattrsInUprEvent_Call) Run(run func(uprEvent *memcached.UprEvent, dp base.DataPool, slicesToBeReleased *[][]byte, needToFilterBody bool)) *UtilsIface_CheckForTransactionXattrsInUprEvent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*memcached.UprEvent), args[1].(base.DataPool), args[2].(*[][]byte), args[3].(bool))
	})
	return _c
}

func (_c *UtilsIface_CheckForTransactionXattrsInUprEvent_Call) Return(hasTxnXattrs bool, body []byte, endBodyPos int, err error, additionalErrDesc string, totalFailedCnt int64, uncompressedUprValue []byte) *UtilsIface_CheckForTransactionXattrsInUprEvent_Call {
	_c.Call.Return(hasTxnXattrs, body, endBodyPos, err, additionalErrDesc, totalFailedCnt, uncompressedUprValue)
	return _c
}

func (_c *UtilsIface_CheckForTransactionXattrsInUprEvent_Call) RunAndReturn(run func(*memcached.UprEvent, base.DataPool, *[][]byte, bool) (bool, []byte, int, error, string, int64, []byte)) *UtilsIface_CheckForTransactionXattrsInUprEvent_Call {
	_c.Call.Return(run)
	return _c
}

// ComposeHELORequest provides a mock function with given fields: userAgent, features
func (_m *UtilsIface) ComposeHELORequest(userAgent string, features utils.HELOFeatures) *gomemcached.MCRequest {
	ret := _m.Called(userAgent, features)

	var r0 *gomemcached.MCRequest
	if rf, ok := ret.Get(0).(func(string, utils.HELOFeatures) *gomemcached.MCRequest); ok {
		r0 = rf(userAgent, features)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gomemcached.MCRequest)
		}
	}

	return r0
}

// UtilsIface_ComposeHELORequest_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ComposeHELORequest'
type UtilsIface_ComposeHELORequest_Call struct {
	*mock.Call
}

// ComposeHELORequest is a helper method to define mock.On call
//   - userAgent string
//   - features utils.HELOFeatures
func (_e *UtilsIface_Expecter) ComposeHELORequest(userAgent interface{}, features interface{}) *UtilsIface_ComposeHELORequest_Call {
	return &UtilsIface_ComposeHELORequest_Call{Call: _e.mock.On("ComposeHELORequest", userAgent, features)}
}

func (_c *UtilsIface_ComposeHELORequest_Call) Run(run func(userAgent string, features utils.HELOFeatures)) *UtilsIface_ComposeHELORequest_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(utils.HELOFeatures))
	})
	return _c
}

func (_c *UtilsIface_ComposeHELORequest_Call) Return(_a0 *gomemcached.MCRequest) *UtilsIface_ComposeHELORequest_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *UtilsIface_ComposeHELORequest_Call) RunAndReturn(run func(string, utils.HELOFeatures) *gomemcached.MCRequest) *UtilsIface_ComposeHELORequest_Call {
	_c.Call.Return(run)
	return _c
}

// ConstructHttpRequest provides a mock function with given fields: baseURL, path, preservePathEncoding, username, password, authMech, userAuthMode, httpCommand, contentType, body, logger
func (_m *UtilsIface) ConstructHttpRequest(baseURL string, path string, preservePathEncoding bool, username string, password string, authMech base.HttpAuthMech, userAuthMode base.UserAuthMode, httpCommand string, contentType string, body []byte, logger *log.CommonLogger) (*http.Request, string, error) {
	ret := _m.Called(baseURL, path, preservePathEncoding, username, password, authMech, userAuthMode, httpCommand, contentType, body, logger)

	var r0 *http.Request
	var r1 string
	var r2 error
	if rf, ok := ret.Get(0).(func(string, string, bool, string, string, base.HttpAuthMech, base.UserAuthMode, string, string, []byte, *log.CommonLogger) (*http.Request, string, error)); ok {
		return rf(baseURL, path, preservePathEncoding, username, password, authMech, userAuthMode, httpCommand, contentType, body, logger)
	}
	if rf, ok := ret.Get(0).(func(string, string, bool, string, string, base.HttpAuthMech, base.UserAuthMode, string, string, []byte, *log.CommonLogger) *http.Request); ok {
		r0 = rf(baseURL, path, preservePathEncoding, username, password, authMech, userAuthMode, httpCommand, contentType, body, logger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Request)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, bool, string, string, base.HttpAuthMech, base.UserAuthMode, string, string, []byte, *log.CommonLogger) string); ok {
		r1 = rf(baseURL, path, preservePathEncoding, username, password, authMech, userAuthMode, httpCommand, contentType, body, logger)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(string, string, bool, string, string, base.HttpAuthMech, base.UserAuthMode, string, string, []byte, *log.CommonLogger) error); ok {
		r2 = rf(baseURL, path, preservePathEncoding, username, password, authMech, userAuthMode, httpCommand, contentType, body, logger)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// UtilsIface_ConstructHttpRequest_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConstructHttpRequest'
type UtilsIface_ConstructHttpRequest_Call struct {
	*mock.Call
}

// ConstructHttpRequest is a helper method to define mock.On call
//   - baseURL string
//   - path string
//   - preservePathEncoding bool
//   - username string
//   - password string
//   - authMech base.HttpAuthMech
//   - userAuthMode base.UserAuthMode
//   - httpCommand string
//   - contentType string
//   - body []byte
//   - logger *log.CommonLogger
func (_e *UtilsIface_Expecter) ConstructHttpRequest(baseURL interface{}, path interface{}, preservePathEncoding interface{}, username interface{}, password interface{}, authMech interface{}, userAuthMode interface{}, httpCommand interface{}, contentType interface{}, body interface{}, logger interface{}) *UtilsIface_ConstructHttpRequest_Call {
	return &UtilsIface_ConstructHttpRequest_Call{Call: _e.mock.On("ConstructHttpRequest", baseURL, path, preservePathEncoding, username, password, authMech, userAuthMode, httpCommand, contentType, body, logger)}
}

func (_c *UtilsIface_ConstructHttpRequest_Call) Run(run func(baseURL string, path string, preservePathEncoding bool, username string, password string, authMech base.HttpAuthMech, userAuthMode base.UserAuthMode, httpCommand string, contentType string, body []byte, logger *log.CommonLogger)) *UtilsIface_ConstructHttpRequest_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].(bool), args[3].(string), args[4].(string), args[5].(base.HttpAuthMech), args[6].(base.UserAuthMode), args[7].(string), args[8].(string), args[9].([]byte), args[10].(*log.CommonLogger))
	})
	return _c
}

func (_c *UtilsIface_ConstructHttpRequest_Call) Return(_a0 *http.Request, _a1 string, _a2 error) *UtilsIface_ConstructHttpRequest_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *UtilsIface_ConstructHttpRequest_Call) RunAndReturn(run func(string, string, bool, string, string, base.HttpAuthMech, base.UserAuthMode, string, string, []byte, *log.CommonLogger) (*http.Request, string, error)) *UtilsIface_ConstructHttpRequest_Call {
	_c.Call.Return(run)
	return _c
}

// DumpStackTraceAfterThreshold provides a mock function with given fields: id, threshold, goroutines
func (_m *UtilsIface) DumpStackTraceAfterThreshold(id string, threshold time.Duration, goroutines base.PprofLookupTypes) func() {
	ret := _m.Called(id, threshold, goroutines)

	var r0 func()
	if rf, ok := ret.Get(0).(func(string, time.Duration, base.PprofLookupTypes) func()); ok {
		r0 = rf(id, threshold, goroutines)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(func())
		}
	}

	return r0
}

// UtilsIface_DumpStackTraceAfterThreshold_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DumpStackTraceAfterThreshold'
type UtilsIface_DumpStackTraceAfterThreshold_Call struct {
	*mock.Call
}

// DumpStackTraceAfterThreshold is a helper method to define mock.On call
//   - id string
//   - threshold time.Duration
//   - goroutines base.PprofLookupTypes
func (_e *UtilsIface_Expecter) DumpStackTraceAfterThreshold(id interface{}, threshold interface{}, goroutines interface{}) *UtilsIface_DumpStackTraceAfterThreshold_Call {
	return &UtilsIface_DumpStackTraceAfterThreshold_Call{Call: _e.mock.On("DumpStackTraceAfterThreshold", id, threshold, goroutines)}
}

func (_c *UtilsIface_DumpStackTraceAfterThreshold_Call) Run(run func(id string, threshold time.Duration, goroutines base.PprofLookupTypes)) *UtilsIface_DumpStackTraceAfterThreshold_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(time.Duration), args[2].(base.PprofLookupTypes))
	})
	return _c
}

func (_c *UtilsIface_DumpStackTraceAfterThreshold_Call) Return(_a0 func()) *UtilsIface_DumpStackTraceAfterThreshold_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *UtilsIface_DumpStackTraceAfterThreshold_Call) RunAndReturn(run func(string, time.Duration, base.PprofLookupTypes) func()) *UtilsIface_DumpStackTraceAfterThreshold_Call {
	_c.Call.Return(run)
	return _c
}

// EncodeHttpRequest provides a mock function with given fields: req
func (_m *UtilsIface) EncodeHttpRequest(req *http.Request) ([]byte, error) {
	ret := _m.Called(req)

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func(*http.Request) ([]byte, error)); ok {
		return rf(req)
	}
	if rf, ok := ret.Get(0).(func(*http.Request) []byte); ok {
		r0 = rf(req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(*http.Request) error); ok {
		r1 = rf(req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UtilsIface_EncodeHttpRequest_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EncodeHttpRequest'
type UtilsIface_EncodeHttpRequest_Call struct {
	*mock.Call
}

// EncodeHttpRequest is a helper method to define mock.On call
//   - req *http.Request
func (_e *UtilsIface_Expecter) EncodeHttpRequest(req interface{}) *UtilsIface_EncodeHttpRequest_Call {
	return &UtilsIface_EncodeHttpRequest_Call{Call: _e.mock.On("EncodeHttpRequest", req)}
}

func (_c *UtilsIface_EncodeHttpRequest_Call) Run(run func(req *http.Request)) *UtilsIface_EncodeHttpRequest_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*http.Request))
	})
	return _c
}

func (_c *UtilsIface_EncodeHttpRequest_Call) Return(_a0 []byte, _a1 error) *UtilsIface_EncodeHttpRequest_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *UtilsIface_EncodeHttpRequest_Call) RunAndReturn(run func(*http.Request) ([]byte, error)) *UtilsIface_EncodeHttpRequest_Call {
	_c.Call.Return(run)
	return _c
}

// EncodeHttpRequestHeader provides a mock function with given fields: reqBytes, key, value
func (_m *UtilsIface) EncodeHttpRequestHeader(reqBytes []byte, key string, value string) []byte {
	ret := _m.Called(reqBytes, key, value)

	var r0 []byte
	if rf, ok := ret.Get(0).(func([]byte, string, string) []byte); ok {
		r0 = rf(reqBytes, key, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	return r0
}

// UtilsIface_EncodeHttpRequestHeader_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EncodeHttpRequestHeader'
type UtilsIface_EncodeHttpRequestHeader_Call struct {
	*mock.Call
}

// EncodeHttpRequestHeader is a helper method to define mock.On call
//   - reqBytes []byte
//   - key string
//   - value string
func (_e *UtilsIface_Expecter) EncodeHttpRequestHeader(reqBytes interface{}, key interface{}, value interface{}) *UtilsIface_EncodeHttpRequestHeader_Call {
	return &UtilsIface_EncodeHttpRequestHeader_Call{Call: _e.mock.On("EncodeHttpRequestHeader", reqBytes, key, value)}
}

func (_c *UtilsIface_EncodeHttpRequestHeader_Call) Run(run func(reqBytes []byte, key string, value string)) *UtilsIface_EncodeHttpRequestHeader_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]byte), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *UtilsIface_EncodeHttpRequestHeader_Call) Return(_a0 []byte) *UtilsIface_EncodeHttpRequestHeader_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *UtilsIface_EncodeHttpRequestHeader_Call) RunAndReturn(run func([]byte, string, string) []byte) *UtilsIface_EncodeHttpRequestHeader_Call {
	_c.Call.Return(run)
	return _c
}

// EncodeMapIntoByteArray provides a mock function with given fields: data
func (_m *UtilsIface) EncodeMapIntoByteArray(data map[string]interface{}) ([]byte, error) {
	ret := _m.Called(data)

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func(map[string]interface{}) ([]byte, error)); ok {
		return rf(data)
	}
	if rf, ok := ret.Get(0).(func(map[string]interface{}) []byte); ok {
		r0 = rf(data)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(map[string]interface{}) error); ok {
		r1 = rf(data)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UtilsIface_EncodeMapIntoByteArray_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EncodeMapIntoByteArray'
type UtilsIface_EncodeMapIntoByteArray_Call struct {
	*mock.Call
}

// EncodeMapIntoByteArray is a helper method to define mock.On call
//   - data map[string]interface{}
func (_e *UtilsIface_Expecter) EncodeMapIntoByteArray(data interface{}) *UtilsIface_EncodeMapIntoByteArray_Call {
	return &UtilsIface_EncodeMapIntoByteArray_Call{Call: _e.mock.On("EncodeMapIntoByteArray", data)}
}

func (_c *UtilsIface_EncodeMapIntoByteArray_Call) Run(run func(data map[string]interface{})) *UtilsIface_EncodeMapIntoByteArray_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(map[string]interface{}))
	})
	return _c
}

func (_c *UtilsIface_EncodeMapIntoByteArray_Call) Return(_a0 []byte, _a1 error) *UtilsIface_EncodeMapIntoByteArray_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *UtilsIface_EncodeMapIntoByteArray_Call) RunAndReturn(run func(map[string]interface{}) ([]byte, error)) *UtilsIface_EncodeMapIntoByteArray_Call {
	_c.Call.Return(run)
	return _c
}

// EnforcePrefix provides a mock function with given fields: prefix, str
func (_m *UtilsIface) EnforcePrefix(prefix string, str string) string {
	ret := _m.Called(prefix, str)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, string) string); ok {
		r0 = rf(prefix, str)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// UtilsIface_EnforcePrefix_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EnforcePrefix'
type UtilsIface_EnforcePrefix_Call struct {
	*mock.Call
}

// EnforcePrefix is a helper method to define mock.On call
//   - prefix string
//   - str string
func (_e *UtilsIface_Expecter) EnforcePrefix(prefix interface{}, str interface{}) *UtilsIface_EnforcePrefix_Call {
	return &UtilsIface_EnforcePrefix_Call{Call: _e.mock.On("EnforcePrefix", prefix, str)}
}

func (_c *UtilsIface_EnforcePrefix_Call) Run(run func(prefix string, str string)) *UtilsIface_EnforcePrefix_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *UtilsIface_EnforcePrefix_Call) Return(_a0 string) *UtilsIface_EnforcePrefix_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *UtilsIface_EnforcePrefix_Call) RunAndReturn(run func(string, string) string) *UtilsIface_EnforcePrefix_Call {
	_c.Call.Return(run)
	return _c
}

// ExponentialBackoffExecutor provides a mock function with given fields: name, initialWait, maxRetries, factor, op
func (_m *UtilsIface) ExponentialBackoffExecutor(name string, initialWait time.Duration, maxRetries int, factor int, op utils.ExponentialOpFunc) error {
	ret := _m.Called(name, initialWait, maxRetries, factor, op)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, time.Duration, int, int, utils.ExponentialOpFunc) error); ok {
		r0 = rf(name, initialWait, maxRetries, factor, op)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UtilsIface_ExponentialBackoffExecutor_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExponentialBackoffExecutor'
type UtilsIface_ExponentialBackoffExecutor_Call struct {
	*mock.Call
}

// ExponentialBackoffExecutor is a helper method to define mock.On call
//   - name string
//   - initialWait time.Duration
//   - maxRetries int
//   - factor int
//   - op utils.ExponentialOpFunc
func (_e *UtilsIface_Expecter) ExponentialBackoffExecutor(name interface{}, initialWait interface{}, maxRetries interface{}, factor interface{}, op interface{}) *UtilsIface_ExponentialBackoffExecutor_Call {
	return &UtilsIface_ExponentialBackoffExecutor_Call{Call: _e.mock.On("ExponentialBackoffExecutor", name, initialWait, maxRetries, factor, op)}
}

func (_c *UtilsIface_ExponentialBackoffExecutor_Call) Run(run func(name string, initialWait time.Duration, maxRetries int, factor int, op utils.ExponentialOpFunc)) *UtilsIface_ExponentialBackoffExecutor_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(time.Duration), args[2].(int), args[3].(int), args[4].(utils.ExponentialOpFunc))
	})
	return _c
}

func (_c *UtilsIface_ExponentialBackoffExecutor_Call) Return(_a0 error) *UtilsIface_ExponentialBackoffExecutor_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *UtilsIface_ExponentialBackoffExecutor_Call) RunAndReturn(run func(string, time.Duration, int, int, utils.ExponentialOpFunc) error) *UtilsIface_ExponentialBackoffExecutor_Call {
	_c.Call.Return(run)
	return _c
}

// ExponentialBackoffExecutorWithFinishSignal provides a mock function with given fields: name, initialWait, maxRetries, factor, op, param, finCh
func (_m *UtilsIface) ExponentialBackoffExecutorWithFinishSignal(name string, initialWait time.Duration, maxRetries int, factor int, op utils.ExponentialOpFunc2, param interface{}, finCh chan bool) (interface{}, error) {
	ret := _m.Called(name, initialWait, maxRetries, factor, op, param, finCh)

	var r0 interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(string, time.Duration, int, int, utils.ExponentialOpFunc2, interface{}, chan bool) (interface{}, error)); ok {
		return rf(name, initialWait, maxRetries, factor, op, param, finCh)
	}
	if rf, ok := ret.Get(0).(func(string, time.Duration, int, int, utils.ExponentialOpFunc2, interface{}, chan bool) interface{}); ok {
		r0 = rf(name, initialWait, maxRetries, factor, op, param, finCh)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(string, time.Duration, int, int, utils.ExponentialOpFunc2, interface{}, chan bool) error); ok {
		r1 = rf(name, initialWait, maxRetries, factor, op, param, finCh)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UtilsIface_ExponentialBackoffExecutorWithFinishSignal_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExponentialBackoffExecutorWithFinishSignal'
type UtilsIface_ExponentialBackoffExecutorWithFinishSignal_Call struct {
	*mock.Call
}

// ExponentialBackoffExecutorWithFinishSignal is a helper method to define mock.On call
//   - name string
//   - initialWait time.Duration
//   - maxRetries int
//   - factor int
//   - op utils.ExponentialOpFunc2
//   - param interface{}
//   - finCh chan bool
func (_e *UtilsIface_Expecter) ExponentialBackoffExecutorWithFinishSignal(name interface{}, initialWait interface{}, maxRetries interface{}, factor interface{}, op interface{}, param interface{}, finCh interface{}) *UtilsIface_ExponentialBackoffExecutorWithFinishSignal_Call {
	return &UtilsIface_ExponentialBackoffExecutorWithFinishSignal_Call{Call: _e.mock.On("ExponentialBackoffExecutorWithFinishSignal", name, initialWait, maxRetries, factor, op, param, finCh)}
}

func (_c *UtilsIface_ExponentialBackoffExecutorWithFinishSignal_Call) Run(run func(name string, initialWait time.Duration, maxRetries int, factor int, op utils.ExponentialOpFunc2, param interface{}, finCh chan bool)) *UtilsIface_ExponentialBackoffExecutorWithFinishSignal_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(time.Duration), args[2].(int), args[3].(int), args[4].(utils.ExponentialOpFunc2), args[5].(interface{}), args[6].(chan bool))
	})
	return _c
}

func (_c *UtilsIface_ExponentialBackoffExecutorWithFinishSignal_Call) Return(_a0 interface{}, _a1 error) *UtilsIface_ExponentialBackoffExecutorWithFinishSignal_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *UtilsIface_ExponentialBackoffExecutorWithFinishSignal_Call) RunAndReturn(run func(string, time.Duration, int, int, utils.ExponentialOpFunc2, interface{}, chan bool) (interface{}, error)) *UtilsIface_ExponentialBackoffExecutorWithFinishSignal_Call {
	_c.Call.Return(run)
	return _c
}

// ExponentialBackoffExecutorWithOriginalError provides a mock function with given fields: name, initialWait, maxRetries, factor, op
func (_m *UtilsIface) ExponentialBackoffExecutorWithOriginalError(name string, initialWait time.Duration, maxRetries int, factor int, op utils.ExponentialOpFunc) error {
	ret := _m.Called(name, initialWait, maxRetries, factor, op)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, time.Duration, int, int, utils.ExponentialOpFunc) error); ok {
		r0 = rf(name, initialWait, maxRetries, factor, op)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UtilsIface_ExponentialBackoffExecutorWithOriginalError_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExponentialBackoffExecutorWithOriginalError'
type UtilsIface_ExponentialBackoffExecutorWithOriginalError_Call struct {
	*mock.Call
}

// ExponentialBackoffExecutorWithOriginalError is a helper method to define mock.On call
//   - name string
//   - initialWait time.Duration
//   - maxRetries int
//   - factor int
//   - op utils.ExponentialOpFunc
func (_e *UtilsIface_Expecter) ExponentialBackoffExecutorWithOriginalError(name interface{}, initialWait interface{}, maxRetries interface{}, factor interface{}, op interface{}) *UtilsIface_ExponentialBackoffExecutorWithOriginalError_Call {
	return &UtilsIface_ExponentialBackoffExecutorWithOriginalError_Call{Call: _e.mock.On("ExponentialBackoffExecutorWithOriginalError", name, initialWait, maxRetries, factor, op)}
}

func (_c *UtilsIface_ExponentialBackoffExecutorWithOriginalError_Call) Run(run func(name string, initialWait time.Duration, maxRetries int, factor int, op utils.ExponentialOpFunc)) *UtilsIface_ExponentialBackoffExecutorWithOriginalError_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(time.Duration), args[2].(int), args[3].(int), args[4].(utils.ExponentialOpFunc))
	})
	return _c
}

func (_c *UtilsIface_ExponentialBackoffExecutorWithOriginalError_Call) Return(err error) *UtilsIface_ExponentialBackoffExecutorWithOriginalError_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *UtilsIface_ExponentialBackoffExecutorWithOriginalError_Call) RunAndReturn(run func(string, time.Duration, int, int, utils.ExponentialOpFunc) error) *UtilsIface_ExponentialBackoffExecutorWithOriginalError_Call {
	_c.Call.Return(run)
	return _c
}

// FilterExpressionMatchesDoc provides a mock function with given fields: expression, docId, bucketName, collectionNs, addr, port
func (_m *UtilsIface) FilterExpressionMatchesDoc(expression string, docId string, bucketName string, collectionNs *base.CollectionNamespace, addr string, port uint16) (bool, error) {
	ret := _m.Called(expression, docId, bucketName, collectionNs, addr, port)

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, string, *base.CollectionNamespace, string, uint16) (bool, error)); ok {
		return rf(expression, docId, bucketName, collectionNs, addr, port)
	}
	if rf, ok := ret.Get(0).(func(string, string, string, *base.CollectionNamespace, string, uint16) bool); ok {
		r0 = rf(expression, docId, bucketName, collectionNs, addr, port)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, string, string, *base.CollectionNamespace, string, uint16) error); ok {
		r1 = rf(expression, docId, bucketName, collectionNs, addr, port)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UtilsIface_FilterExpressionMatchesDoc_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FilterExpressionMatchesDoc'
type UtilsIface_FilterExpressionMatchesDoc_Call struct {
	*mock.Call
}

// FilterExpressionMatchesDoc is a helper method to define mock.On call
//   - expression string
//   - docId string
//   - bucketName string
//   - collectionNs *base.CollectionNamespace
//   - addr string
//   - port uint16
func (_e *UtilsIface_Expecter) FilterExpressionMatchesDoc(expression interface{}, docId interface{}, bucketName interface{}, collectionNs interface{}, addr interface{}, port interface{}) *UtilsIface_FilterExpressionMatchesDoc_Call {
	return &UtilsIface_FilterExpressionMatchesDoc_Call{Call: _e.mock.On("FilterExpressionMatchesDoc", expression, docId, bucketName, collectionNs, addr, port)}
}

func (_c *UtilsIface_FilterExpressionMatchesDoc_Call) Run(run func(expression string, docId string, bucketName string, collectionNs *base.CollectionNamespace, addr string, port uint16)) *UtilsIface_FilterExpressionMatchesDoc_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].(string), args[3].(*base.CollectionNamespace), args[4].(string), args[5].(uint16))
	})
	return _c
}

func (_c *UtilsIface_FilterExpressionMatchesDoc_Call) Return(result bool, err error) *UtilsIface_FilterExpressionMatchesDoc_Call {
	_c.Call.Return(result, err)
	return _c
}

func (_c *UtilsIface_FilterExpressionMatchesDoc_Call) RunAndReturn(run func(string, string, string, *base.CollectionNamespace, string, uint16) (bool, error)) *UtilsIface_FilterExpressionMatchesDoc_Call {
	_c.Call.Return(run)
	return _c
}

// GetAuthMode provides a mock function with given fields: username, clientCertificate, path, authMech
func (_m *UtilsIface) GetAuthMode(username string, clientCertificate []byte, path string, authMech base.HttpAuthMech) base.UserAuthMode {
	ret := _m.Called(username, clientCertificate, path, authMech)

	var r0 base.UserAuthMode
	if rf, ok := ret.Get(0).(func(string, []byte, string, base.HttpAuthMech) base.UserAuthMode); ok {
		r0 = rf(username, clientCertificate, path, authMech)
	} else {
		r0 = ret.Get(0).(base.UserAuthMode)
	}

	return r0
}

// UtilsIface_GetAuthMode_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAuthMode'
type UtilsIface_GetAuthMode_Call struct {
	*mock.Call
}

// GetAuthMode is a helper method to define mock.On call
//   - username string
//   - clientCertificate []byte
//   - path string
//   - authMech base.HttpAuthMech
func (_e *UtilsIface_Expecter) GetAuthMode(username interface{}, clientCertificate interface{}, path interface{}, authMech interface{}) *UtilsIface_GetAuthMode_Call {
	return &UtilsIface_GetAuthMode_Call{Call: _e.mock.On("GetAuthMode", username, clientCertificate, path, authMech)}
}

func (_c *UtilsIface_GetAuthMode_Call) Run(run func(username string, clientCertificate []byte, path string, authMech base.HttpAuthMech)) *UtilsIface_GetAuthMode_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].([]byte), args[2].(string), args[3].(base.HttpAuthMech))
	})
	return _c
}

func (_c *UtilsIface_GetAuthMode_Call) Return(_a0 base.UserAuthMode) *UtilsIface_GetAuthMode_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *UtilsIface_GetAuthMode_Call) RunAndReturn(run func(string, []byte, string, base.HttpAuthMech) base.UserAuthMode) *UtilsIface_GetAuthMode_Call {
	_c.Call.Return(run)
	return _c
}

// GetBucketInfo provides a mock function with given fields: hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger
func (_m *UtilsIface) GetBucketInfo(hostAddr string, bucketName string, username string, password string, authMech base.HttpAuthMech, certificate []byte, sanInCertificate bool, clientCertificate []byte, clientKey []byte, logger *log.CommonLogger) (map[string]interface{}, error) {
	ret := _m.Called(hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)

	var r0 map[string]interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) (map[string]interface{}, error)); ok {
		return rf(hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	}
	if rf, ok := ret.Get(0).(func(string, string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) map[string]interface{}); ok {
		r0 = rf(hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) error); ok {
		r1 = rf(hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UtilsIface_GetBucketInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBucketInfo'
type UtilsIface_GetBucketInfo_Call struct {
	*mock.Call
}

// GetBucketInfo is a helper method to define mock.On call
//   - hostAddr string
//   - bucketName string
//   - username string
//   - password string
//   - authMech base.HttpAuthMech
//   - certificate []byte
//   - sanInCertificate bool
//   - clientCertificate []byte
//   - clientKey []byte
//   - logger *log.CommonLogger
func (_e *UtilsIface_Expecter) GetBucketInfo(hostAddr interface{}, bucketName interface{}, username interface{}, password interface{}, authMech interface{}, certificate interface{}, sanInCertificate interface{}, clientCertificate interface{}, clientKey interface{}, logger interface{}) *UtilsIface_GetBucketInfo_Call {
	return &UtilsIface_GetBucketInfo_Call{Call: _e.mock.On("GetBucketInfo", hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)}
}

func (_c *UtilsIface_GetBucketInfo_Call) Run(run func(hostAddr string, bucketName string, username string, password string, authMech base.HttpAuthMech, certificate []byte, sanInCertificate bool, clientCertificate []byte, clientKey []byte, logger *log.CommonLogger)) *UtilsIface_GetBucketInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].(string), args[3].(string), args[4].(base.HttpAuthMech), args[5].([]byte), args[6].(bool), args[7].([]byte), args[8].([]byte), args[9].(*log.CommonLogger))
	})
	return _c
}

func (_c *UtilsIface_GetBucketInfo_Call) Return(_a0 map[string]interface{}, _a1 error) *UtilsIface_GetBucketInfo_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *UtilsIface_GetBucketInfo_Call) RunAndReturn(run func(string, string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) (map[string]interface{}, error)) *UtilsIface_GetBucketInfo_Call {
	_c.Call.Return(run)
	return _c
}

// GetBucketRecreatedError provides a mock function with given fields:
func (_m *UtilsIface) GetBucketRecreatedError() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UtilsIface_GetBucketRecreatedError_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBucketRecreatedError'
type UtilsIface_GetBucketRecreatedError_Call struct {
	*mock.Call
}

// GetBucketRecreatedError is a helper method to define mock.On call
func (_e *UtilsIface_Expecter) GetBucketRecreatedError() *UtilsIface_GetBucketRecreatedError_Call {
	return &UtilsIface_GetBucketRecreatedError_Call{Call: _e.mock.On("GetBucketRecreatedError")}
}

func (_c *UtilsIface_GetBucketRecreatedError_Call) Run(run func()) *UtilsIface_GetBucketRecreatedError_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *UtilsIface_GetBucketRecreatedError_Call) Return(_a0 error) *UtilsIface_GetBucketRecreatedError_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *UtilsIface_GetBucketRecreatedError_Call) RunAndReturn(run func() error) *UtilsIface_GetBucketRecreatedError_Call {
	_c.Call.Return(run)
	return _c
}

// GetBucketTypeFromBucketInfo provides a mock function with given fields: bucketName, bucketInfo
func (_m *UtilsIface) GetBucketTypeFromBucketInfo(bucketName string, bucketInfo map[string]interface{}) (string, error) {
	ret := _m.Called(bucketName, bucketInfo)

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(string, map[string]interface{}) (string, error)); ok {
		return rf(bucketName, bucketInfo)
	}
	if rf, ok := ret.Get(0).(func(string, map[string]interface{}) string); ok {
		r0 = rf(bucketName, bucketInfo)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string, map[string]interface{}) error); ok {
		r1 = rf(bucketName, bucketInfo)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UtilsIface_GetBucketTypeFromBucketInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBucketTypeFromBucketInfo'
type UtilsIface_GetBucketTypeFromBucketInfo_Call struct {
	*mock.Call
}

// GetBucketTypeFromBucketInfo is a helper method to define mock.On call
//   - bucketName string
//   - bucketInfo map[string]interface{}
func (_e *UtilsIface_Expecter) GetBucketTypeFromBucketInfo(bucketName interface{}, bucketInfo interface{}) *UtilsIface_GetBucketTypeFromBucketInfo_Call {
	return &UtilsIface_GetBucketTypeFromBucketInfo_Call{Call: _e.mock.On("GetBucketTypeFromBucketInfo", bucketName, bucketInfo)}
}

func (_c *UtilsIface_GetBucketTypeFromBucketInfo_Call) Run(run func(bucketName string, bucketInfo map[string]interface{})) *UtilsIface_GetBucketTypeFromBucketInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(map[string]interface{}))
	})
	return _c
}

func (_c *UtilsIface_GetBucketTypeFromBucketInfo_Call) Return(_a0 string, _a1 error) *UtilsIface_GetBucketTypeFromBucketInfo_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *UtilsIface_GetBucketTypeFromBucketInfo_Call) RunAndReturn(run func(string, map[string]interface{}) (string, error)) *UtilsIface_GetBucketTypeFromBucketInfo_Call {
	_c.Call.Return(run)
	return _c
}

// GetBucketUuidFromBucketInfo provides a mock function with given fields: bucketName, bucketInfo, logger
func (_m *UtilsIface) GetBucketUuidFromBucketInfo(bucketName string, bucketInfo map[string]interface{}, logger *log.CommonLogger) (string, error) {
	ret := _m.Called(bucketName, bucketInfo, logger)

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(string, map[string]interface{}, *log.CommonLogger) (string, error)); ok {
		return rf(bucketName, bucketInfo, logger)
	}
	if rf, ok := ret.Get(0).(func(string, map[string]interface{}, *log.CommonLogger) string); ok {
		r0 = rf(bucketName, bucketInfo, logger)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string, map[string]interface{}, *log.CommonLogger) error); ok {
		r1 = rf(bucketName, bucketInfo, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UtilsIface_GetBucketUuidFromBucketInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBucketUuidFromBucketInfo'
type UtilsIface_GetBucketUuidFromBucketInfo_Call struct {
	*mock.Call
}

// GetBucketUuidFromBucketInfo is a helper method to define mock.On call
//   - bucketName string
//   - bucketInfo map[string]interface{}
//   - logger *log.CommonLogger
func (_e *UtilsIface_Expecter) GetBucketUuidFromBucketInfo(bucketName interface{}, bucketInfo interface{}, logger interface{}) *UtilsIface_GetBucketUuidFromBucketInfo_Call {
	return &UtilsIface_GetBucketUuidFromBucketInfo_Call{Call: _e.mock.On("GetBucketUuidFromBucketInfo", bucketName, bucketInfo, logger)}
}

func (_c *UtilsIface_GetBucketUuidFromBucketInfo_Call) Run(run func(bucketName string, bucketInfo map[string]interface{}, logger *log.CommonLogger)) *UtilsIface_GetBucketUuidFromBucketInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(map[string]interface{}), args[2].(*log.CommonLogger))
	})
	return _c
}

func (_c *UtilsIface_GetBucketUuidFromBucketInfo_Call) Return(_a0 string, _a1 error) *UtilsIface_GetBucketUuidFromBucketInfo_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *UtilsIface_GetBucketUuidFromBucketInfo_Call) RunAndReturn(run func(string, map[string]interface{}, *log.CommonLogger) (string, error)) *UtilsIface_GetBucketUuidFromBucketInfo_Call {
	_c.Call.Return(run)
	return _c
}

// GetBuckets provides a mock function with given fields: hostAddr, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger
func (_m *UtilsIface) GetBuckets(hostAddr string, username string, password string, authMech base.HttpAuthMech, certificate []byte, sanInCertificate bool, clientCertificate []byte, clientKey []byte, logger *log.CommonLogger) (map[string]string, error) {
	ret := _m.Called(hostAddr, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)

	var r0 map[string]string
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) (map[string]string, error)); ok {
		return rf(hostAddr, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	}
	if rf, ok := ret.Get(0).(func(string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) map[string]string); ok {
		r0 = rf(hostAddr, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]string)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) error); ok {
		r1 = rf(hostAddr, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UtilsIface_GetBuckets_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBuckets'
type UtilsIface_GetBuckets_Call struct {
	*mock.Call
}

// GetBuckets is a helper method to define mock.On call
//   - hostAddr string
//   - username string
//   - password string
//   - authMech base.HttpAuthMech
//   - certificate []byte
//   - sanInCertificate bool
//   - clientCertificate []byte
//   - clientKey []byte
//   - logger *log.CommonLogger
func (_e *UtilsIface_Expecter) GetBuckets(hostAddr interface{}, username interface{}, password interface{}, authMech interface{}, certificate interface{}, sanInCertificate interface{}, clientCertificate interface{}, clientKey interface{}, logger interface{}) *UtilsIface_GetBuckets_Call {
	return &UtilsIface_GetBuckets_Call{Call: _e.mock.On("GetBuckets", hostAddr, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)}
}

func (_c *UtilsIface_GetBuckets_Call) Run(run func(hostAddr string, username string, password string, authMech base.HttpAuthMech, certificate []byte, sanInCertificate bool, clientCertificate []byte, clientKey []byte, logger *log.CommonLogger)) *UtilsIface_GetBuckets_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].(string), args[3].(base.HttpAuthMech), args[4].([]byte), args[5].(bool), args[6].([]byte), args[7].([]byte), args[8].(*log.CommonLogger))
	})
	return _c
}

func (_c *UtilsIface_GetBuckets_Call) Return(_a0 map[string]string, _a1 error) *UtilsIface_GetBuckets_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *UtilsIface_GetBuckets_Call) RunAndReturn(run func(string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) (map[string]string, error)) *UtilsIface_GetBuckets_Call {
	_c.Call.Return(run)
	return _c
}

// GetClusterCompatibilityFromBucketInfo provides a mock function with given fields: bucketInfo, logger
func (_m *UtilsIface) GetClusterCompatibilityFromBucketInfo(bucketInfo map[string]interface{}, logger *log.CommonLogger) (int, error) {
	ret := _m.Called(bucketInfo, logger)

	var r0 int
	var r1 error
	if rf, ok := ret.Get(0).(func(map[string]interface{}, *log.CommonLogger) (int, error)); ok {
		return rf(bucketInfo, logger)
	}
	if rf, ok := ret.Get(0).(func(map[string]interface{}, *log.CommonLogger) int); ok {
		r0 = rf(bucketInfo, logger)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func(map[string]interface{}, *log.CommonLogger) error); ok {
		r1 = rf(bucketInfo, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UtilsIface_GetClusterCompatibilityFromBucketInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetClusterCompatibilityFromBucketInfo'
type UtilsIface_GetClusterCompatibilityFromBucketInfo_Call struct {
	*mock.Call
}

// GetClusterCompatibilityFromBucketInfo is a helper method to define mock.On call
//   - bucketInfo map[string]interface{}
//   - logger *log.CommonLogger
func (_e *UtilsIface_Expecter) GetClusterCompatibilityFromBucketInfo(bucketInfo interface{}, logger interface{}) *UtilsIface_GetClusterCompatibilityFromBucketInfo_Call {
	return &UtilsIface_GetClusterCompatibilityFromBucketInfo_Call{Call: _e.mock.On("GetClusterCompatibilityFromBucketInfo", bucketInfo, logger)}
}

func (_c *UtilsIface_GetClusterCompatibilityFromBucketInfo_Call) Run(run func(bucketInfo map[string]interface{}, logger *log.CommonLogger)) *UtilsIface_GetClusterCompatibilityFromBucketInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(map[string]interface{}), args[1].(*log.CommonLogger))
	})
	return _c
}

func (_c *UtilsIface_GetClusterCompatibilityFromBucketInfo_Call) Return(_a0 int, _a1 error) *UtilsIface_GetClusterCompatibilityFromBucketInfo_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *UtilsIface_GetClusterCompatibilityFromBucketInfo_Call) RunAndReturn(run func(map[string]interface{}, *log.CommonLogger) (int, error)) *UtilsIface_GetClusterCompatibilityFromBucketInfo_Call {
	_c.Call.Return(run)
	return _c
}

// GetClusterCompatibilityFromNodeList provides a mock function with given fields: nodeList
func (_m *UtilsIface) GetClusterCompatibilityFromNodeList(nodeList []interface{}) (int, error) {
	ret := _m.Called(nodeList)

	var r0 int
	var r1 error
	if rf, ok := ret.Get(0).(func([]interface{}) (int, error)); ok {
		return rf(nodeList)
	}
	if rf, ok := ret.Get(0).(func([]interface{}) int); ok {
		r0 = rf(nodeList)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func([]interface{}) error); ok {
		r1 = rf(nodeList)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UtilsIface_GetClusterCompatibilityFromNodeList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetClusterCompatibilityFromNodeList'
type UtilsIface_GetClusterCompatibilityFromNodeList_Call struct {
	*mock.Call
}

// GetClusterCompatibilityFromNodeList is a helper method to define mock.On call
//   - nodeList []interface{}
func (_e *UtilsIface_Expecter) GetClusterCompatibilityFromNodeList(nodeList interface{}) *UtilsIface_GetClusterCompatibilityFromNodeList_Call {
	return &UtilsIface_GetClusterCompatibilityFromNodeList_Call{Call: _e.mock.On("GetClusterCompatibilityFromNodeList", nodeList)}
}

func (_c *UtilsIface_GetClusterCompatibilityFromNodeList_Call) Run(run func(nodeList []interface{})) *UtilsIface_GetClusterCompatibilityFromNodeList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]interface{}))
	})
	return _c
}

func (_c *UtilsIface_GetClusterCompatibilityFromNodeList_Call) Return(_a0 int, _a1 error) *UtilsIface_GetClusterCompatibilityFromNodeList_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *UtilsIface_GetClusterCompatibilityFromNodeList_Call) RunAndReturn(run func([]interface{}) (int, error)) *UtilsIface_GetClusterCompatibilityFromNodeList_Call {
	_c.Call.Return(run)
	return _c
}

// GetClusterHeartbeatStatusFromNodeList provides a mock function with given fields: nodeList
func (_m *UtilsIface) GetClusterHeartbeatStatusFromNodeList(nodeList []interface{}) (map[string]base.HeartbeatStatus, error) {
	ret := _m.Called(nodeList)

	var r0 map[string]base.HeartbeatStatus
	var r1 error
	if rf, ok := ret.Get(0).(func([]interface{}) (map[string]base.HeartbeatStatus, error)); ok {
		return rf(nodeList)
	}
	if rf, ok := ret.Get(0).(func([]interface{}) map[string]base.HeartbeatStatus); ok {
		r0 = rf(nodeList)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]base.HeartbeatStatus)
		}
	}

	if rf, ok := ret.Get(1).(func([]interface{}) error); ok {
		r1 = rf(nodeList)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UtilsIface_GetClusterHeartbeatStatusFromNodeList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetClusterHeartbeatStatusFromNodeList'
type UtilsIface_GetClusterHeartbeatStatusFromNodeList_Call struct {
	*mock.Call
}

// GetClusterHeartbeatStatusFromNodeList is a helper method to define mock.On call
//   - nodeList []interface{}
func (_e *UtilsIface_Expecter) GetClusterHeartbeatStatusFromNodeList(nodeList interface{}) *UtilsIface_GetClusterHeartbeatStatusFromNodeList_Call {
	return &UtilsIface_GetClusterHeartbeatStatusFromNodeList_Call{Call: _e.mock.On("GetClusterHeartbeatStatusFromNodeList", nodeList)}
}

func (_c *UtilsIface_GetClusterHeartbeatStatusFromNodeList_Call) Run(run func(nodeList []interface{})) *UtilsIface_GetClusterHeartbeatStatusFromNodeList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]interface{}))
	})
	return _c
}

func (_c *UtilsIface_GetClusterHeartbeatStatusFromNodeList_Call) Return(_a0 map[string]base.HeartbeatStatus, _a1 error) *UtilsIface_GetClusterHeartbeatStatusFromNodeList_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *UtilsIface_GetClusterHeartbeatStatusFromNodeList_Call) RunAndReturn(run func([]interface{}) (map[string]base.HeartbeatStatus, error)) *UtilsIface_GetClusterHeartbeatStatusFromNodeList_Call {
	_c.Call.Return(run)
	return _c
}

// GetClusterInfo provides a mock function with given fields: hostAddr, path, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger
func (_m *UtilsIface) GetClusterInfo(hostAddr string, path string, username string, password string, authMech base.HttpAuthMech, certificate []byte, sanInCertificate bool, clientCertificate []byte, clientKey []byte, logger *log.CommonLogger) (map[string]interface{}, error) {
	ret := _m.Called(hostAddr, path, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)

	var r0 map[string]interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) (map[string]interface{}, error)); ok {
		return rf(hostAddr, path, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	}
	if rf, ok := ret.Get(0).(func(string, string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) map[string]interface{}); ok {
		r0 = rf(hostAddr, path, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) error); ok {
		r1 = rf(hostAddr, path, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UtilsIface_GetClusterInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetClusterInfo'
type UtilsIface_GetClusterInfo_Call struct {
	*mock.Call
}

// GetClusterInfo is a helper method to define mock.On call
//   - hostAddr string
//   - path string
//   - username string
//   - password string
//   - authMech base.HttpAuthMech
//   - certificate []byte
//   - sanInCertificate bool
//   - clientCertificate []byte
//   - clientKey []byte
//   - logger *log.CommonLogger
func (_e *UtilsIface_Expecter) GetClusterInfo(hostAddr interface{}, path interface{}, username interface{}, password interface{}, authMech interface{}, certificate interface{}, sanInCertificate interface{}, clientCertificate interface{}, clientKey interface{}, logger interface{}) *UtilsIface_GetClusterInfo_Call {
	return &UtilsIface_GetClusterInfo_Call{Call: _e.mock.On("GetClusterInfo", hostAddr, path, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)}
}

func (_c *UtilsIface_GetClusterInfo_Call) Run(run func(hostAddr string, path string, username string, password string, authMech base.HttpAuthMech, certificate []byte, sanInCertificate bool, clientCertificate []byte, clientKey []byte, logger *log.CommonLogger)) *UtilsIface_GetClusterInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].(string), args[3].(string), args[4].(base.HttpAuthMech), args[5].([]byte), args[6].(bool), args[7].([]byte), args[8].([]byte), args[9].(*log.CommonLogger))
	})
	return _c
}

func (_c *UtilsIface_GetClusterInfo_Call) Return(_a0 map[string]interface{}, _a1 error) *UtilsIface_GetClusterInfo_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *UtilsIface_GetClusterInfo_Call) RunAndReturn(run func(string, string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) (map[string]interface{}, error)) *UtilsIface_GetClusterInfo_Call {
	_c.Call.Return(run)
	return _c
}

// GetClusterInfoWStatusCode provides a mock function with given fields: hostAddr, path, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger
func (_m *UtilsIface) GetClusterInfoWStatusCode(hostAddr string, path string, username string, password string, authMech base.HttpAuthMech, certificate []byte, sanInCertificate bool, clientCertificate []byte, clientKey []byte, logger *log.CommonLogger) (map[string]interface{}, error, int) {
	ret := _m.Called(hostAddr, path, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)

	var r0 map[string]interface{}
	var r1 error
	var r2 int
	if rf, ok := ret.Get(0).(func(string, string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) (map[string]interface{}, error, int)); ok {
		return rf(hostAddr, path, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	}
	if rf, ok := ret.Get(0).(func(string, string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) map[string]interface{}); ok {
		r0 = rf(hostAddr, path, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) error); ok {
		r1 = rf(hostAddr, path, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	} else {
		r1 = ret.Error(1)
	}

	if rf, ok := ret.Get(2).(func(string, string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) int); ok {
		r2 = rf(hostAddr, path, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	} else {
		r2 = ret.Get(2).(int)
	}

	return r0, r1, r2
}

// UtilsIface_GetClusterInfoWStatusCode_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetClusterInfoWStatusCode'
type UtilsIface_GetClusterInfoWStatusCode_Call struct {
	*mock.Call
}

// GetClusterInfoWStatusCode is a helper method to define mock.On call
//   - hostAddr string
//   - path string
//   - username string
//   - password string
//   - authMech base.HttpAuthMech
//   - certificate []byte
//   - sanInCertificate bool
//   - clientCertificate []byte
//   - clientKey []byte
//   - logger *log.CommonLogger
func (_e *UtilsIface_Expecter) GetClusterInfoWStatusCode(hostAddr interface{}, path interface{}, username interface{}, password interface{}, authMech interface{}, certificate interface{}, sanInCertificate interface{}, clientCertificate interface{}, clientKey interface{}, logger interface{}) *UtilsIface_GetClusterInfoWStatusCode_Call {
	return &UtilsIface_GetClusterInfoWStatusCode_Call{Call: _e.mock.On("GetClusterInfoWStatusCode", hostAddr, path, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)}
}

func (_c *UtilsIface_GetClusterInfoWStatusCode_Call) Run(run func(hostAddr string, path string, username string, password string, authMech base.HttpAuthMech, certificate []byte, sanInCertificate bool, clientCertificate []byte, clientKey []byte, logger *log.CommonLogger)) *UtilsIface_GetClusterInfoWStatusCode_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].(string), args[3].(string), args[4].(base.HttpAuthMech), args[5].([]byte), args[6].(bool), args[7].([]byte), args[8].([]byte), args[9].(*log.CommonLogger))
	})
	return _c
}

func (_c *UtilsIface_GetClusterInfoWStatusCode_Call) Return(_a0 map[string]interface{}, _a1 error, _a2 int) *UtilsIface_GetClusterInfoWStatusCode_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *UtilsIface_GetClusterInfoWStatusCode_Call) RunAndReturn(run func(string, string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) (map[string]interface{}, error, int)) *UtilsIface_GetClusterInfoWStatusCode_Call {
	_c.Call.Return(run)
	return _c
}

// GetClusterUUID provides a mock function with given fields: hostAddr, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger
func (_m *UtilsIface) GetClusterUUID(hostAddr string, username string, password string, authMech base.HttpAuthMech, certificate []byte, sanInCertificate bool, clientCertificate []byte, clientKey []byte, logger *log.CommonLogger) (string, error) {
	ret := _m.Called(hostAddr, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) (string, error)); ok {
		return rf(hostAddr, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	}
	if rf, ok := ret.Get(0).(func(string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) string); ok {
		r0 = rf(hostAddr, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) error); ok {
		r1 = rf(hostAddr, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UtilsIface_GetClusterUUID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetClusterUUID'
type UtilsIface_GetClusterUUID_Call struct {
	*mock.Call
}

// GetClusterUUID is a helper method to define mock.On call
//   - hostAddr string
//   - username string
//   - password string
//   - authMech base.HttpAuthMech
//   - certificate []byte
//   - sanInCertificate bool
//   - clientCertificate []byte
//   - clientKey []byte
//   - logger *log.CommonLogger
func (_e *UtilsIface_Expecter) GetClusterUUID(hostAddr interface{}, username interface{}, password interface{}, authMech interface{}, certificate interface{}, sanInCertificate interface{}, clientCertificate interface{}, clientKey interface{}, logger interface{}) *UtilsIface_GetClusterUUID_Call {
	return &UtilsIface_GetClusterUUID_Call{Call: _e.mock.On("GetClusterUUID", hostAddr, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)}
}

func (_c *UtilsIface_GetClusterUUID_Call) Run(run func(hostAddr string, username string, password string, authMech base.HttpAuthMech, certificate []byte, sanInCertificate bool, clientCertificate []byte, clientKey []byte, logger *log.CommonLogger)) *UtilsIface_GetClusterUUID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].(string), args[3].(base.HttpAuthMech), args[4].([]byte), args[5].(bool), args[6].([]byte), args[7].([]byte), args[8].(*log.CommonLogger))
	})
	return _c
}

func (_c *UtilsIface_GetClusterUUID_Call) Return(_a0 string, _a1 error) *UtilsIface_GetClusterUUID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *UtilsIface_GetClusterUUID_Call) RunAndReturn(run func(string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) (string, error)) *UtilsIface_GetClusterUUID_Call {
	_c.Call.Return(run)
	return _c
}

// GetClusterUUIDAndNodeListWithMinInfo provides a mock function with given fields: hostAddr, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger
func (_m *UtilsIface) GetClusterUUIDAndNodeListWithMinInfo(hostAddr string, username string, password string, authMech base.HttpAuthMech, certificate []byte, sanInCertificate bool, clientCertificate []byte, clientKey []byte, logger *log.CommonLogger) (string, []interface{}, error) {
	ret := _m.Called(hostAddr, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)

	var r0 string
	var r1 []interface{}
	var r2 error
	if rf, ok := ret.Get(0).(func(string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) (string, []interface{}, error)); ok {
		return rf(hostAddr, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	}
	if rf, ok := ret.Get(0).(func(string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) string); ok {
		r0 = rf(hostAddr, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) []interface{}); ok {
		r1 = rf(hostAddr, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]interface{})
		}
	}

	if rf, ok := ret.Get(2).(func(string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) error); ok {
		r2 = rf(hostAddr, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// UtilsIface_GetClusterUUIDAndNodeListWithMinInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetClusterUUIDAndNodeListWithMinInfo'
type UtilsIface_GetClusterUUIDAndNodeListWithMinInfo_Call struct {
	*mock.Call
}

// GetClusterUUIDAndNodeListWithMinInfo is a helper method to define mock.On call
//   - hostAddr string
//   - username string
//   - password string
//   - authMech base.HttpAuthMech
//   - certificate []byte
//   - sanInCertificate bool
//   - clientCertificate []byte
//   - clientKey []byte
//   - logger *log.CommonLogger
func (_e *UtilsIface_Expecter) GetClusterUUIDAndNodeListWithMinInfo(hostAddr interface{}, username interface{}, password interface{}, authMech interface{}, certificate interface{}, sanInCertificate interface{}, clientCertificate interface{}, clientKey interface{}, logger interface{}) *UtilsIface_GetClusterUUIDAndNodeListWithMinInfo_Call {
	return &UtilsIface_GetClusterUUIDAndNodeListWithMinInfo_Call{Call: _e.mock.On("GetClusterUUIDAndNodeListWithMinInfo", hostAddr, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)}
}

func (_c *UtilsIface_GetClusterUUIDAndNodeListWithMinInfo_Call) Run(run func(hostAddr string, username string, password string, authMech base.HttpAuthMech, certificate []byte, sanInCertificate bool, clientCertificate []byte, clientKey []byte, logger *log.CommonLogger)) *UtilsIface_GetClusterUUIDAndNodeListWithMinInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].(string), args[3].(base.HttpAuthMech), args[4].([]byte), args[5].(bool), args[6].([]byte), args[7].([]byte), args[8].(*log.CommonLogger))
	})
	return _c
}

func (_c *UtilsIface_GetClusterUUIDAndNodeListWithMinInfo_Call) Return(_a0 string, _a1 []interface{}, _a2 error) *UtilsIface_GetClusterUUIDAndNodeListWithMinInfo_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *UtilsIface_GetClusterUUIDAndNodeListWithMinInfo_Call) RunAndReturn(run func(string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) (string, []interface{}, error)) *UtilsIface_GetClusterUUIDAndNodeListWithMinInfo_Call {
	_c.Call.Return(run)
	return _c
}

// GetClusterUUIDAndNodeListWithMinInfoFromDefaultPoolInfo provides a mock function with given fields: defaultPoolInfo, logger
func (_m *UtilsIface) GetClusterUUIDAndNodeListWithMinInfoFromDefaultPoolInfo(defaultPoolInfo map[string]interface{}, logger *log.CommonLogger) (string, []interface{}, error) {
	ret := _m.Called(defaultPoolInfo, logger)

	var r0 string
	var r1 []interface{}
	var r2 error
	if rf, ok := ret.Get(0).(func(map[string]interface{}, *log.CommonLogger) (string, []interface{}, error)); ok {
		return rf(defaultPoolInfo, logger)
	}
	if rf, ok := ret.Get(0).(func(map[string]interface{}, *log.CommonLogger) string); ok {
		r0 = rf(defaultPoolInfo, logger)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(map[string]interface{}, *log.CommonLogger) []interface{}); ok {
		r1 = rf(defaultPoolInfo, logger)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]interface{})
		}
	}

	if rf, ok := ret.Get(2).(func(map[string]interface{}, *log.CommonLogger) error); ok {
		r2 = rf(defaultPoolInfo, logger)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// UtilsIface_GetClusterUUIDAndNodeListWithMinInfoFromDefaultPoolInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetClusterUUIDAndNodeListWithMinInfoFromDefaultPoolInfo'
type UtilsIface_GetClusterUUIDAndNodeListWithMinInfoFromDefaultPoolInfo_Call struct {
	*mock.Call
}

// GetClusterUUIDAndNodeListWithMinInfoFromDefaultPoolInfo is a helper method to define mock.On call
//   - defaultPoolInfo map[string]interface{}
//   - logger *log.CommonLogger
func (_e *UtilsIface_Expecter) GetClusterUUIDAndNodeListWithMinInfoFromDefaultPoolInfo(defaultPoolInfo interface{}, logger interface{}) *UtilsIface_GetClusterUUIDAndNodeListWithMinInfoFromDefaultPoolInfo_Call {
	return &UtilsIface_GetClusterUUIDAndNodeListWithMinInfoFromDefaultPoolInfo_Call{Call: _e.mock.On("GetClusterUUIDAndNodeListWithMinInfoFromDefaultPoolInfo", defaultPoolInfo, logger)}
}

func (_c *UtilsIface_GetClusterUUIDAndNodeListWithMinInfoFromDefaultPoolInfo_Call) Run(run func(defaultPoolInfo map[string]interface{}, logger *log.CommonLogger)) *UtilsIface_GetClusterUUIDAndNodeListWithMinInfoFromDefaultPoolInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(map[string]interface{}), args[1].(*log.CommonLogger))
	})
	return _c
}

func (_c *UtilsIface_GetClusterUUIDAndNodeListWithMinInfoFromDefaultPoolInfo_Call) Return(_a0 string, _a1 []interface{}, _a2 error) *UtilsIface_GetClusterUUIDAndNodeListWithMinInfoFromDefaultPoolInfo_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *UtilsIface_GetClusterUUIDAndNodeListWithMinInfoFromDefaultPoolInfo_Call) RunAndReturn(run func(map[string]interface{}, *log.CommonLogger) (string, []interface{}, error)) *UtilsIface_GetClusterUUIDAndNodeListWithMinInfoFromDefaultPoolInfo_Call {
	_c.Call.Return(run)
	return _c
}

// GetClusterUUIDFromDefaultPoolInfo provides a mock function with given fields: defaultPoolInfo, logger
func (_m *UtilsIface) GetClusterUUIDFromDefaultPoolInfo(defaultPoolInfo map[string]interface{}, logger *log.CommonLogger) (string, error) {
	ret := _m.Called(defaultPoolInfo, logger)

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(map[string]interface{}, *log.CommonLogger) (string, error)); ok {
		return rf(defaultPoolInfo, logger)
	}
	if rf, ok := ret.Get(0).(func(map[string]interface{}, *log.CommonLogger) string); ok {
		r0 = rf(defaultPoolInfo, logger)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(map[string]interface{}, *log.CommonLogger) error); ok {
		r1 = rf(defaultPoolInfo, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UtilsIface_GetClusterUUIDFromDefaultPoolInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetClusterUUIDFromDefaultPoolInfo'
type UtilsIface_GetClusterUUIDFromDefaultPoolInfo_Call struct {
	*mock.Call
}

// GetClusterUUIDFromDefaultPoolInfo is a helper method to define mock.On call
//   - defaultPoolInfo map[string]interface{}
//   - logger *log.CommonLogger
func (_e *UtilsIface_Expecter) GetClusterUUIDFromDefaultPoolInfo(defaultPoolInfo interface{}, logger interface{}) *UtilsIface_GetClusterUUIDFromDefaultPoolInfo_Call {
	return &UtilsIface_GetClusterUUIDFromDefaultPoolInfo_Call{Call: _e.mock.On("GetClusterUUIDFromDefaultPoolInfo", defaultPoolInfo, logger)}
}

func (_c *UtilsIface_GetClusterUUIDFromDefaultPoolInfo_Call) Run(run func(defaultPoolInfo map[string]interface{}, logger *log.CommonLogger)) *UtilsIface_GetClusterUUIDFromDefaultPoolInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(map[string]interface{}), args[1].(*log.CommonLogger))
	})
	return _c
}

func (_c *UtilsIface_GetClusterUUIDFromDefaultPoolInfo_Call) Return(_a0 string, _a1 error) *UtilsIface_GetClusterUUIDFromDefaultPoolInfo_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *UtilsIface_GetClusterUUIDFromDefaultPoolInfo_Call) RunAndReturn(run func(map[string]interface{}, *log.CommonLogger) (string, error)) *UtilsIface_GetClusterUUIDFromDefaultPoolInfo_Call {
	_c.Call.Return(run)
	return _c
}

// GetClusterUUIDFromURI provides a mock function with given fields: uri
func (_m *UtilsIface) GetClusterUUIDFromURI(uri string) (string, error) {
	ret := _m.Called(uri)

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (string, error)); ok {
		return rf(uri)
	}
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(uri)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(uri)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UtilsIface_GetClusterUUIDFromURI_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetClusterUUIDFromURI'
type UtilsIface_GetClusterUUIDFromURI_Call struct {
	*mock.Call
}

// GetClusterUUIDFromURI is a helper method to define mock.On call
//   - uri string
func (_e *UtilsIface_Expecter) GetClusterUUIDFromURI(uri interface{}) *UtilsIface_GetClusterUUIDFromURI_Call {
	return &UtilsIface_GetClusterUUIDFromURI_Call{Call: _e.mock.On("GetClusterUUIDFromURI", uri)}
}

func (_c *UtilsIface_GetClusterUUIDFromURI_Call) Run(run func(uri string)) *UtilsIface_GetClusterUUIDFromURI_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *UtilsIface_GetClusterUUIDFromURI_Call) Return(_a0 string, _a1 error) *UtilsIface_GetClusterUUIDFromURI_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *UtilsIface_GetClusterUUIDFromURI_Call) RunAndReturn(run func(string) (string, error)) *UtilsIface_GetClusterUUIDFromURI_Call {
	_c.Call.Return(run)
	return _c
}

// GetCollectionManifestUidFromBucketInfo provides a mock function with given fields: bucketInfo
func (_m *UtilsIface) GetCollectionManifestUidFromBucketInfo(bucketInfo map[string]interface{}) (uint64, error) {
	ret := _m.Called(bucketInfo)

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(map[string]interface{}) (uint64, error)); ok {
		return rf(bucketInfo)
	}
	if rf, ok := ret.Get(0).(func(map[string]interface{}) uint64); ok {
		r0 = rf(bucketInfo)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(map[string]interface{}) error); ok {
		r1 = rf(bucketInfo)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UtilsIface_GetCollectionManifestUidFromBucketInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCollectionManifestUidFromBucketInfo'
type UtilsIface_GetCollectionManifestUidFromBucketInfo_Call struct {
	*mock.Call
}

// GetCollectionManifestUidFromBucketInfo is a helper method to define mock.On call
//   - bucketInfo map[string]interface{}
func (_e *UtilsIface_Expecter) GetCollectionManifestUidFromBucketInfo(bucketInfo interface{}) *UtilsIface_GetCollectionManifestUidFromBucketInfo_Call {
	return &UtilsIface_GetCollectionManifestUidFromBucketInfo_Call{Call: _e.mock.On("GetCollectionManifestUidFromBucketInfo", bucketInfo)}
}

func (_c *UtilsIface_GetCollectionManifestUidFromBucketInfo_Call) Run(run func(bucketInfo map[string]interface{})) *UtilsIface_GetCollectionManifestUidFromBucketInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(map[string]interface{}))
	})
	return _c
}

func (_c *UtilsIface_GetCollectionManifestUidFromBucketInfo_Call) Return(_a0 uint64, _a1 error) *UtilsIface_GetCollectionManifestUidFromBucketInfo_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *UtilsIface_GetCollectionManifestUidFromBucketInfo_Call) RunAndReturn(run func(map[string]interface{}) (uint64, error)) *UtilsIface_GetCollectionManifestUidFromBucketInfo_Call {
	_c.Call.Return(run)
	return _c
}

// GetCollectionsManifest provides a mock function with given fields: hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger
func (_m *UtilsIface) GetCollectionsManifest(hostAddr string, bucketName string, username string, password string, authMech base.HttpAuthMech, certificate []byte, sanInCertificate bool, clientCertificate []byte, clientKey []byte, logger *log.CommonLogger) (*metadata.CollectionsManifest, error) {
	ret := _m.Called(hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)

	var r0 *metadata.CollectionsManifest
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) (*metadata.CollectionsManifest, error)); ok {
		return rf(hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	}
	if rf, ok := ret.Get(0).(func(string, string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) *metadata.CollectionsManifest); ok {
		r0 = rf(hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*metadata.CollectionsManifest)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) error); ok {
		r1 = rf(hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UtilsIface_GetCollectionsManifest_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCollectionsManifest'
type UtilsIface_GetCollectionsManifest_Call struct {
	*mock.Call
}

// GetCollectionsManifest is a helper method to define mock.On call
//   - hostAddr string
//   - bucketName string
//   - username string
//   - password string
//   - authMech base.HttpAuthMech
//   - certificate []byte
//   - sanInCertificate bool
//   - clientCertificate []byte
//   - clientKey []byte
//   - logger *log.CommonLogger
func (_e *UtilsIface_Expecter) GetCollectionsManifest(hostAddr interface{}, bucketName interface{}, username interface{}, password interface{}, authMech interface{}, certificate interface{}, sanInCertificate interface{}, clientCertificate interface{}, clientKey interface{}, logger interface{}) *UtilsIface_GetCollectionsManifest_Call {
	return &UtilsIface_GetCollectionsManifest_Call{Call: _e.mock.On("GetCollectionsManifest", hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)}
}

func (_c *UtilsIface_GetCollectionsManifest_Call) Run(run func(hostAddr string, bucketName string, username string, password string, authMech base.HttpAuthMech, certificate []byte, sanInCertificate bool, clientCertificate []byte, clientKey []byte, logger *log.CommonLogger)) *UtilsIface_GetCollectionsManifest_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].(string), args[3].(string), args[4].(base.HttpAuthMech), args[5].([]byte), args[6].(bool), args[7].([]byte), args[8].([]byte), args[9].(*log.CommonLogger))
	})
	return _c
}

func (_c *UtilsIface_GetCollectionsManifest_Call) Return(_a0 *metadata.CollectionsManifest, _a1 error) *UtilsIface_GetCollectionsManifest_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *UtilsIface_GetCollectionsManifest_Call) RunAndReturn(run func(string, string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) (*metadata.CollectionsManifest, error)) *UtilsIface_GetCollectionsManifest_Call {
	_c.Call.Return(run)
	return _c
}

// GetConflictResolutionTypeFromBucketInfo provides a mock function with given fields: bucketName, bucketInfo
func (_m *UtilsIface) GetConflictResolutionTypeFromBucketInfo(bucketName string, bucketInfo map[string]interface{}) (string, error) {
	ret := _m.Called(bucketName, bucketInfo)

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(string, map[string]interface{}) (string, error)); ok {
		return rf(bucketName, bucketInfo)
	}
	if rf, ok := ret.Get(0).(func(string, map[string]interface{}) string); ok {
		r0 = rf(bucketName, bucketInfo)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string, map[string]interface{}) error); ok {
		r1 = rf(bucketName, bucketInfo)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UtilsIface_GetConflictResolutionTypeFromBucketInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetConflictResolutionTypeFromBucketInfo'
type UtilsIface_GetConflictResolutionTypeFromBucketInfo_Call struct {
	*mock.Call
}

// GetConflictResolutionTypeFromBucketInfo is a helper method to define mock.On call
//   - bucketName string
//   - bucketInfo map[string]interface{}
func (_e *UtilsIface_Expecter) GetConflictResolutionTypeFromBucketInfo(bucketName interface{}, bucketInfo interface{}) *UtilsIface_GetConflictResolutionTypeFromBucketInfo_Call {
	return &UtilsIface_GetConflictResolutionTypeFromBucketInfo_Call{Call: _e.mock.On("GetConflictResolutionTypeFromBucketInfo", bucketName, bucketInfo)}
}

func (_c *UtilsIface_GetConflictResolutionTypeFromBucketInfo_Call) Run(run func(bucketName string, bucketInfo map[string]interface{})) *UtilsIface_GetConflictResolutionTypeFromBucketInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(map[string]interface{}))
	})
	return _c
}

func (_c *UtilsIface_GetConflictResolutionTypeFromBucketInfo_Call) Return(_a0 string, _a1 error) *UtilsIface_GetConflictResolutionTypeFromBucketInfo_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *UtilsIface_GetConflictResolutionTypeFromBucketInfo_Call) RunAndReturn(run func(string, map[string]interface{}) (string, error)) *UtilsIface_GetConflictResolutionTypeFromBucketInfo_Call {
	_c.Call.Return(run)
	return _c
}

// GetCrossClusterVersioningFromBucketInfo provides a mock function with given fields: bucketInfo
func (_m *UtilsIface) GetCrossClusterVersioningFromBucketInfo(bucketInfo map[string]interface{}) (bool, error) {
	ret := _m.Called(bucketInfo)

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(map[string]interface{}) (bool, error)); ok {
		return rf(bucketInfo)
	}
	if rf, ok := ret.Get(0).(func(map[string]interface{}) bool); ok {
		r0 = rf(bucketInfo)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(map[string]interface{}) error); ok {
		r1 = rf(bucketInfo)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UtilsIface_GetCrossClusterVersioningFromBucketInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCrossClusterVersioningFromBucketInfo'
type UtilsIface_GetCrossClusterVersioningFromBucketInfo_Call struct {
	*mock.Call
}

// GetCrossClusterVersioningFromBucketInfo is a helper method to define mock.On call
//   - bucketInfo map[string]interface{}
func (_e *UtilsIface_Expecter) GetCrossClusterVersioningFromBucketInfo(bucketInfo interface{}) *UtilsIface_GetCrossClusterVersioningFromBucketInfo_Call {
	return &UtilsIface_GetCrossClusterVersioningFromBucketInfo_Call{Call: _e.mock.On("GetCrossClusterVersioningFromBucketInfo", bucketInfo)}
}

func (_c *UtilsIface_GetCrossClusterVersioningFromBucketInfo_Call) Run(run func(bucketInfo map[string]interface{})) *UtilsIface_GetCrossClusterVersioningFromBucketInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(map[string]interface{}))
	})
	return _c
}

func (_c *UtilsIface_GetCrossClusterVersioningFromBucketInfo_Call) Return(_a0 bool, _a1 error) *UtilsIface_GetCrossClusterVersioningFromBucketInfo_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *UtilsIface_GetCrossClusterVersioningFromBucketInfo_Call) RunAndReturn(run func(map[string]interface{}) (bool, error)) *UtilsIface_GetCrossClusterVersioningFromBucketInfo_Call {
	_c.Call.Return(run)
	return _c
}

// GetCurrentHostnameFromBucketInfo provides a mock function with given fields: bucketInfo
func (_m *UtilsIface) GetCurrentHostnameFromBucketInfo(bucketInfo map[string]interface{}) (string, error) {
	ret := _m.Called(bucketInfo)

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(map[string]interface{}) (string, error)); ok {
		return rf(bucketInfo)
	}
	if rf, ok := ret.Get(0).(func(map[string]interface{}) string); ok {
		r0 = rf(bucketInfo)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(map[string]interface{}) error); ok {
		r1 = rf(bucketInfo)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UtilsIface_GetCurrentHostnameFromBucketInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCurrentHostnameFromBucketInfo'
type UtilsIface_GetCurrentHostnameFromBucketInfo_Call struct {
	*mock.Call
}

// GetCurrentHostnameFromBucketInfo is a helper method to define mock.On call
//   - bucketInfo map[string]interface{}
func (_e *UtilsIface_Expecter) GetCurrentHostnameFromBucketInfo(bucketInfo interface{}) *UtilsIface_GetCurrentHostnameFromBucketInfo_Call {
	return &UtilsIface_GetCurrentHostnameFromBucketInfo_Call{Call: _e.mock.On("GetCurrentHostnameFromBucketInfo", bucketInfo)}
}

func (_c *UtilsIface_GetCurrentHostnameFromBucketInfo_Call) Run(run func(bucketInfo map[string]interface{})) *UtilsIface_GetCurrentHostnameFromBucketInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(map[string]interface{}))
	})
	return _c
}

func (_c *UtilsIface_GetCurrentHostnameFromBucketInfo_Call) Return(_a0 string, _a1 error) *UtilsIface_GetCurrentHostnameFromBucketInfo_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *UtilsIface_GetCurrentHostnameFromBucketInfo_Call) RunAndReturn(run func(map[string]interface{}) (string, error)) *UtilsIface_GetCurrentHostnameFromBucketInfo_Call {
	_c.Call.Return(run)
	return _c
}

// GetDefaultPoolInfoUsingHttps provides a mock function with given fields: hostHttpsAddr, username, password, certificate, clientCertificate, clientKey, logger
func (_m *UtilsIface) GetDefaultPoolInfoUsingHttps(hostHttpsAddr string, username string, password string, certificate []byte, clientCertificate []byte, clientKey []byte, logger *log.CommonLogger) (map[string]interface{}, int, error) {
	ret := _m.Called(hostHttpsAddr, username, password, certificate, clientCertificate, clientKey, logger)

	var r0 map[string]interface{}
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(string, string, string, []byte, []byte, []byte, *log.CommonLogger) (map[string]interface{}, int, error)); ok {
		return rf(hostHttpsAddr, username, password, certificate, clientCertificate, clientKey, logger)
	}
	if rf, ok := ret.Get(0).(func(string, string, string, []byte, []byte, []byte, *log.CommonLogger) map[string]interface{}); ok {
		r0 = rf(hostHttpsAddr, username, password, certificate, clientCertificate, clientKey, logger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, string, []byte, []byte, []byte, *log.CommonLogger) int); ok {
		r1 = rf(hostHttpsAddr, username, password, certificate, clientCertificate, clientKey, logger)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(string, string, string, []byte, []byte, []byte, *log.CommonLogger) error); ok {
		r2 = rf(hostHttpsAddr, username, password, certificate, clientCertificate, clientKey, logger)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// UtilsIface_GetDefaultPoolInfoUsingHttps_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDefaultPoolInfoUsingHttps'
type UtilsIface_GetDefaultPoolInfoUsingHttps_Call struct {
	*mock.Call
}

// GetDefaultPoolInfoUsingHttps is a helper method to define mock.On call
//   - hostHttpsAddr string
//   - username string
//   - password string
//   - certificate []byte
//   - clientCertificate []byte
//   - clientKey []byte
//   - logger *log.CommonLogger
func (_e *UtilsIface_Expecter) GetDefaultPoolInfoUsingHttps(hostHttpsAddr interface{}, username interface{}, password interface{}, certificate interface{}, clientCertificate interface{}, clientKey interface{}, logger interface{}) *UtilsIface_GetDefaultPoolInfoUsingHttps_Call {
	return &UtilsIface_GetDefaultPoolInfoUsingHttps_Call{Call: _e.mock.On("GetDefaultPoolInfoUsingHttps", hostHttpsAddr, username, password, certificate, clientCertificate, clientKey, logger)}
}

func (_c *UtilsIface_GetDefaultPoolInfoUsingHttps_Call) Run(run func(hostHttpsAddr string, username string, password string, certificate []byte, clientCertificate []byte, clientKey []byte, logger *log.CommonLogger)) *UtilsIface_GetDefaultPoolInfoUsingHttps_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].(string), args[3].([]byte), args[4].([]byte), args[5].([]byte), args[6].(*log.CommonLogger))
	})
	return _c
}

func (_c *UtilsIface_GetDefaultPoolInfoUsingHttps_Call) Return(_a0 map[string]interface{}, _a1 int, _a2 error) *UtilsIface_GetDefaultPoolInfoUsingHttps_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *UtilsIface_GetDefaultPoolInfoUsingHttps_Call) RunAndReturn(run func(string, string, string, []byte, []byte, []byte, *log.CommonLogger) (map[string]interface{}, int, error)) *UtilsIface_GetDefaultPoolInfoUsingHttps_Call {
	_c.Call.Return(run)
	return _c
}

// GetDefaultPoolInfoUsingScramSha provides a mock function with given fields: hostAddr, username, password, logger
func (_m *UtilsIface) GetDefaultPoolInfoUsingScramSha(hostAddr string, username string, password string, logger *log.CommonLogger) (map[string]interface{}, int, error) {
	ret := _m.Called(hostAddr, username, password, logger)

	var r0 map[string]interface{}
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(string, string, string, *log.CommonLogger) (map[string]interface{}, int, error)); ok {
		return rf(hostAddr, username, password, logger)
	}
	if rf, ok := ret.Get(0).(func(string, string, string, *log.CommonLogger) map[string]interface{}); ok {
		r0 = rf(hostAddr, username, password, logger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, string, *log.CommonLogger) int); ok {
		r1 = rf(hostAddr, username, password, logger)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(string, string, string, *log.CommonLogger) error); ok {
		r2 = rf(hostAddr, username, password, logger)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// UtilsIface_GetDefaultPoolInfoUsingScramSha_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDefaultPoolInfoUsingScramSha'
type UtilsIface_GetDefaultPoolInfoUsingScramSha_Call struct {
	*mock.Call
}

// GetDefaultPoolInfoUsingScramSha is a helper method to define mock.On call
//   - hostAddr string
//   - username string
//   - password string
//   - logger *log.CommonLogger
func (_e *UtilsIface_Expecter) GetDefaultPoolInfoUsingScramSha(hostAddr interface{}, username interface{}, password interface{}, logger interface{}) *UtilsIface_GetDefaultPoolInfoUsingScramSha_Call {
	return &UtilsIface_GetDefaultPoolInfoUsingScramSha_Call{Call: _e.mock.On("GetDefaultPoolInfoUsingScramSha", hostAddr, username, password, logger)}
}

func (_c *UtilsIface_GetDefaultPoolInfoUsingScramSha_Call) Run(run func(hostAddr string, username string, password string, logger *log.CommonLogger)) *UtilsIface_GetDefaultPoolInfoUsingScramSha_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].(string), args[3].(*log.CommonLogger))
	})
	return _c
}

func (_c *UtilsIface_GetDefaultPoolInfoUsingScramSha_Call) Return(_a0 map[string]interface{}, _a1 int, _a2 error) *UtilsIface_GetDefaultPoolInfoUsingScramSha_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *UtilsIface_GetDefaultPoolInfoUsingScramSha_Call) RunAndReturn(run func(string, string, string, *log.CommonLogger) (map[string]interface{}, int, error)) *UtilsIface_GetDefaultPoolInfoUsingScramSha_Call {
	_c.Call.Return(run)
	return _c
}

// GetEvictionPolicyFromBucketInfo provides a mock function with given fields: bucketName, bucketInfo
func (_m *UtilsIface) GetEvictionPolicyFromBucketInfo(bucketName string, bucketInfo map[string]interface{}) (string, error) {
	ret := _m.Called(bucketName, bucketInfo)

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(string, map[string]interface{}) (string, error)); ok {
		return rf(bucketName, bucketInfo)
	}
	if rf, ok := ret.Get(0).(func(string, map[string]interface{}) string); ok {
		r0 = rf(bucketName, bucketInfo)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string, map[string]interface{}) error); ok {
		r1 = rf(bucketName, bucketInfo)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UtilsIface_GetEvictionPolicyFromBucketInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEvictionPolicyFromBucketInfo'
type UtilsIface_GetEvictionPolicyFromBucketInfo_Call struct {
	*mock.Call
}

// GetEvictionPolicyFromBucketInfo is a helper method to define mock.On call
//   - bucketName string
//   - bucketInfo map[string]interface{}
func (_e *UtilsIface_Expecter) GetEvictionPolicyFromBucketInfo(bucketName interface{}, bucketInfo interface{}) *UtilsIface_GetEvictionPolicyFromBucketInfo_Call {
	return &UtilsIface_GetEvictionPolicyFromBucketInfo_Call{Call: _e.mock.On("GetEvictionPolicyFromBucketInfo", bucketName, bucketInfo)}
}

func (_c *UtilsIface_GetEvictionPolicyFromBucketInfo_Call) Run(run func(bucketName string, bucketInfo map[string]interface{})) *UtilsIface_GetEvictionPolicyFromBucketInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(map[string]interface{}))
	})
	return _c
}

func (_c *UtilsIface_GetEvictionPolicyFromBucketInfo_Call) Return(_a0 string, _a1 error) *UtilsIface_GetEvictionPolicyFromBucketInfo_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *UtilsIface_GetEvictionPolicyFromBucketInfo_Call) RunAndReturn(run func(string, map[string]interface{}) (string, error)) *UtilsIface_GetEvictionPolicyFromBucketInfo_Call {
	_c.Call.Return(run)
	return _c
}

// GetExternalAddressAndKvPortsFromNodeInfo provides a mock function with given fields: nodeInfo
func (_m *UtilsIface) GetExternalAddressAndKvPortsFromNodeInfo(nodeInfo map[string]interface{}) (string, int, error, int, error) {
	ret := _m.Called(nodeInfo)

	var r0 string
	var r1 int
	var r2 error
	var r3 int
	var r4 error
	if rf, ok := ret.Get(0).(func(map[string]interface{}) (string, int, error, int, error)); ok {
		return rf(nodeInfo)
	}
	if rf, ok := ret.Get(0).(func(map[string]interface{}) string); ok {
		r0 = rf(nodeInfo)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(map[string]interface{}) int); ok {
		r1 = rf(nodeInfo)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(map[string]interface{}) error); ok {
		r2 = rf(nodeInfo)
	} else {
		r2 = ret.Error(2)
	}

	if rf, ok := ret.Get(3).(func(map[string]interface{}) int); ok {
		r3 = rf(nodeInfo)
	} else {
		r3 = ret.Get(3).(int)
	}

	if rf, ok := ret.Get(4).(func(map[string]interface{}) error); ok {
		r4 = rf(nodeInfo)
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// UtilsIface_GetExternalAddressAndKvPortsFromNodeInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetExternalAddressAndKvPortsFromNodeInfo'
type UtilsIface_GetExternalAddressAndKvPortsFromNodeInfo_Call struct {
	*mock.Call
}

// GetExternalAddressAndKvPortsFromNodeInfo is a helper method to define mock.On call
//   - nodeInfo map[string]interface{}
func (_e *UtilsIface_Expecter) GetExternalAddressAndKvPortsFromNodeInfo(nodeInfo interface{}) *UtilsIface_GetExternalAddressAndKvPortsFromNodeInfo_Call {
	return &UtilsIface_GetExternalAddressAndKvPortsFromNodeInfo_Call{Call: _e.mock.On("GetExternalAddressAndKvPortsFromNodeInfo", nodeInfo)}
}

func (_c *UtilsIface_GetExternalAddressAndKvPortsFromNodeInfo_Call) Run(run func(nodeInfo map[string]interface{})) *UtilsIface_GetExternalAddressAndKvPortsFromNodeInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(map[string]interface{}))
	})
	return _c
}

func (_c *UtilsIface_GetExternalAddressAndKvPortsFromNodeInfo_Call) Return(_a0 string, _a1 int, _a2 error, _a3 int, _a4 error) *UtilsIface_GetExternalAddressAndKvPortsFromNodeInfo_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3, _a4)
	return _c
}

func (_c *UtilsIface_GetExternalAddressAndKvPortsFromNodeInfo_Call) RunAndReturn(run func(map[string]interface{}) (string, int, error, int, error)) *UtilsIface_GetExternalAddressAndKvPortsFromNodeInfo_Call {
	_c.Call.Return(run)
	return _c
}

// GetExternalMgtHostAndPort provides a mock function with given fields: nodeInfo, isHttps
func (_m *UtilsIface) GetExternalMgtHostAndPort(nodeInfo map[string]interface{}, isHttps bool) (string, int, error) {
	ret := _m.Called(nodeInfo, isHttps)

	var r0 string
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(map[string]interface{}, bool) (string, int, error)); ok {
		return rf(nodeInfo, isHttps)
	}
	if rf, ok := ret.Get(0).(func(map[string]interface{}, bool) string); ok {
		r0 = rf(nodeInfo, isHttps)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(map[string]interface{}, bool) int); ok {
		r1 = rf(nodeInfo, isHttps)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(map[string]interface{}, bool) error); ok {
		r2 = rf(nodeInfo, isHttps)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// UtilsIface_GetExternalMgtHostAndPort_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetExternalMgtHostAndPort'
type UtilsIface_GetExternalMgtHostAndPort_Call struct {
	*mock.Call
}

// GetExternalMgtHostAndPort is a helper method to define mock.On call
//   - nodeInfo map[string]interface{}
//   - isHttps bool
func (_e *UtilsIface_Expecter) GetExternalMgtHostAndPort(nodeInfo interface{}, isHttps interface{}) *UtilsIface_GetExternalMgtHostAndPort_Call {
	return &UtilsIface_GetExternalMgtHostAndPort_Call{Call: _e.mock.On("GetExternalMgtHostAndPort", nodeInfo, isHttps)}
}

func (_c *UtilsIface_GetExternalMgtHostAndPort_Call) Run(run func(nodeInfo map[string]interface{}, isHttps bool)) *UtilsIface_GetExternalMgtHostAndPort_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(map[string]interface{}), args[1].(bool))
	})
	return _c
}

func (_c *UtilsIface_GetExternalMgtHostAndPort_Call) Return(_a0 string, _a1 int, _a2 error) *UtilsIface_GetExternalMgtHostAndPort_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *UtilsIface_GetExternalMgtHostAndPort_Call) RunAndReturn(run func(map[string]interface{}, bool) (string, int, error)) *UtilsIface_GetExternalMgtHostAndPort_Call {
	_c.Call.Return(run)
	return _c
}

// GetHighSeqNos provides a mock function with given fields: vbnos, conn, stats_map, collectionIds, recycledVbSeqnoMap
func (_m *UtilsIface) GetHighSeqNos(vbnos []uint16, conn memcached.ClientIface, stats_map *map[string]string, collectionIds []uint32, recycledVbSeqnoMap *map[uint16]uint64) (*map[uint16]uint64, *map[string]string, []uint16, error) {
	ret := _m.Called(vbnos, conn, stats_map, collectionIds, recycledVbSeqnoMap)

	var r0 *map[uint16]uint64
	var r1 *map[string]string
	var r2 []uint16
	var r3 error
	if rf, ok := ret.Get(0).(func([]uint16, memcached.ClientIface, *map[string]string, []uint32, *map[uint16]uint64) (*map[uint16]uint64, *map[string]string, []uint16, error)); ok {
		return rf(vbnos, conn, stats_map, collectionIds, recycledVbSeqnoMap)
	}
	if rf, ok := ret.Get(0).(func([]uint16, memcached.ClientIface, *map[string]string, []uint32, *map[uint16]uint64) *map[uint16]uint64); ok {
		r0 = rf(vbnos, conn, stats_map, collectionIds, recycledVbSeqnoMap)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*map[uint16]uint64)
		}
	}

	if rf, ok := ret.Get(1).(func([]uint16, memcached.ClientIface, *map[string]string, []uint32, *map[uint16]uint64) *map[string]string); ok {
		r1 = rf(vbnos, conn, stats_map, collectionIds, recycledVbSeqnoMap)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*map[string]string)
		}
	}

	if rf, ok := ret.Get(2).(func([]uint16, memcached.ClientIface, *map[string]string, []uint32, *map[uint16]uint64) []uint16); ok {
		r2 = rf(vbnos, conn, stats_map, collectionIds, recycledVbSeqnoMap)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]uint16)
		}
	}

	if rf, ok := ret.Get(3).(func([]uint16, memcached.ClientIface, *map[string]string, []uint32, *map[uint16]uint64) error); ok {
		r3 = rf(vbnos, conn, stats_map, collectionIds, recycledVbSeqnoMap)
	} else {
		r3 = ret.Error(3)
	}

	return r0, r1, r2, r3
}

// UtilsIface_GetHighSeqNos_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetHighSeqNos'
type UtilsIface_GetHighSeqNos_Call struct {
	*mock.Call
}

// GetHighSeqNos is a helper method to define mock.On call
//   - vbnos []uint16
//   - conn memcached.ClientIface
//   - stats_map *map[string]string
//   - collectionIds []uint32
//   - recycledVbSeqnoMap *map[uint16]uint64
func (_e *UtilsIface_Expecter) GetHighSeqNos(vbnos interface{}, conn interface{}, stats_map interface{}, collectionIds interface{}, recycledVbSeqnoMap interface{}) *UtilsIface_GetHighSeqNos_Call {
	return &UtilsIface_GetHighSeqNos_Call{Call: _e.mock.On("GetHighSeqNos", vbnos, conn, stats_map, collectionIds, recycledVbSeqnoMap)}
}

func (_c *UtilsIface_GetHighSeqNos_Call) Run(run func(vbnos []uint16, conn memcached.ClientIface, stats_map *map[string]string, collectionIds []uint32, recycledVbSeqnoMap *map[uint16]uint64)) *UtilsIface_GetHighSeqNos_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]uint16), args[1].(memcached.ClientIface), args[2].(*map[string]string), args[3].([]uint32), args[4].(*map[uint16]uint64))
	})
	return _c
}

func (_c *UtilsIface_GetHighSeqNos_Call) Return(_a0 *map[uint16]uint64, _a1 *map[string]string, _a2 []uint16, _a3 error) *UtilsIface_GetHighSeqNos_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3)
	return _c
}

func (_c *UtilsIface_GetHighSeqNos_Call) RunAndReturn(run func([]uint16, memcached.ClientIface, *map[string]string, []uint32, *map[uint16]uint64) (*map[uint16]uint64, *map[string]string, []uint16, error)) *UtilsIface_GetHighSeqNos_Call {
	_c.Call.Return(run)
	return _c
}

// GetHostAddrFromNodeInfo provides a mock function with given fields: adminHostAddr, nodeInfo, isHttps, logger, useExternal
func (_m *UtilsIface) GetHostAddrFromNodeInfo(adminHostAddr string, nodeInfo map[string]interface{}, isHttps bool, logger *log.CommonLogger, useExternal bool) (string, error) {
	ret := _m.Called(adminHostAddr, nodeInfo, isHttps, logger, useExternal)

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(string, map[string]interface{}, bool, *log.CommonLogger, bool) (string, error)); ok {
		return rf(adminHostAddr, nodeInfo, isHttps, logger, useExternal)
	}
	if rf, ok := ret.Get(0).(func(string, map[string]interface{}, bool, *log.CommonLogger, bool) string); ok {
		r0 = rf(adminHostAddr, nodeInfo, isHttps, logger, useExternal)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string, map[string]interface{}, bool, *log.CommonLogger, bool) error); ok {
		r1 = rf(adminHostAddr, nodeInfo, isHttps, logger, useExternal)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UtilsIface_GetHostAddrFromNodeInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetHostAddrFromNodeInfo'
type UtilsIface_GetHostAddrFromNodeInfo_Call struct {
	*mock.Call
}

// GetHostAddrFromNodeInfo is a helper method to define mock.On call
//   - adminHostAddr string
//   - nodeInfo map[string]interface{}
//   - isHttps bool
//   - logger *log.CommonLogger
//   - useExternal bool
func (_e *UtilsIface_Expecter) GetHostAddrFromNodeInfo(adminHostAddr interface{}, nodeInfo interface{}, isHttps interface{}, logger interface{}, useExternal interface{}) *UtilsIface_GetHostAddrFromNodeInfo_Call {
	return &UtilsIface_GetHostAddrFromNodeInfo_Call{Call: _e.mock.On("GetHostAddrFromNodeInfo", adminHostAddr, nodeInfo, isHttps, logger, useExternal)}
}

func (_c *UtilsIface_GetHostAddrFromNodeInfo_Call) Run(run func(adminHostAddr string, nodeInfo map[string]interface{}, isHttps bool, logger *log.CommonLogger, useExternal bool)) *UtilsIface_GetHostAddrFromNodeInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(map[string]interface{}), args[2].(bool), args[3].(*log.CommonLogger), args[4].(bool))
	})
	return _c
}

func (_c *UtilsIface_GetHostAddrFromNodeInfo_Call) Return(_a0 string, _a1 error) *UtilsIface_GetHostAddrFromNodeInfo_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *UtilsIface_GetHostAddrFromNodeInfo_Call) RunAndReturn(run func(string, map[string]interface{}, bool, *log.CommonLogger, bool) (string, error)) *UtilsIface_GetHostAddrFromNodeInfo_Call {
	_c.Call.Return(run)
	return _c
}

// GetHostNameFromNodeInfo provides a mock function with given fields: adminHostAddr, nodeInfo, logger
func (_m *UtilsIface) GetHostNameFromNodeInfo(adminHostAddr string, nodeInfo map[string]interface{}, logger *log.CommonLogger) (string, error) {
	ret := _m.Called(adminHostAddr, nodeInfo, logger)

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(string, map[string]interface{}, *log.CommonLogger) (string, error)); ok {
		return rf(adminHostAddr, nodeInfo, logger)
	}
	if rf, ok := ret.Get(0).(func(string, map[string]interface{}, *log.CommonLogger) string); ok {
		r0 = rf(adminHostAddr, nodeInfo, logger)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string, map[string]interface{}, *log.CommonLogger) error); ok {
		r1 = rf(adminHostAddr, nodeInfo, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UtilsIface_GetHostNameFromNodeInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetHostNameFromNodeInfo'
type UtilsIface_GetHostNameFromNodeInfo_Call struct {
	*mock.Call
}

// GetHostNameFromNodeInfo is a helper method to define mock.On call
//   - adminHostAddr string
//   - nodeInfo map[string]interface{}
//   - logger *log.CommonLogger
func (_e *UtilsIface_Expecter) GetHostNameFromNodeInfo(adminHostAddr interface{}, nodeInfo interface{}, logger interface{}) *UtilsIface_GetHostNameFromNodeInfo_Call {
	return &UtilsIface_GetHostNameFromNodeInfo_Call{Call: _e.mock.On("GetHostNameFromNodeInfo", adminHostAddr, nodeInfo, logger)}
}

func (_c *UtilsIface_GetHostNameFromNodeInfo_Call) Run(run func(adminHostAddr string, nodeInfo map[string]interface{}, logger *log.CommonLogger)) *UtilsIface_GetHostNameFromNodeInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(map[string]interface{}), args[2].(*log.CommonLogger))
	})
	return _c
}

func (_c *UtilsIface_GetHostNameFromNodeInfo_Call) Return(_a0 string, _a1 error) *UtilsIface_GetHostNameFromNodeInfo_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *UtilsIface_GetHostNameFromNodeInfo_Call) RunAndReturn(run func(string, map[string]interface{}, *log.CommonLogger) (string, error)) *UtilsIface_GetHostNameFromNodeInfo_Call {
	_c.Call.Return(run)
	return _c
}

// GetHostNamesFromBucketInfo provides a mock function with given fields: bucketInfo
func (_m *UtilsIface) GetHostNamesFromBucketInfo(bucketInfo map[string]interface{}) ([]string, error) {
	ret := _m.Called(bucketInfo)

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(map[string]interface{}) ([]string, error)); ok {
		return rf(bucketInfo)
	}
	if rf, ok := ret.Get(0).(func(map[string]interface{}) []string); ok {
		r0 = rf(bucketInfo)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(map[string]interface{}) error); ok {
		r1 = rf(bucketInfo)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UtilsIface_GetHostNamesFromBucketInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetHostNamesFromBucketInfo'
type UtilsIface_GetHostNamesFromBucketInfo_Call struct {
	*mock.Call
}

// GetHostNamesFromBucketInfo is a helper method to define mock.On call
//   - bucketInfo map[string]interface{}
func (_e *UtilsIface_Expecter) GetHostNamesFromBucketInfo(bucketInfo interface{}) *UtilsIface_GetHostNamesFromBucketInfo_Call {
	return &UtilsIface_GetHostNamesFromBucketInfo_Call{Call: _e.mock.On("GetHostNamesFromBucketInfo", bucketInfo)}
}

func (_c *UtilsIface_GetHostNamesFromBucketInfo_Call) Run(run func(bucketInfo map[string]interface{})) *UtilsIface_GetHostNamesFromBucketInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(map[string]interface{}))
	})
	return _c
}

func (_c *UtilsIface_GetHostNamesFromBucketInfo_Call) Return(_a0 []string, _a1 error) *UtilsIface_GetHostNamesFromBucketInfo_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *UtilsIface_GetHostNamesFromBucketInfo_Call) RunAndReturn(run func(map[string]interface{}) ([]string, error)) *UtilsIface_GetHostNamesFromBucketInfo_Call {
	_c.Call.Return(run)
	return _c
}

// GetHttpClient provides a mock function with given fields: username, authMech, certificate, san_in_certificate, clientCertificate, clientKey, ssl_con_str, logger
func (_m *UtilsIface) GetHttpClient(username string, authMech base.HttpAuthMech, certificate []byte, san_in_certificate bool, clientCertificate []byte, clientKey []byte, ssl_con_str string, logger *log.CommonLogger) (*http.Client, error) {
	ret := _m.Called(username, authMech, certificate, san_in_certificate, clientCertificate, clientKey, ssl_con_str, logger)

	var r0 *http.Client
	var r1 error
	if rf, ok := ret.Get(0).(func(string, base.HttpAuthMech, []byte, bool, []byte, []byte, string, *log.CommonLogger) (*http.Client, error)); ok {
		return rf(username, authMech, certificate, san_in_certificate, clientCertificate, clientKey, ssl_con_str, logger)
	}
	if rf, ok := ret.Get(0).(func(string, base.HttpAuthMech, []byte, bool, []byte, []byte, string, *log.CommonLogger) *http.Client); ok {
		r0 = rf(username, authMech, certificate, san_in_certificate, clientCertificate, clientKey, ssl_con_str, logger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Client)
		}
	}

	if rf, ok := ret.Get(1).(func(string, base.HttpAuthMech, []byte, bool, []byte, []byte, string, *log.CommonLogger) error); ok {
		r1 = rf(username, authMech, certificate, san_in_certificate, clientCertificate, clientKey, ssl_con_str, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UtilsIface_GetHttpClient_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetHttpClient'
type UtilsIface_GetHttpClient_Call struct {
	*mock.Call
}

// GetHttpClient is a helper method to define mock.On call
//   - username string
//   - authMech base.HttpAuthMech
//   - certificate []byte
//   - san_in_certificate bool
//   - clientCertificate []byte
//   - clientKey []byte
//   - ssl_con_str string
//   - logger *log.CommonLogger
func (_e *UtilsIface_Expecter) GetHttpClient(username interface{}, authMech interface{}, certificate interface{}, san_in_certificate interface{}, clientCertificate interface{}, clientKey interface{}, ssl_con_str interface{}, logger interface{}) *UtilsIface_GetHttpClient_Call {
	return &UtilsIface_GetHttpClient_Call{Call: _e.mock.On("GetHttpClient", username, authMech, certificate, san_in_certificate, clientCertificate, clientKey, ssl_con_str, logger)}
}

func (_c *UtilsIface_GetHttpClient_Call) Run(run func(username string, authMech base.HttpAuthMech, certificate []byte, san_in_certificate bool, clientCertificate []byte, clientKey []byte, ssl_con_str string, logger *log.CommonLogger)) *UtilsIface_GetHttpClient_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(base.HttpAuthMech), args[2].([]byte), args[3].(bool), args[4].([]byte), args[5].([]byte), args[6].(string), args[7].(*log.CommonLogger))
	})
	return _c
}

func (_c *UtilsIface_GetHttpClient_Call) Return(_a0 *http.Client, _a1 error) *UtilsIface_GetHttpClient_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *UtilsIface_GetHttpClient_Call) RunAndReturn(run func(string, base.HttpAuthMech, []byte, bool, []byte, []byte, string, *log.CommonLogger) (*http.Client, error)) *UtilsIface_GetHttpClient_Call {
	_c.Call.Return(run)
	return _c
}

// GetHttpsMgtPortFromNodeInfo provides a mock function with given fields: nodeInfo
func (_m *UtilsIface) GetHttpsMgtPortFromNodeInfo(nodeInfo map[string]interface{}) (int, error) {
	ret := _m.Called(nodeInfo)

	var r0 int
	var r1 error
	if rf, ok := ret.Get(0).(func(map[string]interface{}) (int, error)); ok {
		return rf(nodeInfo)
	}
	if rf, ok := ret.Get(0).(func(map[string]interface{}) int); ok {
		r0 = rf(nodeInfo)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func(map[string]interface{}) error); ok {
		r1 = rf(nodeInfo)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UtilsIface_GetHttpsMgtPortFromNodeInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetHttpsMgtPortFromNodeInfo'
type UtilsIface_GetHttpsMgtPortFromNodeInfo_Call struct {
	*mock.Call
}

// GetHttpsMgtPortFromNodeInfo is a helper method to define mock.On call
//   - nodeInfo map[string]interface{}
func (_e *UtilsIface_Expecter) GetHttpsMgtPortFromNodeInfo(nodeInfo interface{}) *UtilsIface_GetHttpsMgtPortFromNodeInfo_Call {
	return &UtilsIface_GetHttpsMgtPortFromNodeInfo_Call{Call: _e.mock.On("GetHttpsMgtPortFromNodeInfo", nodeInfo)}
}

func (_c *UtilsIface_GetHttpsMgtPortFromNodeInfo_Call) Run(run func(nodeInfo map[string]interface{})) *UtilsIface_GetHttpsMgtPortFromNodeInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(map[string]interface{}))
	})
	return _c
}

func (_c *UtilsIface_GetHttpsMgtPortFromNodeInfo_Call) Return(_a0 int, _a1 error) *UtilsIface_GetHttpsMgtPortFromNodeInfo_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *UtilsIface_GetHttpsMgtPortFromNodeInfo_Call) RunAndReturn(run func(map[string]interface{}) (int, error)) *UtilsIface_GetHttpsMgtPortFromNodeInfo_Call {
	_c.Call.Return(run)
	return _c
}

// GetIntExtHostNameKVPortTranslationMap provides a mock function with given fields: mapContainingNodesKey
func (_m *UtilsIface) GetIntExtHostNameKVPortTranslationMap(mapContainingNodesKey map[string]interface{}) (map[string]string, error) {
	ret := _m.Called(mapContainingNodesKey)

	var r0 map[string]string
	var r1 error
	if rf, ok := ret.Get(0).(func(map[string]interface{}) (map[string]string, error)); ok {
		return rf(mapContainingNodesKey)
	}
	if rf, ok := ret.Get(0).(func(map[string]interface{}) map[string]string); ok {
		r0 = rf(mapContainingNodesKey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]string)
		}
	}

	if rf, ok := ret.Get(1).(func(map[string]interface{}) error); ok {
		r1 = rf(mapContainingNodesKey)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UtilsIface_GetIntExtHostNameKVPortTranslationMap_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetIntExtHostNameKVPortTranslationMap'
type UtilsIface_GetIntExtHostNameKVPortTranslationMap_Call struct {
	*mock.Call
}

// GetIntExtHostNameKVPortTranslationMap is a helper method to define mock.On call
//   - mapContainingNodesKey map[string]interface{}
func (_e *UtilsIface_Expecter) GetIntExtHostNameKVPortTranslationMap(mapContainingNodesKey interface{}) *UtilsIface_GetIntExtHostNameKVPortTranslationMap_Call {
	return &UtilsIface_GetIntExtHostNameKVPortTranslationMap_Call{Call: _e.mock.On("GetIntExtHostNameKVPortTranslationMap", mapContainingNodesKey)}
}

func (_c *UtilsIface_GetIntExtHostNameKVPortTranslationMap_Call) Run(run func(mapContainingNodesKey map[string]interface{})) *UtilsIface_GetIntExtHostNameKVPortTranslationMap_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(map[string]interface{}))
	})
	return _c
}

func (_c *UtilsIface_GetIntExtHostNameKVPortTranslationMap_Call) Return(_a0 map[string]string, _a1 error) *UtilsIface_GetIntExtHostNameKVPortTranslationMap_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *UtilsIface_GetIntExtHostNameKVPortTranslationMap_Call) RunAndReturn(run func(map[string]interface{}) (map[string]string, error)) *UtilsIface_GetIntExtHostNameKVPortTranslationMap_Call {
	_c.Call.Return(run)
	return _c
}

// GetIntSettingFromSettings provides a mock function with given fields: settings, settingName
func (_m *UtilsIface) GetIntSettingFromSettings(settings metadata.ReplicationSettingsMap, settingName string) (int, error) {
	ret := _m.Called(settings, settingName)

	var r0 int
	var r1 error
	if rf, ok := ret.Get(0).(func(metadata.ReplicationSettingsMap, string) (int, error)); ok {
		return rf(settings, settingName)
	}
	if rf, ok := ret.Get(0).(func(metadata.ReplicationSettingsMap, string) int); ok {
		r0 = rf(settings, settingName)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func(metadata.ReplicationSettingsMap, string) error); ok {
		r1 = rf(settings, settingName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UtilsIface_GetIntSettingFromSettings_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetIntSettingFromSettings'
type UtilsIface_GetIntSettingFromSettings_Call struct {
	*mock.Call
}

// GetIntSettingFromSettings is a helper method to define mock.On call
//   - settings metadata.ReplicationSettingsMap
//   - settingName string
func (_e *UtilsIface_Expecter) GetIntSettingFromSettings(settings interface{}, settingName interface{}) *UtilsIface_GetIntSettingFromSettings_Call {
	return &UtilsIface_GetIntSettingFromSettings_Call{Call: _e.mock.On("GetIntSettingFromSettings", settings, settingName)}
}

func (_c *UtilsIface_GetIntSettingFromSettings_Call) Run(run func(settings metadata.ReplicationSettingsMap, settingName string)) *UtilsIface_GetIntSettingFromSettings_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(metadata.ReplicationSettingsMap), args[1].(string))
	})
	return _c
}

func (_c *UtilsIface_GetIntSettingFromSettings_Call) Return(_a0 int, _a1 error) *UtilsIface_GetIntSettingFromSettings_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *UtilsIface_GetIntSettingFromSettings_Call) RunAndReturn(run func(metadata.ReplicationSettingsMap, string) (int, error)) *UtilsIface_GetIntSettingFromSettings_Call {
	_c.Call.Return(run)
	return _c
}

// GetLocalBuckets provides a mock function with given fields: hostAddr, logger
func (_m *UtilsIface) GetLocalBuckets(hostAddr string, logger *log.CommonLogger) (map[string]string, error) {
	ret := _m.Called(hostAddr, logger)

	var r0 map[string]string
	var r1 error
	if rf, ok := ret.Get(0).(func(string, *log.CommonLogger) (map[string]string, error)); ok {
		return rf(hostAddr, logger)
	}
	if rf, ok := ret.Get(0).(func(string, *log.CommonLogger) map[string]string); ok {
		r0 = rf(hostAddr, logger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]string)
		}
	}

	if rf, ok := ret.Get(1).(func(string, *log.CommonLogger) error); ok {
		r1 = rf(hostAddr, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UtilsIface_GetLocalBuckets_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLocalBuckets'
type UtilsIface_GetLocalBuckets_Call struct {
	*mock.Call
}

// GetLocalBuckets is a helper method to define mock.On call
//   - hostAddr string
//   - logger *log.CommonLogger
func (_e *UtilsIface_Expecter) GetLocalBuckets(hostAddr interface{}, logger interface{}) *UtilsIface_GetLocalBuckets_Call {
	return &UtilsIface_GetLocalBuckets_Call{Call: _e.mock.On("GetLocalBuckets", hostAddr, logger)}
}

func (_c *UtilsIface_GetLocalBuckets_Call) Run(run func(hostAddr string, logger *log.CommonLogger)) *UtilsIface_GetLocalBuckets_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(*log.CommonLogger))
	})
	return _c
}

func (_c *UtilsIface_GetLocalBuckets_Call) Return(_a0 map[string]string, _a1 error) *UtilsIface_GetLocalBuckets_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *UtilsIface_GetLocalBuckets_Call) RunAndReturn(run func(string, *log.CommonLogger) (map[string]string, error)) *UtilsIface_GetLocalBuckets_Call {
	_c.Call.Return(run)
	return _c
}

// GetMapFromExpvarMap provides a mock function with given fields: expvarMap
func (_m *UtilsIface) GetMapFromExpvarMap(expvarMap *expvar.Map) map[string]interface{} {
	ret := _m.Called(expvarMap)

	var r0 map[string]interface{}
	if rf, ok := ret.Get(0).(func(*expvar.Map) map[string]interface{}); ok {
		r0 = rf(expvarMap)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]interface{})
		}
	}

	return r0
}

// UtilsIface_GetMapFromExpvarMap_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMapFromExpvarMap'
type UtilsIface_GetMapFromExpvarMap_Call struct {
	*mock.Call
}

// GetMapFromExpvarMap is a helper method to define mock.On call
//   - expvarMap *expvar.Map
func (_e *UtilsIface_Expecter) GetMapFromExpvarMap(expvarMap interface{}) *UtilsIface_GetMapFromExpvarMap_Call {
	return &UtilsIface_GetMapFromExpvarMap_Call{Call: _e.mock.On("GetMapFromExpvarMap", expvarMap)}
}

func (_c *UtilsIface_GetMapFromExpvarMap_Call) Run(run func(expvarMap *expvar.Map)) *UtilsIface_GetMapFromExpvarMap_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*expvar.Map))
	})
	return _c
}

func (_c *UtilsIface_GetMapFromExpvarMap_Call) Return(_a0 map[string]interface{}) *UtilsIface_GetMapFromExpvarMap_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *UtilsIface_GetMapFromExpvarMap_Call) RunAndReturn(run func(*expvar.Map) map[string]interface{}) *UtilsIface_GetMapFromExpvarMap_Call {
	_c.Call.Return(run)
	return _c
}

// GetMemcachedClient provides a mock function with given fields: serverAddr, bucketName, kv_mem_clients, userAgent, keepAlivePeriod, logger, features
func (_m *UtilsIface) GetMemcachedClient(serverAddr string, bucketName string, kv_mem_clients map[string]memcached.ClientIface, userAgent string, keepAlivePeriod time.Duration, logger *log.CommonLogger, features utils.HELOFeatures) (memcached.ClientIface, error) {
	ret := _m.Called(serverAddr, bucketName, kv_mem_clients, userAgent, keepAlivePeriod, logger, features)

	var r0 memcached.ClientIface
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, map[string]memcached.ClientIface, string, time.Duration, *log.CommonLogger, utils.HELOFeatures) (memcached.ClientIface, error)); ok {
		return rf(serverAddr, bucketName, kv_mem_clients, userAgent, keepAlivePeriod, logger, features)
	}
	if rf, ok := ret.Get(0).(func(string, string, map[string]memcached.ClientIface, string, time.Duration, *log.CommonLogger, utils.HELOFeatures) memcached.ClientIface); ok {
		r0 = rf(serverAddr, bucketName, kv_mem_clients, userAgent, keepAlivePeriod, logger, features)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(memcached.ClientIface)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, map[string]memcached.ClientIface, string, time.Duration, *log.CommonLogger, utils.HELOFeatures) error); ok {
		r1 = rf(serverAddr, bucketName, kv_mem_clients, userAgent, keepAlivePeriod, logger, features)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UtilsIface_GetMemcachedClient_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMemcachedClient'
type UtilsIface_GetMemcachedClient_Call struct {
	*mock.Call
}

// GetMemcachedClient is a helper method to define mock.On call
//   - serverAddr string
//   - bucketName string
//   - kv_mem_clients map[string]memcached.ClientIface
//   - userAgent string
//   - keepAlivePeriod time.Duration
//   - logger *log.CommonLogger
//   - features utils.HELOFeatures
func (_e *UtilsIface_Expecter) GetMemcachedClient(serverAddr interface{}, bucketName interface{}, kv_mem_clients interface{}, userAgent interface{}, keepAlivePeriod interface{}, logger interface{}, features interface{}) *UtilsIface_GetMemcachedClient_Call {
	return &UtilsIface_GetMemcachedClient_Call{Call: _e.mock.On("GetMemcachedClient", serverAddr, bucketName, kv_mem_clients, userAgent, keepAlivePeriod, logger, features)}
}

func (_c *UtilsIface_GetMemcachedClient_Call) Run(run func(serverAddr string, bucketName string, kv_mem_clients map[string]memcached.ClientIface, userAgent string, keepAlivePeriod time.Duration, logger *log.CommonLogger, features utils.HELOFeatures)) *UtilsIface_GetMemcachedClient_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].(map[string]memcached.ClientIface), args[3].(string), args[4].(time.Duration), args[5].(*log.CommonLogger), args[6].(utils.HELOFeatures))
	})
	return _c
}

func (_c *UtilsIface_GetMemcachedClient_Call) Return(_a0 memcached.ClientIface, _a1 error) *UtilsIface_GetMemcachedClient_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *UtilsIface_GetMemcachedClient_Call) RunAndReturn(run func(string, string, map[string]memcached.ClientIface, string, time.Duration, *log.CommonLogger, utils.HELOFeatures) (memcached.ClientIface, error)) *UtilsIface_GetMemcachedClient_Call {
	_c.Call.Return(run)
	return _c
}

// GetMemcachedConnection provides a mock function with given fields: serverAddr, bucketName, userAgent, keepAlivePeriod, logger
func (_m *UtilsIface) GetMemcachedConnection(serverAddr string, bucketName string, userAgent string, keepAlivePeriod time.Duration, logger *log.CommonLogger) (memcached.ClientIface, error) {
	ret := _m.Called(serverAddr, bucketName, userAgent, keepAlivePeriod, logger)

	var r0 memcached.ClientIface
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, string, time.Duration, *log.CommonLogger) (memcached.ClientIface, error)); ok {
		return rf(serverAddr, bucketName, userAgent, keepAlivePeriod, logger)
	}
	if rf, ok := ret.Get(0).(func(string, string, string, time.Duration, *log.CommonLogger) memcached.ClientIface); ok {
		r0 = rf(serverAddr, bucketName, userAgent, keepAlivePeriod, logger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(memcached.ClientIface)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, string, time.Duration, *log.CommonLogger) error); ok {
		r1 = rf(serverAddr, bucketName, userAgent, keepAlivePeriod, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UtilsIface_GetMemcachedConnection_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMemcachedConnection'
type UtilsIface_GetMemcachedConnection_Call struct {
	*mock.Call
}

// GetMemcachedConnection is a helper method to define mock.On call
//   - serverAddr string
//   - bucketName string
//   - userAgent string
//   - keepAlivePeriod time.Duration
//   - logger *log.CommonLogger
func (_e *UtilsIface_Expecter) GetMemcachedConnection(serverAddr interface{}, bucketName interface{}, userAgent interface{}, keepAlivePeriod interface{}, logger interface{}) *UtilsIface_GetMemcachedConnection_Call {
	return &UtilsIface_GetMemcachedConnection_Call{Call: _e.mock.On("GetMemcachedConnection", serverAddr, bucketName, userAgent, keepAlivePeriod, logger)}
}

func (_c *UtilsIface_GetMemcachedConnection_Call) Run(run func(serverAddr string, bucketName string, userAgent string, keepAlivePeriod time.Duration, logger *log.CommonLogger)) *UtilsIface_GetMemcachedConnection_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].(string), args[3].(time.Duration), args[4].(*log.CommonLogger))
	})
	return _c
}

func (_c *UtilsIface_GetMemcachedConnection_Call) Return(_a0 memcached.ClientIface, _a1 error) *UtilsIface_GetMemcachedConnection_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *UtilsIface_GetMemcachedConnection_Call) RunAndReturn(run func(string, string, string, time.Duration, *log.CommonLogger) (memcached.ClientIface, error)) *UtilsIface_GetMemcachedConnection_Call {
	_c.Call.Return(run)
	return _c
}

// GetMemcachedConnectionWFeatures provides a mock function with given fields: serverAddr, bucketName, userAgent, keepAlivePeriod, features, logger
func (_m *UtilsIface) GetMemcachedConnectionWFeatures(serverAddr string, bucketName string, userAgent string, keepAlivePeriod time.Duration, features utils.HELOFeatures, logger *log.CommonLogger) (memcached.ClientIface, utils.HELOFeatures, error) {
	ret := _m.Called(serverAddr, bucketName, userAgent, keepAlivePeriod, features, logger)

	var r0 memcached.ClientIface
	var r1 utils.HELOFeatures
	var r2 error
	if rf, ok := ret.Get(0).(func(string, string, string, time.Duration, utils.HELOFeatures, *log.CommonLogger) (memcached.ClientIface, utils.HELOFeatures, error)); ok {
		return rf(serverAddr, bucketName, userAgent, keepAlivePeriod, features, logger)
	}
	if rf, ok := ret.Get(0).(func(string, string, string, time.Duration, utils.HELOFeatures, *log.CommonLogger) memcached.ClientIface); ok {
		r0 = rf(serverAddr, bucketName, userAgent, keepAlivePeriod, features, logger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(memcached.ClientIface)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, string, time.Duration, utils.HELOFeatures, *log.CommonLogger) utils.HELOFeatures); ok {
		r1 = rf(serverAddr, bucketName, userAgent, keepAlivePeriod, features, logger)
	} else {
		r1 = ret.Get(1).(utils.HELOFeatures)
	}

	if rf, ok := ret.Get(2).(func(string, string, string, time.Duration, utils.HELOFeatures, *log.CommonLogger) error); ok {
		r2 = rf(serverAddr, bucketName, userAgent, keepAlivePeriod, features, logger)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// UtilsIface_GetMemcachedConnectionWFeatures_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMemcachedConnectionWFeatures'
type UtilsIface_GetMemcachedConnectionWFeatures_Call struct {
	*mock.Call
}

// GetMemcachedConnectionWFeatures is a helper method to define mock.On call
//   - serverAddr string
//   - bucketName string
//   - userAgent string
//   - keepAlivePeriod time.Duration
//   - features utils.HELOFeatures
//   - logger *log.CommonLogger
func (_e *UtilsIface_Expecter) GetMemcachedConnectionWFeatures(serverAddr interface{}, bucketName interface{}, userAgent interface{}, keepAlivePeriod interface{}, features interface{}, logger interface{}) *UtilsIface_GetMemcachedConnectionWFeatures_Call {
	return &UtilsIface_GetMemcachedConnectionWFeatures_Call{Call: _e.mock.On("GetMemcachedConnectionWFeatures", serverAddr, bucketName, userAgent, keepAlivePeriod, features, logger)}
}

func (_c *UtilsIface_GetMemcachedConnectionWFeatures_Call) Run(run func(serverAddr string, bucketName string, userAgent string, keepAlivePeriod time.Duration, features utils.HELOFeatures, logger *log.CommonLogger)) *UtilsIface_GetMemcachedConnectionWFeatures_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].(string), args[3].(time.Duration), args[4].(utils.HELOFeatures), args[5].(*log.CommonLogger))
	})
	return _c
}

func (_c *UtilsIface_GetMemcachedConnectionWFeatures_Call) Return(_a0 memcached.ClientIface, _a1 utils.HELOFeatures, _a2 error) *UtilsIface_GetMemcachedConnectionWFeatures_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *UtilsIface_GetMemcachedConnectionWFeatures_Call) RunAndReturn(run func(string, string, string, time.Duration, utils.HELOFeatures, *log.CommonLogger) (memcached.ClientIface, utils.HELOFeatures, error)) *UtilsIface_GetMemcachedConnectionWFeatures_Call {
	_c.Call.Return(run)
	return _c
}

// GetMemcachedRawConn provides a mock function with given fields: serverAddr, username, password, bucketName, plainAuth, keepAlivePeriod, logger
func (_m *UtilsIface) GetMemcachedRawConn(serverAddr string, username string, password string, bucketName string, plainAuth bool, keepAlivePeriod time.Duration, logger *log.CommonLogger) (memcached.ClientIface, error) {
	ret := _m.Called(serverAddr, username, password, bucketName, plainAuth, keepAlivePeriod, logger)

	var r0 memcached.ClientIface
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, string, string, bool, time.Duration, *log.CommonLogger) (memcached.ClientIface, error)); ok {
		return rf(serverAddr, username, password, bucketName, plainAuth, keepAlivePeriod, logger)
	}
	if rf, ok := ret.Get(0).(func(string, string, string, string, bool, time.Duration, *log.CommonLogger) memcached.ClientIface); ok {
		r0 = rf(serverAddr, username, password, bucketName, plainAuth, keepAlivePeriod, logger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(memcached.ClientIface)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, string, string, bool, time.Duration, *log.CommonLogger) error); ok {
		r1 = rf(serverAddr, username, password, bucketName, plainAuth, keepAlivePeriod, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UtilsIface_GetMemcachedRawConn_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMemcachedRawConn'
type UtilsIface_GetMemcachedRawConn_Call struct {
	*mock.Call
}

// GetMemcachedRawConn is a helper method to define mock.On call
//   - serverAddr string
//   - username string
//   - password string
//   - bucketName string
//   - plainAuth bool
//   - keepAlivePeriod time.Duration
//   - logger *log.CommonLogger
func (_e *UtilsIface_Expecter) GetMemcachedRawConn(serverAddr interface{}, username interface{}, password interface{}, bucketName interface{}, plainAuth interface{}, keepAlivePeriod interface{}, logger interface{}) *UtilsIface_GetMemcachedRawConn_Call {
	return &UtilsIface_GetMemcachedRawConn_Call{Call: _e.mock.On("GetMemcachedRawConn", serverAddr, username, password, bucketName, plainAuth, keepAlivePeriod, logger)}
}

func (_c *UtilsIface_GetMemcachedRawConn_Call) Run(run func(serverAddr string, username string, password string, bucketName string, plainAuth bool, keepAlivePeriod time.Duration, logger *log.CommonLogger)) *UtilsIface_GetMemcachedRawConn_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].(string), args[3].(string), args[4].(bool), args[5].(time.Duration), args[6].(*log.CommonLogger))
	})
	return _c
}

func (_c *UtilsIface_GetMemcachedRawConn_Call) Return(_a0 memcached.ClientIface, _a1 error) *UtilsIface_GetMemcachedRawConn_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *UtilsIface_GetMemcachedRawConn_Call) RunAndReturn(run func(string, string, string, string, bool, time.Duration, *log.CommonLogger) (memcached.ClientIface, error)) *UtilsIface_GetMemcachedRawConn_Call {
	_c.Call.Return(run)
	return _c
}

// GetMemcachedSSLPortMap provides a mock function with given fields: hostName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, bucket, logger, useExternal
func (_m *UtilsIface) GetMemcachedSSLPortMap(hostName string, username string, password string, authMech base.HttpAuthMech, certificate []byte, sanInCertificate bool, clientCertificate []byte, clientKey []byte, bucket string, logger *log.CommonLogger, useExternal bool) (base.SSLPortMap, error) {
	ret := _m.Called(hostName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, bucket, logger, useExternal)

	var r0 base.SSLPortMap
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, string, *log.CommonLogger, bool) (base.SSLPortMap, error)); ok {
		return rf(hostName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, bucket, logger, useExternal)
	}
	if rf, ok := ret.Get(0).(func(string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, string, *log.CommonLogger, bool) base.SSLPortMap); ok {
		r0 = rf(hostName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, bucket, logger, useExternal)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(base.SSLPortMap)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, string, *log.CommonLogger, bool) error); ok {
		r1 = rf(hostName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, bucket, logger, useExternal)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UtilsIface_GetMemcachedSSLPortMap_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMemcachedSSLPortMap'
type UtilsIface_GetMemcachedSSLPortMap_Call struct {
	*mock.Call
}

// GetMemcachedSSLPortMap is a helper method to define mock.On call
//   - hostName string
//   - username string
//   - password string
//   - authMech base.HttpAuthMech
//   - certificate []byte
//   - sanInCertificate bool
//   - clientCertificate []byte
//   - clientKey []byte
//   - bucket string
//   - logger *log.CommonLogger
//   - useExternal bool
func (_e *UtilsIface_Expecter) GetMemcachedSSLPortMap(hostName interface{}, username interface{}, password interface{}, authMech interface{}, certificate interface{}, sanInCertificate interface{}, clientCertificate interface{}, clientKey interface{}, bucket interface{}, logger interface{}, useExternal interface{}) *UtilsIface_GetMemcachedSSLPortMap_Call {
	return &UtilsIface_GetMemcachedSSLPortMap_Call{Call: _e.mock.On("GetMemcachedSSLPortMap", hostName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, bucket, logger, useExternal)}
}

func (_c *UtilsIface_GetMemcachedSSLPortMap_Call) Run(run func(hostName string, username string, password string, authMech base.HttpAuthMech, certificate []byte, sanInCertificate bool, clientCertificate []byte, clientKey []byte, bucket string, logger *log.CommonLogger, useExternal bool)) *UtilsIface_GetMemcachedSSLPortMap_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].(string), args[3].(base.HttpAuthMech), args[4].([]byte), args[5].(bool), args[6].([]byte), args[7].([]byte), args[8].(string), args[9].(*log.CommonLogger), args[10].(bool))
	})
	return _c
}

func (_c *UtilsIface_GetMemcachedSSLPortMap_Call) Return(_a0 base.SSLPortMap, _a1 error) *UtilsIface_GetMemcachedSSLPortMap_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *UtilsIface_GetMemcachedSSLPortMap_Call) RunAndReturn(run func(string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, string, *log.CommonLogger, bool) (base.SSLPortMap, error)) *UtilsIface_GetMemcachedSSLPortMap_Call {
	_c.Call.Return(run)
	return _c
}

// GetNodeListFromInfoMap provides a mock function with given fields: infoMap, logger
func (_m *UtilsIface) GetNodeListFromInfoMap(infoMap map[string]interface{}, logger *log.CommonLogger) ([]interface{}, error) {
	ret := _m.Called(infoMap, logger)

	var r0 []interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(map[string]interface{}, *log.CommonLogger) ([]interface{}, error)); ok {
		return rf(infoMap, logger)
	}
	if rf, ok := ret.Get(0).(func(map[string]interface{}, *log.CommonLogger) []interface{}); ok {
		r0 = rf(infoMap, logger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(map[string]interface{}, *log.CommonLogger) error); ok {
		r1 = rf(infoMap, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UtilsIface_GetNodeListFromInfoMap_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetNodeListFromInfoMap'
type UtilsIface_GetNodeListFromInfoMap_Call struct {
	*mock.Call
}

// GetNodeListFromInfoMap is a helper method to define mock.On call
//   - infoMap map[string]interface{}
//   - logger *log.CommonLogger
func (_e *UtilsIface_Expecter) GetNodeListFromInfoMap(infoMap interface{}, logger interface{}) *UtilsIface_GetNodeListFromInfoMap_Call {
	return &UtilsIface_GetNodeListFromInfoMap_Call{Call: _e.mock.On("GetNodeListFromInfoMap", infoMap, logger)}
}

func (_c *UtilsIface_GetNodeListFromInfoMap_Call) Run(run func(infoMap map[string]interface{}, logger *log.CommonLogger)) *UtilsIface_GetNodeListFromInfoMap_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(map[string]interface{}), args[1].(*log.CommonLogger))
	})
	return _c
}

func (_c *UtilsIface_GetNodeListFromInfoMap_Call) Return(_a0 []interface{}, _a1 error) *UtilsIface_GetNodeListFromInfoMap_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *UtilsIface_GetNodeListFromInfoMap_Call) RunAndReturn(run func(map[string]interface{}, *log.CommonLogger) ([]interface{}, error)) *UtilsIface_GetNodeListFromInfoMap_Call {
	_c.Call.Return(run)
	return _c
}

// GetNodeListWithMinInfo provides a mock function with given fields: hostAddr, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger
func (_m *UtilsIface) GetNodeListWithMinInfo(hostAddr string, username string, password string, authMech base.HttpAuthMech, certificate []byte, sanInCertificate bool, clientCertificate []byte, clientKey []byte, logger *log.CommonLogger) ([]interface{}, error) {
	ret := _m.Called(hostAddr, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)

	var r0 []interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) ([]interface{}, error)); ok {
		return rf(hostAddr, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	}
	if rf, ok := ret.Get(0).(func(string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) []interface{}); ok {
		r0 = rf(hostAddr, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) error); ok {
		r1 = rf(hostAddr, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UtilsIface_GetNodeListWithMinInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetNodeListWithMinInfo'
type UtilsIface_GetNodeListWithMinInfo_Call struct {
	*mock.Call
}

// GetNodeListWithMinInfo is a helper method to define mock.On call
//   - hostAddr string
//   - username string
//   - password string
//   - authMech base.HttpAuthMech
//   - certificate []byte
//   - sanInCertificate bool
//   - clientCertificate []byte
//   - clientKey []byte
//   - logger *log.CommonLogger
func (_e *UtilsIface_Expecter) GetNodeListWithMinInfo(hostAddr interface{}, username interface{}, password interface{}, authMech interface{}, certificate interface{}, sanInCertificate interface{}, clientCertificate interface{}, clientKey interface{}, logger interface{}) *UtilsIface_GetNodeListWithMinInfo_Call {
	return &UtilsIface_GetNodeListWithMinInfo_Call{Call: _e.mock.On("GetNodeListWithMinInfo", hostAddr, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)}
}

func (_c *UtilsIface_GetNodeListWithMinInfo_Call) Run(run func(hostAddr string, username string, password string, authMech base.HttpAuthMech, certificate []byte, sanInCertificate bool, clientCertificate []byte, clientKey []byte, logger *log.CommonLogger)) *UtilsIface_GetNodeListWithMinInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].(string), args[3].(base.HttpAuthMech), args[4].([]byte), args[5].(bool), args[6].([]byte), args[7].([]byte), args[8].(*log.CommonLogger))
	})
	return _c
}

func (_c *UtilsIface_GetNodeListWithMinInfo_Call) Return(_a0 []interface{}, _a1 error) *UtilsIface_GetNodeListWithMinInfo_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *UtilsIface_GetNodeListWithMinInfo_Call) RunAndReturn(run func(string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) ([]interface{}, error)) *UtilsIface_GetNodeListWithMinInfo_Call {
	_c.Call.Return(run)
	return _c
}

// GetNodeServicesInfo provides a mock function with given fields: hostAddr, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger
func (_m *UtilsIface) GetNodeServicesInfo(hostAddr string, username string, password string, authMech base.HttpAuthMech, certificate []byte, sanInCertificate bool, clientCertificate []byte, clientKey []byte, logger *log.CommonLogger) (map[string]interface{}, error) {
	ret := _m.Called(hostAddr, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)

	var r0 map[string]interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) (map[string]interface{}, error)); ok {
		return rf(hostAddr, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	}
	if rf, ok := ret.Get(0).(func(string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) map[string]interface{}); ok {
		r0 = rf(hostAddr, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) error); ok {
		r1 = rf(hostAddr, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UtilsIface_GetNodeServicesInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetNodeServicesInfo'
type UtilsIface_GetNodeServicesInfo_Call struct {
	*mock.Call
}

// GetNodeServicesInfo is a helper method to define mock.On call
//   - hostAddr string
//   - username string
//   - password string
//   - authMech base.HttpAuthMech
//   - certificate []byte
//   - sanInCertificate bool
//   - clientCertificate []byte
//   - clientKey []byte
//   - logger *log.CommonLogger
func (_e *UtilsIface_Expecter) GetNodeServicesInfo(hostAddr interface{}, username interface{}, password interface{}, authMech interface{}, certificate interface{}, sanInCertificate interface{}, clientCertificate interface{}, clientKey interface{}, logger interface{}) *UtilsIface_GetNodeServicesInfo_Call {
	return &UtilsIface_GetNodeServicesInfo_Call{Call: _e.mock.On("GetNodeServicesInfo", hostAddr, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)}
}

func (_c *UtilsIface_GetNodeServicesInfo_Call) Run(run func(hostAddr string, username string, password string, authMech base.HttpAuthMech, certificate []byte, sanInCertificate bool, clientCertificate []byte, clientKey []byte, logger *log.CommonLogger)) *UtilsIface_GetNodeServicesInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].(string), args[3].(base.HttpAuthMech), args[4].([]byte), args[5].(bool), args[6].([]byte), args[7].([]byte), args[8].(*log.CommonLogger))
	})
	return _c
}

func (_c *UtilsIface_GetNodeServicesInfo_Call) Return(_a0 map[string]interface{}, _a1 error) *UtilsIface_GetNodeServicesInfo_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *UtilsIface_GetNodeServicesInfo_Call) RunAndReturn(run func(string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) (map[string]interface{}, error)) *UtilsIface_GetNodeServicesInfo_Call {
	_c.Call.Return(run)
	return _c
}

// GetNonExistentBucketError provides a mock function with given fields:
func (_m *UtilsIface) GetNonExistentBucketError() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UtilsIface_GetNonExistentBucketError_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetNonExistentBucketError'
type UtilsIface_GetNonExistentBucketError_Call struct {
	*mock.Call
}

// GetNonExistentBucketError is a helper method to define mock.On call
func (_e *UtilsIface_Expecter) GetNonExistentBucketError() *UtilsIface_GetNonExistentBucketError_Call {
	return &UtilsIface_GetNonExistentBucketError_Call{Call: _e.mock.On("GetNonExistentBucketError")}
}

func (_c *UtilsIface_GetNonExistentBucketError_Call) Run(run func()) *UtilsIface_GetNonExistentBucketError_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *UtilsIface_GetNonExistentBucketError_Call) Return(_a0 error) *UtilsIface_GetNonExistentBucketError_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *UtilsIface_GetNonExistentBucketError_Call) RunAndReturn(run func() error) *UtilsIface_GetNonExistentBucketError_Call {
	_c.Call.Return(run)
	return _c
}

// GetPortsAndHostAddrsFromNodeServices provides a mock function with given fields: nodeServicesInfo, defaultConnStr, logger
func (_m *UtilsIface) GetPortsAndHostAddrsFromNodeServices(nodeServicesInfo map[string]interface{}, defaultConnStr string, logger *log.CommonLogger) (base.HostPortMapType, []string, error) {
	ret := _m.Called(nodeServicesInfo, defaultConnStr, logger)

	var r0 base.HostPortMapType
	var r1 []string
	var r2 error
	if rf, ok := ret.Get(0).(func(map[string]interface{}, string, *log.CommonLogger) (base.HostPortMapType, []string, error)); ok {
		return rf(nodeServicesInfo, defaultConnStr, logger)
	}
	if rf, ok := ret.Get(0).(func(map[string]interface{}, string, *log.CommonLogger) base.HostPortMapType); ok {
		r0 = rf(nodeServicesInfo, defaultConnStr, logger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(base.HostPortMapType)
		}
	}

	if rf, ok := ret.Get(1).(func(map[string]interface{}, string, *log.CommonLogger) []string); ok {
		r1 = rf(nodeServicesInfo, defaultConnStr, logger)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]string)
		}
	}

	if rf, ok := ret.Get(2).(func(map[string]interface{}, string, *log.CommonLogger) error); ok {
		r2 = rf(nodeServicesInfo, defaultConnStr, logger)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// UtilsIface_GetPortsAndHostAddrsFromNodeServices_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPortsAndHostAddrsFromNodeServices'
type UtilsIface_GetPortsAndHostAddrsFromNodeServices_Call struct {
	*mock.Call
}

// GetPortsAndHostAddrsFromNodeServices is a helper method to define mock.On call
//   - nodeServicesInfo map[string]interface{}
//   - defaultConnStr string
//   - logger *log.CommonLogger
func (_e *UtilsIface_Expecter) GetPortsAndHostAddrsFromNodeServices(nodeServicesInfo interface{}, defaultConnStr interface{}, logger interface{}) *UtilsIface_GetPortsAndHostAddrsFromNodeServices_Call {
	return &UtilsIface_GetPortsAndHostAddrsFromNodeServices_Call{Call: _e.mock.On("GetPortsAndHostAddrsFromNodeServices", nodeServicesInfo, defaultConnStr, logger)}
}

func (_c *UtilsIface_GetPortsAndHostAddrsFromNodeServices_Call) Run(run func(nodeServicesInfo map[string]interface{}, defaultConnStr string, logger *log.CommonLogger)) *UtilsIface_GetPortsAndHostAddrsFromNodeServices_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(map[string]interface{}), args[1].(string), args[2].(*log.CommonLogger))
	})
	return _c
}

func (_c *UtilsIface_GetPortsAndHostAddrsFromNodeServices_Call) Return(_a0 base.HostPortMapType, _a1 []string, _a2 error) *UtilsIface_GetPortsAndHostAddrsFromNodeServices_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *UtilsIface_GetPortsAndHostAddrsFromNodeServices_Call) RunAndReturn(run func(map[string]interface{}, string, *log.CommonLogger) (base.HostPortMapType, []string, error)) *UtilsIface_GetPortsAndHostAddrsFromNodeServices_Call {
	_c.Call.Return(run)
	return _c
}

// GetRemoteMemcachedConnection provides a mock function with given fields: serverAddr, username, password, bucketName, userAgent, plainAuth, keepAlivePeriod, logger
func (_m *UtilsIface) GetRemoteMemcachedConnection(serverAddr string, username string, password string, bucketName string, userAgent string, plainAuth bool, keepAlivePeriod time.Duration, logger *log.CommonLogger) (memcached.ClientIface, error) {
	ret := _m.Called(serverAddr, username, password, bucketName, userAgent, plainAuth, keepAlivePeriod, logger)

	var r0 memcached.ClientIface
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, string, string, string, bool, time.Duration, *log.CommonLogger) (memcached.ClientIface, error)); ok {
		return rf(serverAddr, username, password, bucketName, userAgent, plainAuth, keepAlivePeriod, logger)
	}
	if rf, ok := ret.Get(0).(func(string, string, string, string, string, bool, time.Duration, *log.CommonLogger) memcached.ClientIface); ok {
		r0 = rf(serverAddr, username, password, bucketName, userAgent, plainAuth, keepAlivePeriod, logger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(memcached.ClientIface)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, string, string, string, bool, time.Duration, *log.CommonLogger) error); ok {
		r1 = rf(serverAddr, username, password, bucketName, userAgent, plainAuth, keepAlivePeriod, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UtilsIface_GetRemoteMemcachedConnection_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRemoteMemcachedConnection'
type UtilsIface_GetRemoteMemcachedConnection_Call struct {
	*mock.Call
}

// GetRemoteMemcachedConnection is a helper method to define mock.On call
//   - serverAddr string
//   - username string
//   - password string
//   - bucketName string
//   - userAgent string
//   - plainAuth bool
//   - keepAlivePeriod time.Duration
//   - logger *log.CommonLogger
func (_e *UtilsIface_Expecter) GetRemoteMemcachedConnection(serverAddr interface{}, username interface{}, password interface{}, bucketName interface{}, userAgent interface{}, plainAuth interface{}, keepAlivePeriod interface{}, logger interface{}) *UtilsIface_GetRemoteMemcachedConnection_Call {
	return &UtilsIface_GetRemoteMemcachedConnection_Call{Call: _e.mock.On("GetRemoteMemcachedConnection", serverAddr, username, password, bucketName, userAgent, plainAuth, keepAlivePeriod, logger)}
}

func (_c *UtilsIface_GetRemoteMemcachedConnection_Call) Run(run func(serverAddr string, username string, password string, bucketName string, userAgent string, plainAuth bool, keepAlivePeriod time.Duration, logger *log.CommonLogger)) *UtilsIface_GetRemoteMemcachedConnection_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].(string), args[3].(string), args[4].(string), args[5].(bool), args[6].(time.Duration), args[7].(*log.CommonLogger))
	})
	return _c
}

func (_c *UtilsIface_GetRemoteMemcachedConnection_Call) Return(_a0 memcached.ClientIface, _a1 error) *UtilsIface_GetRemoteMemcachedConnection_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *UtilsIface_GetRemoteMemcachedConnection_Call) RunAndReturn(run func(string, string, string, string, string, bool, time.Duration, *log.CommonLogger) (memcached.ClientIface, error)) *UtilsIface_GetRemoteMemcachedConnection_Call {
	_c.Call.Return(run)
	return _c
}

// GetRemoteMemcachedConnectionWFeatures provides a mock function with given fields: serverAddr, username, password, bucketName, userAgent, plainAuth, keepAlivePeriod, features, logger
func (_m *UtilsIface) GetRemoteMemcachedConnectionWFeatures(serverAddr string, username string, password string, bucketName string, userAgent string, plainAuth bool, keepAlivePeriod time.Duration, features utils.HELOFeatures, logger *log.CommonLogger) (memcached.ClientIface, utils.HELOFeatures, error) {
	ret := _m.Called(serverAddr, username, password, bucketName, userAgent, plainAuth, keepAlivePeriod, features, logger)

	var r0 memcached.ClientIface
	var r1 utils.HELOFeatures
	var r2 error
	if rf, ok := ret.Get(0).(func(string, string, string, string, string, bool, time.Duration, utils.HELOFeatures, *log.CommonLogger) (memcached.ClientIface, utils.HELOFeatures, error)); ok {
		return rf(serverAddr, username, password, bucketName, userAgent, plainAuth, keepAlivePeriod, features, logger)
	}
	if rf, ok := ret.Get(0).(func(string, string, string, string, string, bool, time.Duration, utils.HELOFeatures, *log.CommonLogger) memcached.ClientIface); ok {
		r0 = rf(serverAddr, username, password, bucketName, userAgent, plainAuth, keepAlivePeriod, features, logger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(memcached.ClientIface)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, string, string, string, bool, time.Duration, utils.HELOFeatures, *log.CommonLogger) utils.HELOFeatures); ok {
		r1 = rf(serverAddr, username, password, bucketName, userAgent, plainAuth, keepAlivePeriod, features, logger)
	} else {
		r1 = ret.Get(1).(utils.HELOFeatures)
	}

	if rf, ok := ret.Get(2).(func(string, string, string, string, string, bool, time.Duration, utils.HELOFeatures, *log.CommonLogger) error); ok {
		r2 = rf(serverAddr, username, password, bucketName, userAgent, plainAuth, keepAlivePeriod, features, logger)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// UtilsIface_GetRemoteMemcachedConnectionWFeatures_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRemoteMemcachedConnectionWFeatures'
type UtilsIface_GetRemoteMemcachedConnectionWFeatures_Call struct {
	*mock.Call
}

// GetRemoteMemcachedConnectionWFeatures is a helper method to define mock.On call
//   - serverAddr string
//   - username string
//   - password string
//   - bucketName string
//   - userAgent string
//   - plainAuth bool
//   - keepAlivePeriod time.Duration
//   - features utils.HELOFeatures
//   - logger *log.CommonLogger
func (_e *UtilsIface_Expecter) GetRemoteMemcachedConnectionWFeatures(serverAddr interface{}, username interface{}, password interface{}, bucketName interface{}, userAgent interface{}, plainAuth interface{}, keepAlivePeriod interface{}, features interface{}, logger interface{}) *UtilsIface_GetRemoteMemcachedConnectionWFeatures_Call {
	return &UtilsIface_GetRemoteMemcachedConnectionWFeatures_Call{Call: _e.mock.On("GetRemoteMemcachedConnectionWFeatures", serverAddr, username, password, bucketName, userAgent, plainAuth, keepAlivePeriod, features, logger)}
}

func (_c *UtilsIface_GetRemoteMemcachedConnectionWFeatures_Call) Run(run func(serverAddr string, username string, password string, bucketName string, userAgent string, plainAuth bool, keepAlivePeriod time.Duration, features utils.HELOFeatures, logger *log.CommonLogger)) *UtilsIface_GetRemoteMemcachedConnectionWFeatures_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].(string), args[3].(string), args[4].(string), args[5].(bool), args[6].(time.Duration), args[7].(utils.HELOFeatures), args[8].(*log.CommonLogger))
	})
	return _c
}

func (_c *UtilsIface_GetRemoteMemcachedConnectionWFeatures_Call) Return(_a0 memcached.ClientIface, _a1 utils.HELOFeatures, _a2 error) *UtilsIface_GetRemoteMemcachedConnectionWFeatures_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *UtilsIface_GetRemoteMemcachedConnectionWFeatures_Call) RunAndReturn(run func(string, string, string, string, string, bool, time.Duration, utils.HELOFeatures, *log.CommonLogger) (memcached.ClientIface, utils.HELOFeatures, error)) *UtilsIface_GetRemoteMemcachedConnectionWFeatures_Call {
	_c.Call.Return(run)
	return _c
}

// GetRemoteNodeAddressesListFromNodeList provides a mock function with given fields: nodeList, connStr, needHttps, logger, useExternal
func (_m *UtilsIface) GetRemoteNodeAddressesListFromNodeList(nodeList []interface{}, connStr string, needHttps bool, logger *log.CommonLogger, useExternal bool) (base.StringPairList, error) {
	ret := _m.Called(nodeList, connStr, needHttps, logger, useExternal)

	var r0 base.StringPairList
	var r1 error
	if rf, ok := ret.Get(0).(func([]interface{}, string, bool, *log.CommonLogger, bool) (base.StringPairList, error)); ok {
		return rf(nodeList, connStr, needHttps, logger, useExternal)
	}
	if rf, ok := ret.Get(0).(func([]interface{}, string, bool, *log.CommonLogger, bool) base.StringPairList); ok {
		r0 = rf(nodeList, connStr, needHttps, logger, useExternal)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(base.StringPairList)
		}
	}

	if rf, ok := ret.Get(1).(func([]interface{}, string, bool, *log.CommonLogger, bool) error); ok {
		r1 = rf(nodeList, connStr, needHttps, logger, useExternal)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UtilsIface_GetRemoteNodeAddressesListFromNodeList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRemoteNodeAddressesListFromNodeList'
type UtilsIface_GetRemoteNodeAddressesListFromNodeList_Call struct {
	*mock.Call
}

// GetRemoteNodeAddressesListFromNodeList is a helper method to define mock.On call
//   - nodeList []interface{}
//   - connStr string
//   - needHttps bool
//   - logger *log.CommonLogger
//   - useExternal bool
func (_e *UtilsIface_Expecter) GetRemoteNodeAddressesListFromNodeList(nodeList interface{}, connStr interface{}, needHttps interface{}, logger interface{}, useExternal interface{}) *UtilsIface_GetRemoteNodeAddressesListFromNodeList_Call {
	return &UtilsIface_GetRemoteNodeAddressesListFromNodeList_Call{Call: _e.mock.On("GetRemoteNodeAddressesListFromNodeList", nodeList, connStr, needHttps, logger, useExternal)}
}

func (_c *UtilsIface_GetRemoteNodeAddressesListFromNodeList_Call) Run(run func(nodeList []interface{}, connStr string, needHttps bool, logger *log.CommonLogger, useExternal bool)) *UtilsIface_GetRemoteNodeAddressesListFromNodeList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]interface{}), args[1].(string), args[2].(bool), args[3].(*log.CommonLogger), args[4].(bool))
	})
	return _c
}

func (_c *UtilsIface_GetRemoteNodeAddressesListFromNodeList_Call) Return(_a0 base.StringPairList, _a1 error) *UtilsIface_GetRemoteNodeAddressesListFromNodeList_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *UtilsIface_GetRemoteNodeAddressesListFromNodeList_Call) RunAndReturn(run func([]interface{}, string, bool, *log.CommonLogger, bool) (base.StringPairList, error)) *UtilsIface_GetRemoteNodeAddressesListFromNodeList_Call {
	_c.Call.Return(run)
	return _c
}

// GetRemoteSSLPorts provides a mock function with given fields: hostAddr, logger
func (_m *UtilsIface) GetRemoteSSLPorts(hostAddr string, logger *log.CommonLogger) (uint16, error, uint16, error) {
	ret := _m.Called(hostAddr, logger)

	var r0 uint16
	var r1 error
	var r2 uint16
	var r3 error
	if rf, ok := ret.Get(0).(func(string, *log.CommonLogger) (uint16, error, uint16, error)); ok {
		return rf(hostAddr, logger)
	}
	if rf, ok := ret.Get(0).(func(string, *log.CommonLogger) uint16); ok {
		r0 = rf(hostAddr, logger)
	} else {
		r0 = ret.Get(0).(uint16)
	}

	if rf, ok := ret.Get(1).(func(string, *log.CommonLogger) error); ok {
		r1 = rf(hostAddr, logger)
	} else {
		r1 = ret.Error(1)
	}

	if rf, ok := ret.Get(2).(func(string, *log.CommonLogger) uint16); ok {
		r2 = rf(hostAddr, logger)
	} else {
		r2 = ret.Get(2).(uint16)
	}

	if rf, ok := ret.Get(3).(func(string, *log.CommonLogger) error); ok {
		r3 = rf(hostAddr, logger)
	} else {
		r3 = ret.Error(3)
	}

	return r0, r1, r2, r3
}

// UtilsIface_GetRemoteSSLPorts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRemoteSSLPorts'
type UtilsIface_GetRemoteSSLPorts_Call struct {
	*mock.Call
}

// GetRemoteSSLPorts is a helper method to define mock.On call
//   - hostAddr string
//   - logger *log.CommonLogger
func (_e *UtilsIface_Expecter) GetRemoteSSLPorts(hostAddr interface{}, logger interface{}) *UtilsIface_GetRemoteSSLPorts_Call {
	return &UtilsIface_GetRemoteSSLPorts_Call{Call: _e.mock.On("GetRemoteSSLPorts", hostAddr, logger)}
}

func (_c *UtilsIface_GetRemoteSSLPorts_Call) Run(run func(hostAddr string, logger *log.CommonLogger)) *UtilsIface_GetRemoteSSLPorts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(*log.CommonLogger))
	})
	return _c
}

func (_c *UtilsIface_GetRemoteSSLPorts_Call) Return(internalSSLPort uint16, internalSSLErr error, externalSSLPort uint16, externalSSLErr error) *UtilsIface_GetRemoteSSLPorts_Call {
	_c.Call.Return(internalSSLPort, internalSSLErr, externalSSLPort, externalSSLErr)
	return _c
}

func (_c *UtilsIface_GetRemoteSSLPorts_Call) RunAndReturn(run func(string, *log.CommonLogger) (uint16, error, uint16, error)) *UtilsIface_GetRemoteSSLPorts_Call {
	_c.Call.Return(run)
	return _c
}

// GetRemoteServerVBucketsMap provides a mock function with given fields: connStr, bucketName, bucketInfo, useExternal
func (_m *UtilsIface) GetRemoteServerVBucketsMap(connStr string, bucketName string, bucketInfo map[string]interface{}, useExternal bool) (map[string][]uint16, error) {
	ret := _m.Called(connStr, bucketName, bucketInfo, useExternal)

	var r0 map[string][]uint16
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, map[string]interface{}, bool) (map[string][]uint16, error)); ok {
		return rf(connStr, bucketName, bucketInfo, useExternal)
	}
	if rf, ok := ret.Get(0).(func(string, string, map[string]interface{}, bool) map[string][]uint16); ok {
		r0 = rf(connStr, bucketName, bucketInfo, useExternal)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string][]uint16)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, map[string]interface{}, bool) error); ok {
		r1 = rf(connStr, bucketName, bucketInfo, useExternal)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UtilsIface_GetRemoteServerVBucketsMap_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRemoteServerVBucketsMap'
type UtilsIface_GetRemoteServerVBucketsMap_Call struct {
	*mock.Call
}

// GetRemoteServerVBucketsMap is a helper method to define mock.On call
//   - connStr string
//   - bucketName string
//   - bucketInfo map[string]interface{}
//   - useExternal bool
func (_e *UtilsIface_Expecter) GetRemoteServerVBucketsMap(connStr interface{}, bucketName interface{}, bucketInfo interface{}, useExternal interface{}) *UtilsIface_GetRemoteServerVBucketsMap_Call {
	return &UtilsIface_GetRemoteServerVBucketsMap_Call{Call: _e.mock.On("GetRemoteServerVBucketsMap", connStr, bucketName, bucketInfo, useExternal)}
}

func (_c *UtilsIface_GetRemoteServerVBucketsMap_Call) Run(run func(connStr string, bucketName string, bucketInfo map[string]interface{}, useExternal bool)) *UtilsIface_GetRemoteServerVBucketsMap_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].(map[string]interface{}), args[3].(bool))
	})
	return _c
}

func (_c *UtilsIface_GetRemoteServerVBucketsMap_Call) Return(_a0 map[string][]uint16, _a1 error) *UtilsIface_GetRemoteServerVBucketsMap_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *UtilsIface_GetRemoteServerVBucketsMap_Call) RunAndReturn(run func(string, string, map[string]interface{}, bool) (map[string][]uint16, error)) *UtilsIface_GetRemoteServerVBucketsMap_Call {
	_c.Call.Return(run)
	return _c
}

// GetReplicasInfo provides a mock function with given fields: bucketInfo, isStrictlySecure, recycledStringStringMap, recycledVbHostMapGetter, recycledStringSliceGetter
func (_m *UtilsIface) GetReplicasInfo(bucketInfo map[string]interface{}, isStrictlySecure bool, recycledStringStringMap *base.StringStringMap, recycledVbHostMapGetter func([]uint16) *base.VbHostsMapType, recycledStringSliceGetter func() *[]string) (*base.VbHostsMapType, *base.StringStringMap, int, []uint16, error) {
	ret := _m.Called(bucketInfo, isStrictlySecure, recycledStringStringMap, recycledVbHostMapGetter, recycledStringSliceGetter)

	var r0 *base.VbHostsMapType
	var r1 *base.StringStringMap
	var r2 int
	var r3 []uint16
	var r4 error
	if rf, ok := ret.Get(0).(func(map[string]interface{}, bool, *base.StringStringMap, func([]uint16) *base.VbHostsMapType, func() *[]string) (*base.VbHostsMapType, *base.StringStringMap, int, []uint16, error)); ok {
		return rf(bucketInfo, isStrictlySecure, recycledStringStringMap, recycledVbHostMapGetter, recycledStringSliceGetter)
	}
	if rf, ok := ret.Get(0).(func(map[string]interface{}, bool, *base.StringStringMap, func([]uint16) *base.VbHostsMapType, func() *[]string) *base.VbHostsMapType); ok {
		r0 = rf(bucketInfo, isStrictlySecure, recycledStringStringMap, recycledVbHostMapGetter, recycledStringSliceGetter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*base.VbHostsMapType)
		}
	}

	if rf, ok := ret.Get(1).(func(map[string]interface{}, bool, *base.StringStringMap, func([]uint16) *base.VbHostsMapType, func() *[]string) *base.StringStringMap); ok {
		r1 = rf(bucketInfo, isStrictlySecure, recycledStringStringMap, recycledVbHostMapGetter, recycledStringSliceGetter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*base.StringStringMap)
		}
	}

	if rf, ok := ret.Get(2).(func(map[string]interface{}, bool, *base.StringStringMap, func([]uint16) *base.VbHostsMapType, func() *[]string) int); ok {
		r2 = rf(bucketInfo, isStrictlySecure, recycledStringStringMap, recycledVbHostMapGetter, recycledStringSliceGetter)
	} else {
		r2 = ret.Get(2).(int)
	}

	if rf, ok := ret.Get(3).(func(map[string]interface{}, bool, *base.StringStringMap, func([]uint16) *base.VbHostsMapType, func() *[]string) []uint16); ok {
		r3 = rf(bucketInfo, isStrictlySecure, recycledStringStringMap, recycledVbHostMapGetter, recycledStringSliceGetter)
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).([]uint16)
		}
	}

	if rf, ok := ret.Get(4).(func(map[string]interface{}, bool, *base.StringStringMap, func([]uint16) *base.VbHostsMapType, func() *[]string) error); ok {
		r4 = rf(bucketInfo, isStrictlySecure, recycledStringStringMap, recycledVbHostMapGetter, recycledStringSliceGetter)
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// UtilsIface_GetReplicasInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetReplicasInfo'
type UtilsIface_GetReplicasInfo_Call struct {
	*mock.Call
}

// GetReplicasInfo is a helper method to define mock.On call
//   - bucketInfo map[string]interface{}
//   - isStrictlySecure bool
//   - recycledStringStringMap *base.StringStringMap
//   - recycledVbHostMapGetter func([]uint16) *base.VbHostsMapType
//   - recycledStringSliceGetter func() *[]string
func (_e *UtilsIface_Expecter) GetReplicasInfo(bucketInfo interface{}, isStrictlySecure interface{}, recycledStringStringMap interface{}, recycledVbHostMapGetter interface{}, recycledStringSliceGetter interface{}) *UtilsIface_GetReplicasInfo_Call {
	return &UtilsIface_GetReplicasInfo_Call{Call: _e.mock.On("GetReplicasInfo", bucketInfo, isStrictlySecure, recycledStringStringMap, recycledVbHostMapGetter, recycledStringSliceGetter)}
}

func (_c *UtilsIface_GetReplicasInfo_Call) Run(run func(bucketInfo map[string]interface{}, isStrictlySecure bool, recycledStringStringMap *base.StringStringMap, recycledVbHostMapGetter func([]uint16) *base.VbHostsMapType, recycledStringSliceGetter func() *[]string)) *UtilsIface_GetReplicasInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(map[string]interface{}), args[1].(bool), args[2].(*base.StringStringMap), args[3].(func([]uint16) *base.VbHostsMapType), args[4].(func() *[]string))
	})
	return _c
}

func (_c *UtilsIface_GetReplicasInfo_Call) Return(_a0 *base.VbHostsMapType, _a1 *base.StringStringMap, _a2 int, _a3 []uint16, _a4 error) *UtilsIface_GetReplicasInfo_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3, _a4)
	return _c
}

func (_c *UtilsIface_GetReplicasInfo_Call) RunAndReturn(run func(map[string]interface{}, bool, *base.StringStringMap, func([]uint16) *base.VbHostsMapType, func() *[]string) (*base.VbHostsMapType, *base.StringStringMap, int, []uint16, error)) *UtilsIface_GetReplicasInfo_Call {
	_c.Call.Return(run)
	return _c
}

// GetSecuritySettingsAndDefaultPoolInfo provides a mock function with given fields: hostAddr, hostHttpsAddr, username, password, certificate, clientCertificate, clientKey, scramShaEnabled, logger
func (_m *UtilsIface) GetSecuritySettingsAndDefaultPoolInfo(hostAddr string, hostHttpsAddr string, username string, password string, certificate []byte, clientCertificate []byte, clientKey []byte, scramShaEnabled bool, logger *log.CommonLogger) (base.HttpAuthMech, map[string]interface{}, int, error) {
	ret := _m.Called(hostAddr, hostHttpsAddr, username, password, certificate, clientCertificate, clientKey, scramShaEnabled, logger)

	var r0 base.HttpAuthMech
	var r1 map[string]interface{}
	var r2 int
	var r3 error
	if rf, ok := ret.Get(0).(func(string, string, string, string, []byte, []byte, []byte, bool, *log.CommonLogger) (base.HttpAuthMech, map[string]interface{}, int, error)); ok {
		return rf(hostAddr, hostHttpsAddr, username, password, certificate, clientCertificate, clientKey, scramShaEnabled, logger)
	}
	if rf, ok := ret.Get(0).(func(string, string, string, string, []byte, []byte, []byte, bool, *log.CommonLogger) base.HttpAuthMech); ok {
		r0 = rf(hostAddr, hostHttpsAddr, username, password, certificate, clientCertificate, clientKey, scramShaEnabled, logger)
	} else {
		r0 = ret.Get(0).(base.HttpAuthMech)
	}

	if rf, ok := ret.Get(1).(func(string, string, string, string, []byte, []byte, []byte, bool, *log.CommonLogger) map[string]interface{}); ok {
		r1 = rf(hostAddr, hostHttpsAddr, username, password, certificate, clientCertificate, clientKey, scramShaEnabled, logger)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(map[string]interface{})
		}
	}

	if rf, ok := ret.Get(2).(func(string, string, string, string, []byte, []byte, []byte, bool, *log.CommonLogger) int); ok {
		r2 = rf(hostAddr, hostHttpsAddr, username, password, certificate, clientCertificate, clientKey, scramShaEnabled, logger)
	} else {
		r2 = ret.Get(2).(int)
	}

	if rf, ok := ret.Get(3).(func(string, string, string, string, []byte, []byte, []byte, bool, *log.CommonLogger) error); ok {
		r3 = rf(hostAddr, hostHttpsAddr, username, password, certificate, clientCertificate, clientKey, scramShaEnabled, logger)
	} else {
		r3 = ret.Error(3)
	}

	return r0, r1, r2, r3
}

// UtilsIface_GetSecuritySettingsAndDefaultPoolInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSecuritySettingsAndDefaultPoolInfo'
type UtilsIface_GetSecuritySettingsAndDefaultPoolInfo_Call struct {
	*mock.Call
}

// GetSecuritySettingsAndDefaultPoolInfo is a helper method to define mock.On call
//   - hostAddr string
//   - hostHttpsAddr string
//   - username string
//   - password string
//   - certificate []byte
//   - clientCertificate []byte
//   - clientKey []byte
//   - scramShaEnabled bool
//   - logger *log.CommonLogger
func (_e *UtilsIface_Expecter) GetSecuritySettingsAndDefaultPoolInfo(hostAddr interface{}, hostHttpsAddr interface{}, username interface{}, password interface{}, certificate interface{}, clientCertificate interface{}, clientKey interface{}, scramShaEnabled interface{}, logger interface{}) *UtilsIface_GetSecuritySettingsAndDefaultPoolInfo_Call {
	return &UtilsIface_GetSecuritySettingsAndDefaultPoolInfo_Call{Call: _e.mock.On("GetSecuritySettingsAndDefaultPoolInfo", hostAddr, hostHttpsAddr, username, password, certificate, clientCertificate, clientKey, scramShaEnabled, logger)}
}

func (_c *UtilsIface_GetSecuritySettingsAndDefaultPoolInfo_Call) Run(run func(hostAddr string, hostHttpsAddr string, username string, password string, certificate []byte, clientCertificate []byte, clientKey []byte, scramShaEnabled bool, logger *log.CommonLogger)) *UtilsIface_GetSecuritySettingsAndDefaultPoolInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].(string), args[3].(string), args[4].([]byte), args[5].([]byte), args[6].([]byte), args[7].(bool), args[8].(*log.CommonLogger))
	})
	return _c
}

func (_c *UtilsIface_GetSecuritySettingsAndDefaultPoolInfo_Call) Return(_a0 base.HttpAuthMech, _a1 map[string]interface{}, _a2 int, _a3 error) *UtilsIface_GetSecuritySettingsAndDefaultPoolInfo_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3)
	return _c
}

func (_c *UtilsIface_GetSecuritySettingsAndDefaultPoolInfo_Call) RunAndReturn(run func(string, string, string, string, []byte, []byte, []byte, bool, *log.CommonLogger) (base.HttpAuthMech, map[string]interface{}, int, error)) *UtilsIface_GetSecuritySettingsAndDefaultPoolInfo_Call {
	_c.Call.Return(run)
	return _c
}

// GetServerVBucketsMap provides a mock function with given fields: connStr, bucketName, bucketInfo, recycledMapGetter, serversList
func (_m *UtilsIface) GetServerVBucketsMap(connStr string, bucketName string, bucketInfo map[string]interface{}, recycledMapGetter func([]string) *base.KvVBMapType, serversList []string) (*base.KvVBMapType, error) {
	ret := _m.Called(connStr, bucketName, bucketInfo, recycledMapGetter, serversList)

	var r0 *base.KvVBMapType
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, map[string]interface{}, func([]string) *base.KvVBMapType, []string) (*base.KvVBMapType, error)); ok {
		return rf(connStr, bucketName, bucketInfo, recycledMapGetter, serversList)
	}
	if rf, ok := ret.Get(0).(func(string, string, map[string]interface{}, func([]string) *base.KvVBMapType, []string) *base.KvVBMapType); ok {
		r0 = rf(connStr, bucketName, bucketInfo, recycledMapGetter, serversList)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*base.KvVBMapType)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, map[string]interface{}, func([]string) *base.KvVBMapType, []string) error); ok {
		r1 = rf(connStr, bucketName, bucketInfo, recycledMapGetter, serversList)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UtilsIface_GetServerVBucketsMap_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetServerVBucketsMap'
type UtilsIface_GetServerVBucketsMap_Call struct {
	*mock.Call
}

// GetServerVBucketsMap is a helper method to define mock.On call
//   - connStr string
//   - bucketName string
//   - bucketInfo map[string]interface{}
//   - recycledMapGetter func([]string) *base.KvVBMapType
//   - serversList []string
func (_e *UtilsIface_Expecter) GetServerVBucketsMap(connStr interface{}, bucketName interface{}, bucketInfo interface{}, recycledMapGetter interface{}, serversList interface{}) *UtilsIface_GetServerVBucketsMap_Call {
	return &UtilsIface_GetServerVBucketsMap_Call{Call: _e.mock.On("GetServerVBucketsMap", connStr, bucketName, bucketInfo, recycledMapGetter, serversList)}
}

func (_c *UtilsIface_GetServerVBucketsMap_Call) Run(run func(connStr string, bucketName string, bucketInfo map[string]interface{}, recycledMapGetter func([]string) *base.KvVBMapType, serversList []string)) *UtilsIface_GetServerVBucketsMap_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].(map[string]interface{}), args[3].(func([]string) *base.KvVBMapType), args[4].([]string))
	})
	return _c
}

func (_c *UtilsIface_GetServerVBucketsMap_Call) Return(_a0 *base.KvVBMapType, _a1 error) *UtilsIface_GetServerVBucketsMap_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *UtilsIface_GetServerVBucketsMap_Call) RunAndReturn(run func(string, string, map[string]interface{}, func([]string) *base.KvVBMapType, []string) (*base.KvVBMapType, error)) *UtilsIface_GetServerVBucketsMap_Call {
	_c.Call.Return(run)
	return _c
}

// GetServersListFromBucketInfo provides a mock function with given fields: bucketInfo
func (_m *UtilsIface) GetServersListFromBucketInfo(bucketInfo map[string]interface{}) ([]string, error) {
	ret := _m.Called(bucketInfo)

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(map[string]interface{}) ([]string, error)); ok {
		return rf(bucketInfo)
	}
	if rf, ok := ret.Get(0).(func(map[string]interface{}) []string); ok {
		r0 = rf(bucketInfo)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(map[string]interface{}) error); ok {
		r1 = rf(bucketInfo)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UtilsIface_GetServersListFromBucketInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetServersListFromBucketInfo'
type UtilsIface_GetServersListFromBucketInfo_Call struct {
	*mock.Call
}

// GetServersListFromBucketInfo is a helper method to define mock.On call
//   - bucketInfo map[string]interface{}
func (_e *UtilsIface_Expecter) GetServersListFromBucketInfo(bucketInfo interface{}) *UtilsIface_GetServersListFromBucketInfo_Call {
	return &UtilsIface_GetServersListFromBucketInfo_Call{Call: _e.mock.On("GetServersListFromBucketInfo", bucketInfo)}
}

func (_c *UtilsIface_GetServersListFromBucketInfo_Call) Run(run func(bucketInfo map[string]interface{})) *UtilsIface_GetServersListFromBucketInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(map[string]interface{}))
	})
	return _c
}

func (_c *UtilsIface_GetServersListFromBucketInfo_Call) Return(_a0 []string, _a1 error) *UtilsIface_GetServersListFromBucketInfo_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *UtilsIface_GetServersListFromBucketInfo_Call) RunAndReturn(run func(map[string]interface{}) ([]string, error)) *UtilsIface_GetServersListFromBucketInfo_Call {
	_c.Call.Return(run)
	return _c
}

// GetSettingFromSettings provides a mock function with given fields: settings, settingName
func (_m *UtilsIface) GetSettingFromSettings(settings metadata.ReplicationSettingsMap, settingName string) interface{} {
	ret := _m.Called(settings, settingName)

	var r0 interface{}
	if rf, ok := ret.Get(0).(func(metadata.ReplicationSettingsMap, string) interface{}); ok {
		r0 = rf(settings, settingName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	return r0
}

// UtilsIface_GetSettingFromSettings_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSettingFromSettings'
type UtilsIface_GetSettingFromSettings_Call struct {
	*mock.Call
}

// GetSettingFromSettings is a helper method to define mock.On call
//   - settings metadata.ReplicationSettingsMap
//   - settingName string
func (_e *UtilsIface_Expecter) GetSettingFromSettings(settings interface{}, settingName interface{}) *UtilsIface_GetSettingFromSettings_Call {
	return &UtilsIface_GetSettingFromSettings_Call{Call: _e.mock.On("GetSettingFromSettings", settings, settingName)}
}

func (_c *UtilsIface_GetSettingFromSettings_Call) Run(run func(settings metadata.ReplicationSettingsMap, settingName string)) *UtilsIface_GetSettingFromSettings_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(metadata.ReplicationSettingsMap), args[1].(string))
	})
	return _c
}

func (_c *UtilsIface_GetSettingFromSettings_Call) Return(_a0 interface{}) *UtilsIface_GetSettingFromSettings_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *UtilsIface_GetSettingFromSettings_Call) RunAndReturn(run func(metadata.ReplicationSettingsMap, string) interface{}) *UtilsIface_GetSettingFromSettings_Call {
	_c.Call.Return(run)
	return _c
}

// GetStringSettingFromSettings provides a mock function with given fields: settings, settingName
func (_m *UtilsIface) GetStringSettingFromSettings(settings metadata.ReplicationSettingsMap, settingName string) (string, error) {
	ret := _m.Called(settings, settingName)

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(metadata.ReplicationSettingsMap, string) (string, error)); ok {
		return rf(settings, settingName)
	}
	if rf, ok := ret.Get(0).(func(metadata.ReplicationSettingsMap, string) string); ok {
		r0 = rf(settings, settingName)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(metadata.ReplicationSettingsMap, string) error); ok {
		r1 = rf(settings, settingName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UtilsIface_GetStringSettingFromSettings_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetStringSettingFromSettings'
type UtilsIface_GetStringSettingFromSettings_Call struct {
	*mock.Call
}

// GetStringSettingFromSettings is a helper method to define mock.On call
//   - settings metadata.ReplicationSettingsMap
//   - settingName string
func (_e *UtilsIface_Expecter) GetStringSettingFromSettings(settings interface{}, settingName interface{}) *UtilsIface_GetStringSettingFromSettings_Call {
	return &UtilsIface_GetStringSettingFromSettings_Call{Call: _e.mock.On("GetStringSettingFromSettings", settings, settingName)}
}

func (_c *UtilsIface_GetStringSettingFromSettings_Call) Run(run func(settings metadata.ReplicationSettingsMap, settingName string)) *UtilsIface_GetStringSettingFromSettings_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(metadata.ReplicationSettingsMap), args[1].(string))
	})
	return _c
}

func (_c *UtilsIface_GetStringSettingFromSettings_Call) Return(_a0 string, _a1 error) *UtilsIface_GetStringSettingFromSettings_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *UtilsIface_GetStringSettingFromSettings_Call) RunAndReturn(run func(metadata.ReplicationSettingsMap, string) (string, error)) *UtilsIface_GetStringSettingFromSettings_Call {
	_c.Call.Return(run)
	return _c
}

// GetVbucketsMaxCas provides a mock function with given fields: bucketInfo
func (_m *UtilsIface) GetVbucketsMaxCas(bucketInfo map[string]interface{}) ([]interface{}, error) {
	ret := _m.Called(bucketInfo)

	var r0 []interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(map[string]interface{}) ([]interface{}, error)); ok {
		return rf(bucketInfo)
	}
	if rf, ok := ret.Get(0).(func(map[string]interface{}) []interface{}); ok {
		r0 = rf(bucketInfo)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(map[string]interface{}) error); ok {
		r1 = rf(bucketInfo)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UtilsIface_GetVbucketsMaxCas_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetVbucketsMaxCas'
type UtilsIface_GetVbucketsMaxCas_Call struct {
	*mock.Call
}

// GetVbucketsMaxCas is a helper method to define mock.On call
//   - bucketInfo map[string]interface{}
func (_e *UtilsIface_Expecter) GetVbucketsMaxCas(bucketInfo interface{}) *UtilsIface_GetVbucketsMaxCas_Call {
	return &UtilsIface_GetVbucketsMaxCas_Call{Call: _e.mock.On("GetVbucketsMaxCas", bucketInfo)}
}

func (_c *UtilsIface_GetVbucketsMaxCas_Call) Run(run func(bucketInfo map[string]interface{})) *UtilsIface_GetVbucketsMaxCas_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(map[string]interface{}))
	})
	return _c
}

func (_c *UtilsIface_GetVbucketsMaxCas_Call) Return(_a0 []interface{}, _a1 error) *UtilsIface_GetVbucketsMaxCas_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *UtilsIface_GetVbucketsMaxCas_Call) RunAndReturn(run func(map[string]interface{}) ([]interface{}, error)) *UtilsIface_GetVbucketsMaxCas_Call {
	_c.Call.Return(run)
	return _c
}

// GetVersionPruningWindowHrs provides a mock function with given fields: bucketInfo
func (_m *UtilsIface) GetVersionPruningWindowHrs(bucketInfo map[string]interface{}) (int, error) {
	ret := _m.Called(bucketInfo)

	var r0 int
	var r1 error
	if rf, ok := ret.Get(0).(func(map[string]interface{}) (int, error)); ok {
		return rf(bucketInfo)
	}
	if rf, ok := ret.Get(0).(func(map[string]interface{}) int); ok {
		r0 = rf(bucketInfo)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func(map[string]interface{}) error); ok {
		r1 = rf(bucketInfo)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UtilsIface_GetVersionPruningWindowHrs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetVersionPruningWindowHrs'
type UtilsIface_GetVersionPruningWindowHrs_Call struct {
	*mock.Call
}

// GetVersionPruningWindowHrs is a helper method to define mock.On call
//   - bucketInfo map[string]interface{}
func (_e *UtilsIface_Expecter) GetVersionPruningWindowHrs(bucketInfo interface{}) *UtilsIface_GetVersionPruningWindowHrs_Call {
	return &UtilsIface_GetVersionPruningWindowHrs_Call{Call: _e.mock.On("GetVersionPruningWindowHrs", bucketInfo)}
}

func (_c *UtilsIface_GetVersionPruningWindowHrs_Call) Run(run func(bucketInfo map[string]interface{})) *UtilsIface_GetVersionPruningWindowHrs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(map[string]interface{}))
	})
	return _c
}

func (_c *UtilsIface_GetVersionPruningWindowHrs_Call) Return(_a0 int, _a1 error) *UtilsIface_GetVersionPruningWindowHrs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *UtilsIface_GetVersionPruningWindowHrs_Call) RunAndReturn(run func(map[string]interface{}) (int, error)) *UtilsIface_GetVersionPruningWindowHrs_Call {
	_c.Call.Return(run)
	return _c
}

// HttpsRemoteHostAddr provides a mock function with given fields: hostAddr, logger
func (_m *UtilsIface) HttpsRemoteHostAddr(hostAddr string, logger *log.CommonLogger) (string, string, error) {
	ret := _m.Called(hostAddr, logger)

	var r0 string
	var r1 string
	var r2 error
	if rf, ok := ret.Get(0).(func(string, *log.CommonLogger) (string, string, error)); ok {
		return rf(hostAddr, logger)
	}
	if rf, ok := ret.Get(0).(func(string, *log.CommonLogger) string); ok {
		r0 = rf(hostAddr, logger)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string, *log.CommonLogger) string); ok {
		r1 = rf(hostAddr, logger)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(string, *log.CommonLogger) error); ok {
		r2 = rf(hostAddr, logger)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// UtilsIface_HttpsRemoteHostAddr_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HttpsRemoteHostAddr'
type UtilsIface_HttpsRemoteHostAddr_Call struct {
	*mock.Call
}

// HttpsRemoteHostAddr is a helper method to define mock.On call
//   - hostAddr string
//   - logger *log.CommonLogger
func (_e *UtilsIface_Expecter) HttpsRemoteHostAddr(hostAddr interface{}, logger interface{}) *UtilsIface_HttpsRemoteHostAddr_Call {
	return &UtilsIface_HttpsRemoteHostAddr_Call{Call: _e.mock.On("HttpsRemoteHostAddr", hostAddr, logger)}
}

func (_c *UtilsIface_HttpsRemoteHostAddr_Call) Run(run func(hostAddr string, logger *log.CommonLogger)) *UtilsIface_HttpsRemoteHostAddr_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(*log.CommonLogger))
	})
	return _c
}

func (_c *UtilsIface_HttpsRemoteHostAddr_Call) Return(_a0 string, _a1 string, _a2 error) *UtilsIface_HttpsRemoteHostAddr_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *UtilsIface_HttpsRemoteHostAddr_Call) RunAndReturn(run func(string, *log.CommonLogger) (string, string, error)) *UtilsIface_HttpsRemoteHostAddr_Call {
	_c.Call.Return(run)
	return _c
}

// InvalidRuneIndexErrorMessage provides a mock function with given fields: key, index
func (_m *UtilsIface) InvalidRuneIndexErrorMessage(key string, index int) string {
	ret := _m.Called(key, index)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, int) string); ok {
		r0 = rf(key, index)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// UtilsIface_InvalidRuneIndexErrorMessage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InvalidRuneIndexErrorMessage'
type UtilsIface_InvalidRuneIndexErrorMessage_Call struct {
	*mock.Call
}

// InvalidRuneIndexErrorMessage is a helper method to define mock.On call
//   - key string
//   - index int
func (_e *UtilsIface_Expecter) InvalidRuneIndexErrorMessage(key interface{}, index interface{}) *UtilsIface_InvalidRuneIndexErrorMessage_Call {
	return &UtilsIface_InvalidRuneIndexErrorMessage_Call{Call: _e.mock.On("InvalidRuneIndexErrorMessage", key, index)}
}

func (_c *UtilsIface_InvalidRuneIndexErrorMessage_Call) Run(run func(key string, index int)) *UtilsIface_InvalidRuneIndexErrorMessage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(int))
	})
	return _c
}

func (_c *UtilsIface_InvalidRuneIndexErrorMessage_Call) Return(_a0 string) *UtilsIface_InvalidRuneIndexErrorMessage_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *UtilsIface_InvalidRuneIndexErrorMessage_Call) RunAndReturn(run func(string, int) string) *UtilsIface_InvalidRuneIndexErrorMessage_Call {
	_c.Call.Return(run)
	return _c
}

// InvokeRestWithRetry provides a mock function with given fields: baseURL, path, preservePathEncoding, httpCommand, contentType, body, timeout, out, client, keep_client_alive, logger, num_retry
func (_m *UtilsIface) InvokeRestWithRetry(baseURL string, path string, preservePathEncoding bool, httpCommand string, contentType string, body []byte, timeout time.Duration, out interface{}, client *http.Client, keep_client_alive bool, logger *log.CommonLogger, num_retry int) (error, int) {
	ret := _m.Called(baseURL, path, preservePathEncoding, httpCommand, contentType, body, timeout, out, client, keep_client_alive, logger, num_retry)

	var r0 error
	var r1 int
	if rf, ok := ret.Get(0).(func(string, string, bool, string, string, []byte, time.Duration, interface{}, *http.Client, bool, *log.CommonLogger, int) (error, int)); ok {
		return rf(baseURL, path, preservePathEncoding, httpCommand, contentType, body, timeout, out, client, keep_client_alive, logger, num_retry)
	}
	if rf, ok := ret.Get(0).(func(string, string, bool, string, string, []byte, time.Duration, interface{}, *http.Client, bool, *log.CommonLogger, int) error); ok {
		r0 = rf(baseURL, path, preservePathEncoding, httpCommand, contentType, body, timeout, out, client, keep_client_alive, logger, num_retry)
	} else {
		r0 = ret.Error(0)
	}

	if rf, ok := ret.Get(1).(func(string, string, bool, string, string, []byte, time.Duration, interface{}, *http.Client, bool, *log.CommonLogger, int) int); ok {
		r1 = rf(baseURL, path, preservePathEncoding, httpCommand, contentType, body, timeout, out, client, keep_client_alive, logger, num_retry)
	} else {
		r1 = ret.Get(1).(int)
	}

	return r0, r1
}

// UtilsIface_InvokeRestWithRetry_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InvokeRestWithRetry'
type UtilsIface_InvokeRestWithRetry_Call struct {
	*mock.Call
}

// InvokeRestWithRetry is a helper method to define mock.On call
//   - baseURL string
//   - path string
//   - preservePathEncoding bool
//   - httpCommand string
//   - contentType string
//   - body []byte
//   - timeout time.Duration
//   - out interface{}
//   - client *http.Client
//   - keep_client_alive bool
//   - logger *log.CommonLogger
//   - num_retry int
func (_e *UtilsIface_Expecter) InvokeRestWithRetry(baseURL interface{}, path interface{}, preservePathEncoding interface{}, httpCommand interface{}, contentType interface{}, body interface{}, timeout interface{}, out interface{}, client interface{}, keep_client_alive interface{}, logger interface{}, num_retry interface{}) *UtilsIface_InvokeRestWithRetry_Call {
	return &UtilsIface_InvokeRestWithRetry_Call{Call: _e.mock.On("InvokeRestWithRetry", baseURL, path, preservePathEncoding, httpCommand, contentType, body, timeout, out, client, keep_client_alive, logger, num_retry)}
}

func (_c *UtilsIface_InvokeRestWithRetry_Call) Run(run func(baseURL string, path string, preservePathEncoding bool, httpCommand string, contentType string, body []byte, timeout time.Duration, out interface{}, client *http.Client, keep_client_alive bool, logger *log.CommonLogger, num_retry int)) *UtilsIface_InvokeRestWithRetry_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].(bool), args[3].(string), args[4].(string), args[5].([]byte), args[6].(time.Duration), args[7].(interface{}), args[8].(*http.Client), args[9].(bool), args[10].(*log.CommonLogger), args[11].(int))
	})
	return _c
}

func (_c *UtilsIface_InvokeRestWithRetry_Call) Return(_a0 error, _a1 int) *UtilsIface_InvokeRestWithRetry_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *UtilsIface_InvokeRestWithRetry_Call) RunAndReturn(run func(string, string, bool, string, string, []byte, time.Duration, interface{}, *http.Client, bool, *log.CommonLogger, int) (error, int)) *UtilsIface_InvokeRestWithRetry_Call {
	_c.Call.Return(run)
	return _c
}

// InvokeRestWithRetryWithAuth provides a mock function with given fields: baseURL, path, preservePathEncoding, username, password, authMech, certificate, san_in_certificate, clientCertificate, clientKey, insecureSkipVerify, httpCommand, contentType, body, timeout, out, client, keep_client_alive, logger, num_retry
func (_m *UtilsIface) InvokeRestWithRetryWithAuth(baseURL string, path string, preservePathEncoding bool, username string, password string, authMech base.HttpAuthMech, certificate []byte, san_in_certificate bool, clientCertificate []byte, clientKey []byte, insecureSkipVerify bool, httpCommand string, contentType string, body []byte, timeout time.Duration, out interface{}, client *http.Client, keep_client_alive bool, logger *log.CommonLogger, num_retry int) (error, int) {
	ret := _m.Called(baseURL, path, preservePathEncoding, username, password, authMech, certificate, san_in_certificate, clientCertificate, clientKey, insecureSkipVerify, httpCommand, contentType, body, timeout, out, client, keep_client_alive, logger, num_retry)

	var r0 error
	var r1 int
	if rf, ok := ret.Get(0).(func(string, string, bool, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, bool, string, string, []byte, time.Duration, interface{}, *http.Client, bool, *log.CommonLogger, int) (error, int)); ok {
		return rf(baseURL, path, preservePathEncoding, username, password, authMech, certificate, san_in_certificate, clientCertificate, clientKey, insecureSkipVerify, httpCommand, contentType, body, timeout, out, client, keep_client_alive, logger, num_retry)
	}
	if rf, ok := ret.Get(0).(func(string, string, bool, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, bool, string, string, []byte, time.Duration, interface{}, *http.Client, bool, *log.CommonLogger, int) error); ok {
		r0 = rf(baseURL, path, preservePathEncoding, username, password, authMech, certificate, san_in_certificate, clientCertificate, clientKey, insecureSkipVerify, httpCommand, contentType, body, timeout, out, client, keep_client_alive, logger, num_retry)
	} else {
		r0 = ret.Error(0)
	}

	if rf, ok := ret.Get(1).(func(string, string, bool, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, bool, string, string, []byte, time.Duration, interface{}, *http.Client, bool, *log.CommonLogger, int) int); ok {
		r1 = rf(baseURL, path, preservePathEncoding, username, password, authMech, certificate, san_in_certificate, clientCertificate, clientKey, insecureSkipVerify, httpCommand, contentType, body, timeout, out, client, keep_client_alive, logger, num_retry)
	} else {
		r1 = ret.Get(1).(int)
	}

	return r0, r1
}

// UtilsIface_InvokeRestWithRetryWithAuth_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InvokeRestWithRetryWithAuth'
type UtilsIface_InvokeRestWithRetryWithAuth_Call struct {
	*mock.Call
}

// InvokeRestWithRetryWithAuth is a helper method to define mock.On call
//   - baseURL string
//   - path string
//   - preservePathEncoding bool
//   - username string
//   - password string
//   - authMech base.HttpAuthMech
//   - certificate []byte
//   - san_in_certificate bool
//   - clientCertificate []byte
//   - clientKey []byte
//   - insecureSkipVerify bool
//   - httpCommand string
//   - contentType string
//   - body []byte
//   - timeout time.Duration
//   - out interface{}
//   - client *http.Client
//   - keep_client_alive bool
//   - logger *log.CommonLogger
//   - num_retry int
func (_e *UtilsIface_Expecter) InvokeRestWithRetryWithAuth(baseURL interface{}, path interface{}, preservePathEncoding interface{}, username interface{}, password interface{}, authMech interface{}, certificate interface{}, san_in_certificate interface{}, clientCertificate interface{}, clientKey interface{}, insecureSkipVerify interface{}, httpCommand interface{}, contentType interface{}, body interface{}, timeout interface{}, out interface{}, client interface{}, keep_client_alive interface{}, logger interface{}, num_retry interface{}) *UtilsIface_InvokeRestWithRetryWithAuth_Call {
	return &UtilsIface_InvokeRestWithRetryWithAuth_Call{Call: _e.mock.On("InvokeRestWithRetryWithAuth", baseURL, path, preservePathEncoding, username, password, authMech, certificate, san_in_certificate, clientCertificate, clientKey, insecureSkipVerify, httpCommand, contentType, body, timeout, out, client, keep_client_alive, logger, num_retry)}
}

func (_c *UtilsIface_InvokeRestWithRetryWithAuth_Call) Run(run func(baseURL string, path string, preservePathEncoding bool, username string, password string, authMech base.HttpAuthMech, certificate []byte, san_in_certificate bool, clientCertificate []byte, clientKey []byte, insecureSkipVerify bool, httpCommand string, contentType string, body []byte, timeout time.Duration, out interface{}, client *http.Client, keep_client_alive bool, logger *log.CommonLogger, num_retry int)) *UtilsIface_InvokeRestWithRetryWithAuth_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].(bool), args[3].(string), args[4].(string), args[5].(base.HttpAuthMech), args[6].([]byte), args[7].(bool), args[8].([]byte), args[9].([]byte), args[10].(bool), args[11].(string), args[12].(string), args[13].([]byte), args[14].(time.Duration), args[15].(interface{}), args[16].(*http.Client), args[17].(bool), args[18].(*log.CommonLogger), args[19].(int))
	})
	return _c
}

func (_c *UtilsIface_InvokeRestWithRetryWithAuth_Call) Return(_a0 error, _a1 int) *UtilsIface_InvokeRestWithRetryWithAuth_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *UtilsIface_InvokeRestWithRetryWithAuth_Call) RunAndReturn(run func(string, string, bool, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, bool, string, string, []byte, time.Duration, interface{}, *http.Client, bool, *log.CommonLogger, int) (error, int)) *UtilsIface_InvokeRestWithRetryWithAuth_Call {
	_c.Call.Return(run)
	return _c
}

// IsSeriousNetError provides a mock function with given fields: err
func (_m *UtilsIface) IsSeriousNetError(err error) bool {
	ret := _m.Called(err)

	var r0 bool
	if rf, ok := ret.Get(0).(func(error) bool); ok {
		r0 = rf(err)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// UtilsIface_IsSeriousNetError_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsSeriousNetError'
type UtilsIface_IsSeriousNetError_Call struct {
	*mock.Call
}

// IsSeriousNetError is a helper method to define mock.On call
//   - err error
func (_e *UtilsIface_Expecter) IsSeriousNetError(err interface{}) *UtilsIface_IsSeriousNetError_Call {
	return &UtilsIface_IsSeriousNetError_Call{Call: _e.mock.On("IsSeriousNetError", err)}
}

func (_c *UtilsIface_IsSeriousNetError_Call) Run(run func(err error)) *UtilsIface_IsSeriousNetError_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(error))
	})
	return _c
}

func (_c *UtilsIface_IsSeriousNetError_Call) Return(_a0 bool) *UtilsIface_IsSeriousNetError_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *UtilsIface_IsSeriousNetError_Call) RunAndReturn(run func(error) bool) *UtilsIface_IsSeriousNetError_Call {
	_c.Call.Return(run)
	return _c
}

// LocalBucket provides a mock function with given fields: localConnectStr, bucketName
func (_m *UtilsIface) LocalBucket(localConnectStr string, bucketName string) (*couchbase.Bucket, error) {
	ret := _m.Called(localConnectStr, bucketName)

	var r0 *couchbase.Bucket
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string) (*couchbase.Bucket, error)); ok {
		return rf(localConnectStr, bucketName)
	}
	if rf, ok := ret.Get(0).(func(string, string) *couchbase.Bucket); ok {
		r0 = rf(localConnectStr, bucketName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*couchbase.Bucket)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(localConnectStr, bucketName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UtilsIface_LocalBucket_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LocalBucket'
type UtilsIface_LocalBucket_Call struct {
	*mock.Call
}

// LocalBucket is a helper method to define mock.On call
//   - localConnectStr string
//   - bucketName string
func (_e *UtilsIface_Expecter) LocalBucket(localConnectStr interface{}, bucketName interface{}) *UtilsIface_LocalBucket_Call {
	return &UtilsIface_LocalBucket_Call{Call: _e.mock.On("LocalBucket", localConnectStr, bucketName)}
}

func (_c *UtilsIface_LocalBucket_Call) Run(run func(localConnectStr string, bucketName string)) *UtilsIface_LocalBucket_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *UtilsIface_LocalBucket_Call) Return(_a0 *couchbase.Bucket, _a1 error) *UtilsIface_LocalBucket_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *UtilsIface_LocalBucket_Call) RunAndReturn(run func(string, string) (*couchbase.Bucket, error)) *UtilsIface_LocalBucket_Call {
	_c.Call.Return(run)
	return _c
}

// LocalBucketUUID provides a mock function with given fields: local_connStr, bucketName, logger
func (_m *UtilsIface) LocalBucketUUID(local_connStr string, bucketName string, logger *log.CommonLogger) (string, error) {
	ret := _m.Called(local_connStr, bucketName, logger)

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, *log.CommonLogger) (string, error)); ok {
		return rf(local_connStr, bucketName, logger)
	}
	if rf, ok := ret.Get(0).(func(string, string, *log.CommonLogger) string); ok {
		r0 = rf(local_connStr, bucketName, logger)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string, string, *log.CommonLogger) error); ok {
		r1 = rf(local_connStr, bucketName, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UtilsIface_LocalBucketUUID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LocalBucketUUID'
type UtilsIface_LocalBucketUUID_Call struct {
	*mock.Call
}

// LocalBucketUUID is a helper method to define mock.On call
//   - local_connStr string
//   - bucketName string
//   - logger *log.CommonLogger
func (_e *UtilsIface_Expecter) LocalBucketUUID(local_connStr interface{}, bucketName interface{}, logger interface{}) *UtilsIface_LocalBucketUUID_Call {
	return &UtilsIface_LocalBucketUUID_Call{Call: _e.mock.On("LocalBucketUUID", local_connStr, bucketName, logger)}
}

func (_c *UtilsIface_LocalBucketUUID_Call) Run(run func(local_connStr string, bucketName string, logger *log.CommonLogger)) *UtilsIface_LocalBucketUUID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].(*log.CommonLogger))
	})
	return _c
}

func (_c *UtilsIface_LocalBucketUUID_Call) Return(_a0 string, _a1 error) *UtilsIface_LocalBucketUUID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *UtilsIface_LocalBucketUUID_Call) RunAndReturn(run func(string, string, *log.CommonLogger) (string, error)) *UtilsIface_LocalBucketUUID_Call {
	_c.Call.Return(run)
	return _c
}

// LocalPool provides a mock function with given fields: localConnectStr
func (_m *UtilsIface) LocalPool(localConnectStr string) (couchbase.Pool, error) {
	ret := _m.Called(localConnectStr)

	var r0 couchbase.Pool
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (couchbase.Pool, error)); ok {
		return rf(localConnectStr)
	}
	if rf, ok := ret.Get(0).(func(string) couchbase.Pool); ok {
		r0 = rf(localConnectStr)
	} else {
		r0 = ret.Get(0).(couchbase.Pool)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(localConnectStr)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UtilsIface_LocalPool_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LocalPool'
type UtilsIface_LocalPool_Call struct {
	*mock.Call
}

// LocalPool is a helper method to define mock.On call
//   - localConnectStr string
func (_e *UtilsIface_Expecter) LocalPool(localConnectStr interface{}) *UtilsIface_LocalPool_Call {
	return &UtilsIface_LocalPool_Call{Call: _e.mock.On("LocalPool", localConnectStr)}
}

func (_c *UtilsIface_LocalPool_Call) Run(run func(localConnectStr string)) *UtilsIface_LocalPool_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *UtilsIface_LocalPool_Call) Return(_a0 couchbase.Pool, _a1 error) *UtilsIface_LocalPool_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *UtilsIface_LocalPool_Call) RunAndReturn(run func(string) (couchbase.Pool, error)) *UtilsIface_LocalPool_Call {
	_c.Call.Return(run)
	return _c
}

// NewDataPool provides a mock function with given fields:
func (_m *UtilsIface) NewDataPool() base.DataPool {
	ret := _m.Called()

	var r0 base.DataPool
	if rf, ok := ret.Get(0).(func() base.DataPool); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(base.DataPool)
		}
	}

	return r0
}

// UtilsIface_NewDataPool_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NewDataPool'
type UtilsIface_NewDataPool_Call struct {
	*mock.Call
}

// NewDataPool is a helper method to define mock.On call
func (_e *UtilsIface_Expecter) NewDataPool() *UtilsIface_NewDataPool_Call {
	return &UtilsIface_NewDataPool_Call{Call: _e.mock.On("NewDataPool")}
}

func (_c *UtilsIface_NewDataPool_Call) Run(run func()) *UtilsIface_NewDataPool_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *UtilsIface_NewDataPool_Call) Return(_a0 base.DataPool) *UtilsIface_NewDataPool_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *UtilsIface_NewDataPool_Call) RunAndReturn(run func() base.DataPool) *UtilsIface_NewDataPool_Call {
	_c.Call.Return(run)
	return _c
}

// NewEnhancedError provides a mock function with given fields: msg, err
func (_m *UtilsIface) NewEnhancedError(msg string, err error) error {
	ret := _m.Called(msg, err)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, error) error); ok {
		r0 = rf(msg, err)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UtilsIface_NewEnhancedError_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NewEnhancedError'
type UtilsIface_NewEnhancedError_Call struct {
	*mock.Call
}

// NewEnhancedError is a helper method to define mock.On call
//   - msg string
//   - err error
func (_e *UtilsIface_Expecter) NewEnhancedError(msg interface{}, err interface{}) *UtilsIface_NewEnhancedError_Call {
	return &UtilsIface_NewEnhancedError_Call{Call: _e.mock.On("NewEnhancedError", msg, err)}
}

func (_c *UtilsIface_NewEnhancedError_Call) Run(run func(msg string, err error)) *UtilsIface_NewEnhancedError_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(error))
	})
	return _c
}

func (_c *UtilsIface_NewEnhancedError_Call) Return(_a0 error) *UtilsIface_NewEnhancedError_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *UtilsIface_NewEnhancedError_Call) RunAndReturn(run func(string, error) error) *UtilsIface_NewEnhancedError_Call {
	_c.Call.Return(run)
	return _c
}

// NewTCPConn provides a mock function with given fields: hostName
func (_m *UtilsIface) NewTCPConn(hostName string) (*net.TCPConn, error) {
	ret := _m.Called(hostName)

	var r0 *net.TCPConn
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (*net.TCPConn, error)); ok {
		return rf(hostName)
	}
	if rf, ok := ret.Get(0).(func(string) *net.TCPConn); ok {
		r0 = rf(hostName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*net.TCPConn)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(hostName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UtilsIface_NewTCPConn_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NewTCPConn'
type UtilsIface_NewTCPConn_Call struct {
	*mock.Call
}

// NewTCPConn is a helper method to define mock.On call
//   - hostName string
func (_e *UtilsIface_Expecter) NewTCPConn(hostName interface{}) *UtilsIface_NewTCPConn_Call {
	return &UtilsIface_NewTCPConn_Call{Call: _e.mock.On("NewTCPConn", hostName)}
}

func (_c *UtilsIface_NewTCPConn_Call) Run(run func(hostName string)) *UtilsIface_NewTCPConn_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *UtilsIface_NewTCPConn_Call) Return(_a0 *net.TCPConn, _a1 error) *UtilsIface_NewTCPConn_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *UtilsIface_NewTCPConn_Call) RunAndReturn(run func(string) (*net.TCPConn, error)) *UtilsIface_NewTCPConn_Call {
	_c.Call.Return(run)
	return _c
}

// ParseHighSeqnoAndVBUuidFromStats provides a mock function with given fields: vbnos, stats_map, high_seqno_and_vbuuid_map
func (_m *UtilsIface) ParseHighSeqnoAndVBUuidFromStats(vbnos []uint16, stats_map map[string]string, high_seqno_and_vbuuid_map map[uint16][]uint64) ([]uint16, map[uint16]string) {
	ret := _m.Called(vbnos, stats_map, high_seqno_and_vbuuid_map)

	var r0 []uint16
	var r1 map[uint16]string
	if rf, ok := ret.Get(0).(func([]uint16, map[string]string, map[uint16][]uint64) ([]uint16, map[uint16]string)); ok {
		return rf(vbnos, stats_map, high_seqno_and_vbuuid_map)
	}
	if rf, ok := ret.Get(0).(func([]uint16, map[string]string, map[uint16][]uint64) []uint16); ok {
		r0 = rf(vbnos, stats_map, high_seqno_and_vbuuid_map)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]uint16)
		}
	}

	if rf, ok := ret.Get(1).(func([]uint16, map[string]string, map[uint16][]uint64) map[uint16]string); ok {
		r1 = rf(vbnos, stats_map, high_seqno_and_vbuuid_map)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(map[uint16]string)
		}
	}

	return r0, r1
}

// UtilsIface_ParseHighSeqnoAndVBUuidFromStats_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ParseHighSeqnoAndVBUuidFromStats'
type UtilsIface_ParseHighSeqnoAndVBUuidFromStats_Call struct {
	*mock.Call
}

// ParseHighSeqnoAndVBUuidFromStats is a helper method to define mock.On call
//   - vbnos []uint16
//   - stats_map map[string]string
//   - high_seqno_and_vbuuid_map map[uint16][]uint64
func (_e *UtilsIface_Expecter) ParseHighSeqnoAndVBUuidFromStats(vbnos interface{}, stats_map interface{}, high_seqno_and_vbuuid_map interface{}) *UtilsIface_ParseHighSeqnoAndVBUuidFromStats_Call {
	return &UtilsIface_ParseHighSeqnoAndVBUuidFromStats_Call{Call: _e.mock.On("ParseHighSeqnoAndVBUuidFromStats", vbnos, stats_map, high_seqno_and_vbuuid_map)}
}

func (_c *UtilsIface_ParseHighSeqnoAndVBUuidFromStats_Call) Run(run func(vbnos []uint16, stats_map map[string]string, high_seqno_and_vbuuid_map map[uint16][]uint64)) *UtilsIface_ParseHighSeqnoAndVBUuidFromStats_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]uint16), args[1].(map[string]string), args[2].(map[uint16][]uint64))
	})
	return _c
}

func (_c *UtilsIface_ParseHighSeqnoAndVBUuidFromStats_Call) Return(_a0 []uint16, _a1 map[uint16]string) *UtilsIface_ParseHighSeqnoAndVBUuidFromStats_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *UtilsIface_ParseHighSeqnoAndVBUuidFromStats_Call) RunAndReturn(run func([]uint16, map[string]string, map[uint16][]uint64) ([]uint16, map[uint16]string)) *UtilsIface_ParseHighSeqnoAndVBUuidFromStats_Call {
	_c.Call.Return(run)
	return _c
}

// ParseHighSeqnoStat provides a mock function with given fields: vbnos, stats_map, highseqno_map
func (_m *UtilsIface) ParseHighSeqnoStat(vbnos []uint16, stats_map map[string]string, highseqno_map map[uint16]uint64) ([]uint16, error) {
	ret := _m.Called(vbnos, stats_map, highseqno_map)

	var r0 []uint16
	var r1 error
	if rf, ok := ret.Get(0).(func([]uint16, map[string]string, map[uint16]uint64) ([]uint16, error)); ok {
		return rf(vbnos, stats_map, highseqno_map)
	}
	if rf, ok := ret.Get(0).(func([]uint16, map[string]string, map[uint16]uint64) []uint16); ok {
		r0 = rf(vbnos, stats_map, highseqno_map)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]uint16)
		}
	}

	if rf, ok := ret.Get(1).(func([]uint16, map[string]string, map[uint16]uint64) error); ok {
		r1 = rf(vbnos, stats_map, highseqno_map)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UtilsIface_ParseHighSeqnoStat_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ParseHighSeqnoStat'
type UtilsIface_ParseHighSeqnoStat_Call struct {
	*mock.Call
}

// ParseHighSeqnoStat is a helper method to define mock.On call
//   - vbnos []uint16
//   - stats_map map[string]string
//   - highseqno_map map[uint16]uint64
func (_e *UtilsIface_Expecter) ParseHighSeqnoStat(vbnos interface{}, stats_map interface{}, highseqno_map interface{}) *UtilsIface_ParseHighSeqnoStat_Call {
	return &UtilsIface_ParseHighSeqnoStat_Call{Call: _e.mock.On("ParseHighSeqnoStat", vbnos, stats_map, highseqno_map)}
}

func (_c *UtilsIface_ParseHighSeqnoStat_Call) Run(run func(vbnos []uint16, stats_map map[string]string, highseqno_map map[uint16]uint64)) *UtilsIface_ParseHighSeqnoStat_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]uint16), args[1].(map[string]string), args[2].(map[uint16]uint64))
	})
	return _c
}

func (_c *UtilsIface_ParseHighSeqnoStat_Call) Return(_a0 []uint16, _a1 error) *UtilsIface_ParseHighSeqnoStat_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *UtilsIface_ParseHighSeqnoStat_Call) RunAndReturn(run func([]uint16, map[string]string, map[uint16]uint64) ([]uint16, error)) *UtilsIface_ParseHighSeqnoStat_Call {
	_c.Call.Return(run)
	return _c
}

// ProcessUprEventForFiltering provides a mock function with given fields: uprEvent, body, endBodyPos, dp, flags, slicesBuf
func (_m *UtilsIface) ProcessUprEventForFiltering(uprEvent *memcached.UprEvent, body []byte, endBodyPos int, dp base.DataPool, flags base.FilterFlagType, slicesBuf *[][]byte) ([]byte, error, string, int64) {
	ret := _m.Called(uprEvent, body, endBodyPos, dp, flags, slicesBuf)

	var r0 []byte
	var r1 error
	var r2 string
	var r3 int64
	if rf, ok := ret.Get(0).(func(*memcached.UprEvent, []byte, int, base.DataPool, base.FilterFlagType, *[][]byte) ([]byte, error, string, int64)); ok {
		return rf(uprEvent, body, endBodyPos, dp, flags, slicesBuf)
	}
	if rf, ok := ret.Get(0).(func(*memcached.UprEvent, []byte, int, base.DataPool, base.FilterFlagType, *[][]byte) []byte); ok {
		r0 = rf(uprEvent, body, endBodyPos, dp, flags, slicesBuf)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(*memcached.UprEvent, []byte, int, base.DataPool, base.FilterFlagType, *[][]byte) error); ok {
		r1 = rf(uprEvent, body, endBodyPos, dp, flags, slicesBuf)
	} else {
		r1 = ret.Error(1)
	}

	if rf, ok := ret.Get(2).(func(*memcached.UprEvent, []byte, int, base.DataPool, base.FilterFlagType, *[][]byte) string); ok {
		r2 = rf(uprEvent, body, endBodyPos, dp, flags, slicesBuf)
	} else {
		r2 = ret.Get(2).(string)
	}

	if rf, ok := ret.Get(3).(func(*memcached.UprEvent, []byte, int, base.DataPool, base.FilterFlagType, *[][]byte) int64); ok {
		r3 = rf(uprEvent, body, endBodyPos, dp, flags, slicesBuf)
	} else {
		r3 = ret.Get(3).(int64)
	}

	return r0, r1, r2, r3
}

// UtilsIface_ProcessUprEventForFiltering_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ProcessUprEventForFiltering'
type UtilsIface_ProcessUprEventForFiltering_Call struct {
	*mock.Call
}

// ProcessUprEventForFiltering is a helper method to define mock.On call
//   - uprEvent *memcached.UprEvent
//   - body []byte
//   - endBodyPos int
//   - dp base.DataPool
//   - flags base.FilterFlagType
//   - slicesBuf *[][]byte
func (_e *UtilsIface_Expecter) ProcessUprEventForFiltering(uprEvent interface{}, body interface{}, endBodyPos interface{}, dp interface{}, flags interface{}, slicesBuf interface{}) *UtilsIface_ProcessUprEventForFiltering_Call {
	return &UtilsIface_ProcessUprEventForFiltering_Call{Call: _e.mock.On("ProcessUprEventForFiltering", uprEvent, body, endBodyPos, dp, flags, slicesBuf)}
}

func (_c *UtilsIface_ProcessUprEventForFiltering_Call) Run(run func(uprEvent *memcached.UprEvent, body []byte, endBodyPos int, dp base.DataPool, flags base.FilterFlagType, slicesBuf *[][]byte)) *UtilsIface_ProcessUprEventForFiltering_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*memcached.UprEvent), args[1].([]byte), args[2].(int), args[3].(base.DataPool), args[4].(base.FilterFlagType), args[5].(*[][]byte))
	})
	return _c
}

func (_c *UtilsIface_ProcessUprEventForFiltering_Call) Return(_a0 []byte, _a1 error, _a2 string, _a3 int64) *UtilsIface_ProcessUprEventForFiltering_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3)
	return _c
}

func (_c *UtilsIface_ProcessUprEventForFiltering_Call) RunAndReturn(run func(*memcached.UprEvent, []byte, int, base.DataPool, base.FilterFlagType, *[][]byte) ([]byte, error, string, int64)) *UtilsIface_ProcessUprEventForFiltering_Call {
	_c.Call.Return(run)
	return _c
}

// QueryRestApi provides a mock function with given fields: baseURL, path, preservePathEncoding, httpCommand, contentType, body, timeout, out, logger
func (_m *UtilsIface) QueryRestApi(baseURL string, path string, preservePathEncoding bool, httpCommand string, contentType string, body []byte, timeout time.Duration, out interface{}, logger *log.CommonLogger) (error, int) {
	ret := _m.Called(baseURL, path, preservePathEncoding, httpCommand, contentType, body, timeout, out, logger)

	var r0 error
	var r1 int
	if rf, ok := ret.Get(0).(func(string, string, bool, string, string, []byte, time.Duration, interface{}, *log.CommonLogger) (error, int)); ok {
		return rf(baseURL, path, preservePathEncoding, httpCommand, contentType, body, timeout, out, logger)
	}
	if rf, ok := ret.Get(0).(func(string, string, bool, string, string, []byte, time.Duration, interface{}, *log.CommonLogger) error); ok {
		r0 = rf(baseURL, path, preservePathEncoding, httpCommand, contentType, body, timeout, out, logger)
	} else {
		r0 = ret.Error(0)
	}

	if rf, ok := ret.Get(1).(func(string, string, bool, string, string, []byte, time.Duration, interface{}, *log.CommonLogger) int); ok {
		r1 = rf(baseURL, path, preservePathEncoding, httpCommand, contentType, body, timeout, out, logger)
	} else {
		r1 = ret.Get(1).(int)
	}

	return r0, r1
}

// UtilsIface_QueryRestApi_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'QueryRestApi'
type UtilsIface_QueryRestApi_Call struct {
	*mock.Call
}

// QueryRestApi is a helper method to define mock.On call
//   - baseURL string
//   - path string
//   - preservePathEncoding bool
//   - httpCommand string
//   - contentType string
//   - body []byte
//   - timeout time.Duration
//   - out interface{}
//   - logger *log.CommonLogger
func (_e *UtilsIface_Expecter) QueryRestApi(baseURL interface{}, path interface{}, preservePathEncoding interface{}, httpCommand interface{}, contentType interface{}, body interface{}, timeout interface{}, out interface{}, logger interface{}) *UtilsIface_QueryRestApi_Call {
	return &UtilsIface_QueryRestApi_Call{Call: _e.mock.On("QueryRestApi", baseURL, path, preservePathEncoding, httpCommand, contentType, body, timeout, out, logger)}
}

func (_c *UtilsIface_QueryRestApi_Call) Run(run func(baseURL string, path string, preservePathEncoding bool, httpCommand string, contentType string, body []byte, timeout time.Duration, out interface{}, logger *log.CommonLogger)) *UtilsIface_QueryRestApi_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].(bool), args[3].(string), args[4].(string), args[5].([]byte), args[6].(time.Duration), args[7].(interface{}), args[8].(*log.CommonLogger))
	})
	return _c
}

func (_c *UtilsIface_QueryRestApi_Call) Return(_a0 error, _a1 int) *UtilsIface_QueryRestApi_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *UtilsIface_QueryRestApi_Call) RunAndReturn(run func(string, string, bool, string, string, []byte, time.Duration, interface{}, *log.CommonLogger) (error, int)) *UtilsIface_QueryRestApi_Call {
	_c.Call.Return(run)
	return _c
}

// QueryRestApiWithAuth provides a mock function with given fields: baseURL, path, preservePathEncoding, username, password, authMech, certificate, san_in_certificate, clientCertificate, clientKey, httpCommand, contentType, body, timeout, out, client, keep_client_alive, logger
func (_m *UtilsIface) QueryRestApiWithAuth(baseURL string, path string, preservePathEncoding bool, username string, password string, authMech base.HttpAuthMech, certificate []byte, san_in_certificate bool, clientCertificate []byte, clientKey []byte, httpCommand string, contentType string, body []byte, timeout time.Duration, out interface{}, client *http.Client, keep_client_alive bool, logger *log.CommonLogger) (error, int) {
	ret := _m.Called(baseURL, path, preservePathEncoding, username, password, authMech, certificate, san_in_certificate, clientCertificate, clientKey, httpCommand, contentType, body, timeout, out, client, keep_client_alive, logger)

	var r0 error
	var r1 int
	if rf, ok := ret.Get(0).(func(string, string, bool, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, string, string, []byte, time.Duration, interface{}, *http.Client, bool, *log.CommonLogger) (error, int)); ok {
		return rf(baseURL, path, preservePathEncoding, username, password, authMech, certificate, san_in_certificate, clientCertificate, clientKey, httpCommand, contentType, body, timeout, out, client, keep_client_alive, logger)
	}
	if rf, ok := ret.Get(0).(func(string, string, bool, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, string, string, []byte, time.Duration, interface{}, *http.Client, bool, *log.CommonLogger) error); ok {
		r0 = rf(baseURL, path, preservePathEncoding, username, password, authMech, certificate, san_in_certificate, clientCertificate, clientKey, httpCommand, contentType, body, timeout, out, client, keep_client_alive, logger)
	} else {
		r0 = ret.Error(0)
	}

	if rf, ok := ret.Get(1).(func(string, string, bool, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, string, string, []byte, time.Duration, interface{}, *http.Client, bool, *log.CommonLogger) int); ok {
		r1 = rf(baseURL, path, preservePathEncoding, username, password, authMech, certificate, san_in_certificate, clientCertificate, clientKey, httpCommand, contentType, body, timeout, out, client, keep_client_alive, logger)
	} else {
		r1 = ret.Get(1).(int)
	}

	return r0, r1
}

// UtilsIface_QueryRestApiWithAuth_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'QueryRestApiWithAuth'
type UtilsIface_QueryRestApiWithAuth_Call struct {
	*mock.Call
}

// QueryRestApiWithAuth is a helper method to define mock.On call
//   - baseURL string
//   - path string
//   - preservePathEncoding bool
//   - username string
//   - password string
//   - authMech base.HttpAuthMech
//   - certificate []byte
//   - san_in_certificate bool
//   - clientCertificate []byte
//   - clientKey []byte
//   - httpCommand string
//   - contentType string
//   - body []byte
//   - timeout time.Duration
//   - out interface{}
//   - client *http.Client
//   - keep_client_alive bool
//   - logger *log.CommonLogger
func (_e *UtilsIface_Expecter) QueryRestApiWithAuth(baseURL interface{}, path interface{}, preservePathEncoding interface{}, username interface{}, password interface{}, authMech interface{}, certificate interface{}, san_in_certificate interface{}, clientCertificate interface{}, clientKey interface{}, httpCommand interface{}, contentType interface{}, body interface{}, timeout interface{}, out interface{}, client interface{}, keep_client_alive interface{}, logger interface{}) *UtilsIface_QueryRestApiWithAuth_Call {
	return &UtilsIface_QueryRestApiWithAuth_Call{Call: _e.mock.On("QueryRestApiWithAuth", baseURL, path, preservePathEncoding, username, password, authMech, certificate, san_in_certificate, clientCertificate, clientKey, httpCommand, contentType, body, timeout, out, client, keep_client_alive, logger)}
}

func (_c *UtilsIface_QueryRestApiWithAuth_Call) Run(run func(baseURL string, path string, preservePathEncoding bool, username string, password string, authMech base.HttpAuthMech, certificate []byte, san_in_certificate bool, clientCertificate []byte, clientKey []byte, httpCommand string, contentType string, body []byte, timeout time.Duration, out interface{}, client *http.Client, keep_client_alive bool, logger *log.CommonLogger)) *UtilsIface_QueryRestApiWithAuth_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].(bool), args[3].(string), args[4].(string), args[5].(base.HttpAuthMech), args[6].([]byte), args[7].(bool), args[8].([]byte), args[9].([]byte), args[10].(string), args[11].(string), args[12].([]byte), args[13].(time.Duration), args[14].(interface{}), args[15].(*http.Client), args[16].(bool), args[17].(*log.CommonLogger))
	})
	return _c
}

func (_c *UtilsIface_QueryRestApiWithAuth_Call) Return(_a0 error, _a1 int) *UtilsIface_QueryRestApiWithAuth_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *UtilsIface_QueryRestApiWithAuth_Call) RunAndReturn(run func(string, string, bool, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, string, string, []byte, time.Duration, interface{}, *http.Client, bool, *log.CommonLogger) (error, int)) *UtilsIface_QueryRestApiWithAuth_Call {
	_c.Call.Return(run)
	return _c
}

// RecoverPanic provides a mock function with given fields: err
func (_m *UtilsIface) RecoverPanic(err *error) {
	_m.Called(err)
}

// UtilsIface_RecoverPanic_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RecoverPanic'
type UtilsIface_RecoverPanic_Call struct {
	*mock.Call
}

// RecoverPanic is a helper method to define mock.On call
//   - err *error
func (_e *UtilsIface_Expecter) RecoverPanic(err interface{}) *UtilsIface_RecoverPanic_Call {
	return &UtilsIface_RecoverPanic_Call{Call: _e.mock.On("RecoverPanic", err)}
}

func (_c *UtilsIface_RecoverPanic_Call) Run(run func(err *error)) *UtilsIface_RecoverPanic_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*error))
	})
	return _c
}

func (_c *UtilsIface_RecoverPanic_Call) Return() *UtilsIface_RecoverPanic_Call {
	_c.Call.Return()
	return _c
}

func (_c *UtilsIface_RecoverPanic_Call) RunAndReturn(run func(*error)) *UtilsIface_RecoverPanic_Call {
	_c.Call.Return(run)
	return _c
}

// RemoteBucketValidationInfo provides a mock function with given fields: hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger, useExternal
func (_m *UtilsIface) RemoteBucketValidationInfo(hostAddr string, bucketName string, username string, password string, authMech base.HttpAuthMech, certificate []byte, sanInCertificate bool, clientCertificate []byte, clientKey []byte, logger *log.CommonLogger, useExternal bool) (map[string]interface{}, string, string, string, string, map[string][]uint16, error) {
	ret := _m.Called(hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger, useExternal)

	var r0 map[string]interface{}
	var r1 string
	var r2 string
	var r3 string
	var r4 string
	var r5 map[string][]uint16
	var r6 error
	if rf, ok := ret.Get(0).(func(string, string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger, bool) (map[string]interface{}, string, string, string, string, map[string][]uint16, error)); ok {
		return rf(hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger, useExternal)
	}
	if rf, ok := ret.Get(0).(func(string, string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger, bool) map[string]interface{}); ok {
		r0 = rf(hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger, useExternal)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger, bool) string); ok {
		r1 = rf(hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger, useExternal)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(string, string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger, bool) string); ok {
		r2 = rf(hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger, useExternal)
	} else {
		r2 = ret.Get(2).(string)
	}

	if rf, ok := ret.Get(3).(func(string, string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger, bool) string); ok {
		r3 = rf(hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger, useExternal)
	} else {
		r3 = ret.Get(3).(string)
	}

	if rf, ok := ret.Get(4).(func(string, string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger, bool) string); ok {
		r4 = rf(hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger, useExternal)
	} else {
		r4 = ret.Get(4).(string)
	}

	if rf, ok := ret.Get(5).(func(string, string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger, bool) map[string][]uint16); ok {
		r5 = rf(hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger, useExternal)
	} else {
		if ret.Get(5) != nil {
			r5 = ret.Get(5).(map[string][]uint16)
		}
	}

	if rf, ok := ret.Get(6).(func(string, string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger, bool) error); ok {
		r6 = rf(hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger, useExternal)
	} else {
		r6 = ret.Error(6)
	}

	return r0, r1, r2, r3, r4, r5, r6
}

// UtilsIface_RemoteBucketValidationInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoteBucketValidationInfo'
type UtilsIface_RemoteBucketValidationInfo_Call struct {
	*mock.Call
}

// RemoteBucketValidationInfo is a helper method to define mock.On call
//   - hostAddr string
//   - bucketName string
//   - username string
//   - password string
//   - authMech base.HttpAuthMech
//   - certificate []byte
//   - sanInCertificate bool
//   - clientCertificate []byte
//   - clientKey []byte
//   - logger *log.CommonLogger
//   - useExternal bool
func (_e *UtilsIface_Expecter) RemoteBucketValidationInfo(hostAddr interface{}, bucketName interface{}, username interface{}, password interface{}, authMech interface{}, certificate interface{}, sanInCertificate interface{}, clientCertificate interface{}, clientKey interface{}, logger interface{}, useExternal interface{}) *UtilsIface_RemoteBucketValidationInfo_Call {
	return &UtilsIface_RemoteBucketValidationInfo_Call{Call: _e.mock.On("RemoteBucketValidationInfo", hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger, useExternal)}
}

func (_c *UtilsIface_RemoteBucketValidationInfo_Call) Run(run func(hostAddr string, bucketName string, username string, password string, authMech base.HttpAuthMech, certificate []byte, sanInCertificate bool, clientCertificate []byte, clientKey []byte, logger *log.CommonLogger, useExternal bool)) *UtilsIface_RemoteBucketValidationInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].(string), args[3].(string), args[4].(base.HttpAuthMech), args[5].([]byte), args[6].(bool), args[7].([]byte), args[8].([]byte), args[9].(*log.CommonLogger), args[10].(bool))
	})
	return _c
}

func (_c *UtilsIface_RemoteBucketValidationInfo_Call) Return(bucketInfo map[string]interface{}, bucketType string, bucketUUID string, bucketConflictResolutionType string, bucketEvictionPolicy string, bucketKVVBMap map[string][]uint16, err error) *UtilsIface_RemoteBucketValidationInfo_Call {
	_c.Call.Return(bucketInfo, bucketType, bucketUUID, bucketConflictResolutionType, bucketEvictionPolicy, bucketKVVBMap, err)
	return _c
}

func (_c *UtilsIface_RemoteBucketValidationInfo_Call) RunAndReturn(run func(string, string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger, bool) (map[string]interface{}, string, string, string, string, map[string][]uint16, error)) *UtilsIface_RemoteBucketValidationInfo_Call {
	_c.Call.Return(run)
	return _c
}

// RemovePrefix provides a mock function with given fields: prefix, str
func (_m *UtilsIface) RemovePrefix(prefix string, str string) string {
	ret := _m.Called(prefix, str)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, string) string); ok {
		r0 = rf(prefix, str)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// UtilsIface_RemovePrefix_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemovePrefix'
type UtilsIface_RemovePrefix_Call struct {
	*mock.Call
}

// RemovePrefix is a helper method to define mock.On call
//   - prefix string
//   - str string
func (_e *UtilsIface_Expecter) RemovePrefix(prefix interface{}, str interface{}) *UtilsIface_RemovePrefix_Call {
	return &UtilsIface_RemovePrefix_Call{Call: _e.mock.On("RemovePrefix", prefix, str)}
}

func (_c *UtilsIface_RemovePrefix_Call) Run(run func(prefix string, str string)) *UtilsIface_RemovePrefix_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *UtilsIface_RemovePrefix_Call) Return(_a0 string) *UtilsIface_RemovePrefix_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *UtilsIface_RemovePrefix_Call) RunAndReturn(run func(string, string) string) *UtilsIface_RemovePrefix_Call {
	_c.Call.Return(run)
	return _c
}

// ReplaceCouchApiBaseObjWithExternals provides a mock function with given fields: couchApiBase, nodeInfo
func (_m *UtilsIface) ReplaceCouchApiBaseObjWithExternals(couchApiBase string, nodeInfo map[string]interface{}) string {
	ret := _m.Called(couchApiBase, nodeInfo)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, map[string]interface{}) string); ok {
		r0 = rf(couchApiBase, nodeInfo)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// UtilsIface_ReplaceCouchApiBaseObjWithExternals_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReplaceCouchApiBaseObjWithExternals'
type UtilsIface_ReplaceCouchApiBaseObjWithExternals_Call struct {
	*mock.Call
}

// ReplaceCouchApiBaseObjWithExternals is a helper method to define mock.On call
//   - couchApiBase string
//   - nodeInfo map[string]interface{}
func (_e *UtilsIface_Expecter) ReplaceCouchApiBaseObjWithExternals(couchApiBase interface{}, nodeInfo interface{}) *UtilsIface_ReplaceCouchApiBaseObjWithExternals_Call {
	return &UtilsIface_ReplaceCouchApiBaseObjWithExternals_Call{Call: _e.mock.On("ReplaceCouchApiBaseObjWithExternals", couchApiBase, nodeInfo)}
}

func (_c *UtilsIface_ReplaceCouchApiBaseObjWithExternals_Call) Run(run func(couchApiBase string, nodeInfo map[string]interface{})) *UtilsIface_ReplaceCouchApiBaseObjWithExternals_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(map[string]interface{}))
	})
	return _c
}

func (_c *UtilsIface_ReplaceCouchApiBaseObjWithExternals_Call) Return(_a0 string) *UtilsIface_ReplaceCouchApiBaseObjWithExternals_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *UtilsIface_ReplaceCouchApiBaseObjWithExternals_Call) RunAndReturn(run func(string, map[string]interface{}) string) *UtilsIface_ReplaceCouchApiBaseObjWithExternals_Call {
	_c.Call.Return(run)
	return _c
}

// ReplicationStatusNotFoundError provides a mock function with given fields: topic
func (_m *UtilsIface) ReplicationStatusNotFoundError(topic string) error {
	ret := _m.Called(topic)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(topic)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UtilsIface_ReplicationStatusNotFoundError_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReplicationStatusNotFoundError'
type UtilsIface_ReplicationStatusNotFoundError_Call struct {
	*mock.Call
}

// ReplicationStatusNotFoundError is a helper method to define mock.On call
//   - topic string
func (_e *UtilsIface_Expecter) ReplicationStatusNotFoundError(topic interface{}) *UtilsIface_ReplicationStatusNotFoundError_Call {
	return &UtilsIface_ReplicationStatusNotFoundError_Call{Call: _e.mock.On("ReplicationStatusNotFoundError", topic)}
}

func (_c *UtilsIface_ReplicationStatusNotFoundError_Call) Run(run func(topic string)) *UtilsIface_ReplicationStatusNotFoundError_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *UtilsIface_ReplicationStatusNotFoundError_Call) Return(_a0 error) *UtilsIface_ReplicationStatusNotFoundError_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *UtilsIface_ReplicationStatusNotFoundError_Call) RunAndReturn(run func(string) error) *UtilsIface_ReplicationStatusNotFoundError_Call {
	_c.Call.Return(run)
	return _c
}

// SendHELO provides a mock function with given fields: client, userAgent, readTimeout, writeTimeout, logger
func (_m *UtilsIface) SendHELO(client memcached.ClientIface, userAgent string, readTimeout time.Duration, writeTimeout time.Duration, logger *log.CommonLogger) error {
	ret := _m.Called(client, userAgent, readTimeout, writeTimeout, logger)

	var r0 error
	if rf, ok := ret.Get(0).(func(memcached.ClientIface, string, time.Duration, time.Duration, *log.CommonLogger) error); ok {
		r0 = rf(client, userAgent, readTimeout, writeTimeout, logger)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UtilsIface_SendHELO_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SendHELO'
type UtilsIface_SendHELO_Call struct {
	*mock.Call
}

// SendHELO is a helper method to define mock.On call
//   - client memcached.ClientIface
//   - userAgent string
//   - readTimeout time.Duration
//   - writeTimeout time.Duration
//   - logger *log.CommonLogger
func (_e *UtilsIface_Expecter) SendHELO(client interface{}, userAgent interface{}, readTimeout interface{}, writeTimeout interface{}, logger interface{}) *UtilsIface_SendHELO_Call {
	return &UtilsIface_SendHELO_Call{Call: _e.mock.On("SendHELO", client, userAgent, readTimeout, writeTimeout, logger)}
}

func (_c *UtilsIface_SendHELO_Call) Run(run func(client memcached.ClientIface, userAgent string, readTimeout time.Duration, writeTimeout time.Duration, logger *log.CommonLogger)) *UtilsIface_SendHELO_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(memcached.ClientIface), args[1].(string), args[2].(time.Duration), args[3].(time.Duration), args[4].(*log.CommonLogger))
	})
	return _c
}

func (_c *UtilsIface_SendHELO_Call) Return(_a0 error) *UtilsIface_SendHELO_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *UtilsIface_SendHELO_Call) RunAndReturn(run func(memcached.ClientIface, string, time.Duration, time.Duration, *log.CommonLogger) error) *UtilsIface_SendHELO_Call {
	_c.Call.Return(run)
	return _c
}

// SendHELOWithFeatures provides a mock function with given fields: client, userAgent, readTimeout, writeTimeout, requestedFeatures, logger
func (_m *UtilsIface) SendHELOWithFeatures(client memcached.ClientIface, userAgent string, readTimeout time.Duration, writeTimeout time.Duration, requestedFeatures utils.HELOFeatures, logger *log.CommonLogger) (utils.HELOFeatures, error) {
	ret := _m.Called(client, userAgent, readTimeout, writeTimeout, requestedFeatures, logger)

	var r0 utils.HELOFeatures
	var r1 error
	if rf, ok := ret.Get(0).(func(memcached.ClientIface, string, time.Duration, time.Duration, utils.HELOFeatures, *log.CommonLogger) (utils.HELOFeatures, error)); ok {
		return rf(client, userAgent, readTimeout, writeTimeout, requestedFeatures, logger)
	}
	if rf, ok := ret.Get(0).(func(memcached.ClientIface, string, time.Duration, time.Duration, utils.HELOFeatures, *log.CommonLogger) utils.HELOFeatures); ok {
		r0 = rf(client, userAgent, readTimeout, writeTimeout, requestedFeatures, logger)
	} else {
		r0 = ret.Get(0).(utils.HELOFeatures)
	}

	if rf, ok := ret.Get(1).(func(memcached.ClientIface, string, time.Duration, time.Duration, utils.HELOFeatures, *log.CommonLogger) error); ok {
		r1 = rf(client, userAgent, readTimeout, writeTimeout, requestedFeatures, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UtilsIface_SendHELOWithFeatures_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SendHELOWithFeatures'
type UtilsIface_SendHELOWithFeatures_Call struct {
	*mock.Call
}

// SendHELOWithFeatures is a helper method to define mock.On call
//   - client memcached.ClientIface
//   - userAgent string
//   - readTimeout time.Duration
//   - writeTimeout time.Duration
//   - requestedFeatures utils.HELOFeatures
//   - logger *log.CommonLogger
func (_e *UtilsIface_Expecter) SendHELOWithFeatures(client interface{}, userAgent interface{}, readTimeout interface{}, writeTimeout interface{}, requestedFeatures interface{}, logger interface{}) *UtilsIface_SendHELOWithFeatures_Call {
	return &UtilsIface_SendHELOWithFeatures_Call{Call: _e.mock.On("SendHELOWithFeatures", client, userAgent, readTimeout, writeTimeout, requestedFeatures, logger)}
}

func (_c *UtilsIface_SendHELOWithFeatures_Call) Run(run func(client memcached.ClientIface, userAgent string, readTimeout time.Duration, writeTimeout time.Duration, requestedFeatures utils.HELOFeatures, logger *log.CommonLogger)) *UtilsIface_SendHELOWithFeatures_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(memcached.ClientIface), args[1].(string), args[2].(time.Duration), args[3].(time.Duration), args[4].(utils.HELOFeatures), args[5].(*log.CommonLogger))
	})
	return _c
}

func (_c *UtilsIface_SendHELOWithFeatures_Call) Return(respondedFeatures utils.HELOFeatures, err error) *UtilsIface_SendHELOWithFeatures_Call {
	_c.Call.Return(respondedFeatures, err)
	return _c
}

func (_c *UtilsIface_SendHELOWithFeatures_Call) RunAndReturn(run func(memcached.ClientIface, string, time.Duration, time.Duration, utils.HELOFeatures, *log.CommonLogger) (utils.HELOFeatures, error)) *UtilsIface_SendHELOWithFeatures_Call {
	_c.Call.Return(run)
	return _c
}

// StartDebugExec provides a mock function with given fields: id, threshold, debugFunc
func (_m *UtilsIface) StartDebugExec(id string, threshold time.Duration, debugFunc func()) func() {
	ret := _m.Called(id, threshold, debugFunc)

	var r0 func()
	if rf, ok := ret.Get(0).(func(string, time.Duration, func()) func()); ok {
		r0 = rf(id, threshold, debugFunc)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(func())
		}
	}

	return r0
}

// UtilsIface_StartDebugExec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StartDebugExec'
type UtilsIface_StartDebugExec_Call struct {
	*mock.Call
}

// StartDebugExec is a helper method to define mock.On call
//   - id string
//   - threshold time.Duration
//   - debugFunc func()
func (_e *UtilsIface_Expecter) StartDebugExec(id interface{}, threshold interface{}, debugFunc interface{}) *UtilsIface_StartDebugExec_Call {
	return &UtilsIface_StartDebugExec_Call{Call: _e.mock.On("StartDebugExec", id, threshold, debugFunc)}
}

func (_c *UtilsIface_StartDebugExec_Call) Run(run func(id string, threshold time.Duration, debugFunc func())) *UtilsIface_StartDebugExec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(time.Duration), args[2].(func()))
	})
	return _c
}

func (_c *UtilsIface_StartDebugExec_Call) Return(_a0 func()) *UtilsIface_StartDebugExec_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *UtilsIface_StartDebugExec_Call) RunAndReturn(run func(string, time.Duration, func()) func()) *UtilsIface_StartDebugExec_Call {
	_c.Call.Return(run)
	return _c
}

// StartDiagStopwatch provides a mock function with given fields: id, threshold
func (_m *UtilsIface) StartDiagStopwatch(id string, threshold time.Duration) func() {
	ret := _m.Called(id, threshold)

	var r0 func()
	if rf, ok := ret.Get(0).(func(string, time.Duration) func()); ok {
		r0 = rf(id, threshold)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(func())
		}
	}

	return r0
}

// UtilsIface_StartDiagStopwatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StartDiagStopwatch'
type UtilsIface_StartDiagStopwatch_Call struct {
	*mock.Call
}

// StartDiagStopwatch is a helper method to define mock.On call
//   - id string
//   - threshold time.Duration
func (_e *UtilsIface_Expecter) StartDiagStopwatch(id interface{}, threshold interface{}) *UtilsIface_StartDiagStopwatch_Call {
	return &UtilsIface_StartDiagStopwatch_Call{Call: _e.mock.On("StartDiagStopwatch", id, threshold)}
}

func (_c *UtilsIface_StartDiagStopwatch_Call) Run(run func(id string, threshold time.Duration)) *UtilsIface_StartDiagStopwatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(time.Duration))
	})
	return _c
}

func (_c *UtilsIface_StartDiagStopwatch_Call) Return(_a0 func()) *UtilsIface_StartDiagStopwatch_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *UtilsIface_StartDiagStopwatch_Call) RunAndReturn(run func(string, time.Duration) func()) *UtilsIface_StartDiagStopwatch_Call {
	_c.Call.Return(run)
	return _c
}

// TranslateKvVbMap provides a mock function with given fields: kvVBMap, targetBucketInfo
func (_m *UtilsIface) TranslateKvVbMap(kvVBMap base.KvVBMapType, targetBucketInfo map[string]interface{}) {
	_m.Called(kvVBMap, targetBucketInfo)
}

// UtilsIface_TranslateKvVbMap_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TranslateKvVbMap'
type UtilsIface_TranslateKvVbMap_Call struct {
	*mock.Call
}

// TranslateKvVbMap is a helper method to define mock.On call
//   - kvVBMap base.KvVBMapType
//   - targetBucketInfo map[string]interface{}
func (_e *UtilsIface_Expecter) TranslateKvVbMap(kvVBMap interface{}, targetBucketInfo interface{}) *UtilsIface_TranslateKvVbMap_Call {
	return &UtilsIface_TranslateKvVbMap_Call{Call: _e.mock.On("TranslateKvVbMap", kvVBMap, targetBucketInfo)}
}

func (_c *UtilsIface_TranslateKvVbMap_Call) Run(run func(kvVBMap base.KvVBMapType, targetBucketInfo map[string]interface{})) *UtilsIface_TranslateKvVbMap_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(base.KvVBMapType), args[1].(map[string]interface{}))
	})
	return _c
}

func (_c *UtilsIface_TranslateKvVbMap_Call) Return() *UtilsIface_TranslateKvVbMap_Call {
	_c.Call.Return()
	return _c
}

func (_c *UtilsIface_TranslateKvVbMap_Call) RunAndReturn(run func(base.KvVBMapType, map[string]interface{})) *UtilsIface_TranslateKvVbMap_Call {
	_c.Call.Return(run)
	return _c
}

// UnwrapError provides a mock function with given fields: infos
func (_m *UtilsIface) UnwrapError(infos map[string]interface{}) error {
	ret := _m.Called(infos)

	var r0 error
	if rf, ok := ret.Get(0).(func(map[string]interface{}) error); ok {
		r0 = rf(infos)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UtilsIface_UnwrapError_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnwrapError'
type UtilsIface_UnwrapError_Call struct {
	*mock.Call
}

// UnwrapError is a helper method to define mock.On call
//   - infos map[string]interface{}
func (_e *UtilsIface_Expecter) UnwrapError(infos interface{}) *UtilsIface_UnwrapError_Call {
	return &UtilsIface_UnwrapError_Call{Call: _e.mock.On("UnwrapError", infos)}
}

func (_c *UtilsIface_UnwrapError_Call) Run(run func(infos map[string]interface{})) *UtilsIface_UnwrapError_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(map[string]interface{}))
	})
	return _c
}

func (_c *UtilsIface_UnwrapError_Call) Return(err error) *UtilsIface_UnwrapError_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *UtilsIface_UnwrapError_Call) RunAndReturn(run func(map[string]interface{}) error) *UtilsIface_UnwrapError_Call {
	_c.Call.Return(run)
	return _c
}

// UrlForLog provides a mock function with given fields: urlStr
func (_m *UtilsIface) UrlForLog(urlStr string) string {
	ret := _m.Called(urlStr)

	var r0 string
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(urlStr)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// UtilsIface_UrlForLog_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UrlForLog'
type UtilsIface_UrlForLog_Call struct {
	*mock.Call
}

// UrlForLog is a helper method to define mock.On call
//   - urlStr string
func (_e *UtilsIface_Expecter) UrlForLog(urlStr interface{}) *UtilsIface_UrlForLog_Call {
	return &UtilsIface_UrlForLog_Call{Call: _e.mock.On("UrlForLog", urlStr)}
}

func (_c *UtilsIface_UrlForLog_Call) Run(run func(urlStr string)) *UtilsIface_UrlForLog_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *UtilsIface_UrlForLog_Call) Return(_a0 string) *UtilsIface_UrlForLog_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *UtilsIface_UrlForLog_Call) RunAndReturn(run func(string) string) *UtilsIface_UrlForLog_Call {
	_c.Call.Return(run)
	return _c
}

// ValidateSettings provides a mock function with given fields: defs, settings, logger
func (_m *UtilsIface) ValidateSettings(defs base.SettingDefinitions, settings metadata.ReplicationSettingsMap, logger *log.CommonLogger) error {
	ret := _m.Called(defs, settings, logger)

	var r0 error
	if rf, ok := ret.Get(0).(func(base.SettingDefinitions, metadata.ReplicationSettingsMap, *log.CommonLogger) error); ok {
		r0 = rf(defs, settings, logger)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UtilsIface_ValidateSettings_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ValidateSettings'
type UtilsIface_ValidateSettings_Call struct {
	*mock.Call
}

// ValidateSettings is a helper method to define mock.On call
//   - defs base.SettingDefinitions
//   - settings metadata.ReplicationSettingsMap
//   - logger *log.CommonLogger
func (_e *UtilsIface_Expecter) ValidateSettings(defs interface{}, settings interface{}, logger interface{}) *UtilsIface_ValidateSettings_Call {
	return &UtilsIface_ValidateSettings_Call{Call: _e.mock.On("ValidateSettings", defs, settings, logger)}
}

func (_c *UtilsIface_ValidateSettings_Call) Run(run func(defs base.SettingDefinitions, settings metadata.ReplicationSettingsMap, logger *log.CommonLogger)) *UtilsIface_ValidateSettings_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(base.SettingDefinitions), args[1].(metadata.ReplicationSettingsMap), args[2].(*log.CommonLogger))
	})
	return _c
}

func (_c *UtilsIface_ValidateSettings_Call) Return(_a0 error) *UtilsIface_ValidateSettings_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *UtilsIface_ValidateSettings_Call) RunAndReturn(run func(base.SettingDefinitions, metadata.ReplicationSettingsMap, *log.CommonLogger) error) *UtilsIface_ValidateSettings_Call {
	_c.Call.Return(run)
	return _c
}

// VerifyTargetBucket provides a mock function with given fields: targetBucketName, targetBucketUuid, remoteClusterRef, logger
func (_m *UtilsIface) VerifyTargetBucket(targetBucketName string, targetBucketUuid string, remoteClusterRef *metadata.RemoteClusterReference, logger *log.CommonLogger) error {
	ret := _m.Called(targetBucketName, targetBucketUuid, remoteClusterRef, logger)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, *metadata.RemoteClusterReference, *log.CommonLogger) error); ok {
		r0 = rf(targetBucketName, targetBucketUuid, remoteClusterRef, logger)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UtilsIface_VerifyTargetBucket_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'VerifyTargetBucket'
type UtilsIface_VerifyTargetBucket_Call struct {
	*mock.Call
}

// VerifyTargetBucket is a helper method to define mock.On call
//   - targetBucketName string
//   - targetBucketUuid string
//   - remoteClusterRef *metadata.RemoteClusterReference
//   - logger *log.CommonLogger
func (_e *UtilsIface_Expecter) VerifyTargetBucket(targetBucketName interface{}, targetBucketUuid interface{}, remoteClusterRef interface{}, logger interface{}) *UtilsIface_VerifyTargetBucket_Call {
	return &UtilsIface_VerifyTargetBucket_Call{Call: _e.mock.On("VerifyTargetBucket", targetBucketName, targetBucketUuid, remoteClusterRef, logger)}
}

func (_c *UtilsIface_VerifyTargetBucket_Call) Run(run func(targetBucketName string, targetBucketUuid string, remoteClusterRef *metadata.RemoteClusterReference, logger *log.CommonLogger)) *UtilsIface_VerifyTargetBucket_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].(*metadata.RemoteClusterReference), args[3].(*log.CommonLogger))
	})
	return _c
}

func (_c *UtilsIface_VerifyTargetBucket_Call) Return(_a0 error) *UtilsIface_VerifyTargetBucket_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *UtilsIface_VerifyTargetBucket_Call) RunAndReturn(run func(string, string, *metadata.RemoteClusterReference, *log.CommonLogger) error) *UtilsIface_VerifyTargetBucket_Call {
	_c.Call.Return(run)
	return _c
}

// NewUtilsIface creates a new instance of UtilsIface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewUtilsIface(t interface {
	mock.TestingT
	Cleanup(func())
}) *UtilsIface {
	mock := &UtilsIface{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
