package mocks

import (
	couchbase "github.com/couchbase/go-couchbase"
	base "github.com/couchbase/goxdcr/base"

	expvar "expvar"

	gomemcached "github.com/couchbase/gomemcached"

	http "net/http"

	log "github.com/couchbase/goxdcr/log"

	memcached "github.com/couchbase/gomemcached/client"

	metadata "github.com/couchbase/goxdcr/metadata"

	mock "github.com/stretchr/testify/mock"

	net "net"

	time "time"

	utils "github.com/couchbase/goxdcr/utils"
)

// UtilsIface is an autogenerated mock type for the UtilsIface type
type UtilsIface struct {
	mock.Mock
}

// AddKeyToBeFiltered provides a mock function with given fields: currentValue, key, dpGetter, toBeReleased, currentValueEndBody
func (_m *UtilsIface) AddKeyToBeFiltered(currentValue []byte, key []byte, dpGetter base.DpGetterFunc, toBeReleased *[][]byte, currentValueEndBody int) ([]byte, error, int64, int) {
	ret := _m.Called(currentValue, key, dpGetter, toBeReleased, currentValueEndBody)

	var r0 []byte
	if rf, ok := ret.Get(0).(func([]byte, []byte, base.DpGetterFunc, *[][]byte, int) []byte); ok {
		r0 = rf(currentValue, key, dpGetter, toBeReleased, currentValueEndBody)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([]byte, []byte, base.DpGetterFunc, *[][]byte, int) error); ok {
		r1 = rf(currentValue, key, dpGetter, toBeReleased, currentValueEndBody)
	} else {
		r1 = ret.Error(1)
	}

	var r2 int64
	if rf, ok := ret.Get(2).(func([]byte, []byte, base.DpGetterFunc, *[][]byte, int) int64); ok {
		r2 = rf(currentValue, key, dpGetter, toBeReleased, currentValueEndBody)
	} else {
		r2 = ret.Get(2).(int64)
	}

	var r3 int
	if rf, ok := ret.Get(3).(func([]byte, []byte, base.DpGetterFunc, *[][]byte, int) int); ok {
		r3 = rf(currentValue, key, dpGetter, toBeReleased, currentValueEndBody)
	} else {
		r3 = ret.Get(3).(int)
	}

	return r0, r1, r2, r3
}

// BucketInfoParseError provides a mock function with given fields: bucketInfo, logger
func (_m *UtilsIface) BucketInfoParseError(bucketInfo map[string]interface{}, logger *log.CommonLogger) error {
	ret := _m.Called(bucketInfo, logger)

	var r0 error
	if rf, ok := ret.Get(0).(func(map[string]interface{}, *log.CommonLogger) error); ok {
		r0 = rf(bucketInfo, logger)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// BucketNotFoundError provides a mock function with given fields: bucketName
func (_m *UtilsIface) BucketNotFoundError(bucketName string) error {
	ret := _m.Called(bucketName)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(bucketName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// BucketPassword provides a mock function with given fields: hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger
func (_m *UtilsIface) BucketPassword(hostAddr string, bucketName string, username string, password string, authMech base.HttpAuthMech, certificate []byte, sanInCertificate bool, clientCertificate []byte, clientKey []byte, logger *log.CommonLogger) (string, error) {
	ret := _m.Called(hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) string); ok {
		r0 = rf(hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) error); ok {
		r1 = rf(hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BucketUUID provides a mock function with given fields: hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger
func (_m *UtilsIface) BucketUUID(hostAddr string, bucketName string, username string, password string, authMech base.HttpAuthMech, certificate []byte, sanInCertificate bool, clientCertificate []byte, clientKey []byte, logger *log.CommonLogger) (string, error) {
	ret := _m.Called(hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) string); ok {
		r0 = rf(hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) error); ok {
		r1 = rf(hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BucketValidationInfo provides a mock function with given fields: hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger
func (_m *UtilsIface) BucketValidationInfo(hostAddr string, bucketName string, username string, password string, authMech base.HttpAuthMech, certificate []byte, sanInCertificate bool, clientCertificate []byte, clientKey []byte, logger *log.CommonLogger) (map[string]interface{}, string, string, string, string, map[string][]uint16, error) {
	ret := _m.Called(hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)

	var r0 map[string]interface{}
	if rf, ok := ret.Get(0).(func(string, string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) map[string]interface{}); ok {
		r0 = rf(hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]interface{})
		}
	}

	var r1 string
	if rf, ok := ret.Get(1).(func(string, string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) string); ok {
		r1 = rf(hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	} else {
		r1 = ret.Get(1).(string)
	}

	var r2 string
	if rf, ok := ret.Get(2).(func(string, string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) string); ok {
		r2 = rf(hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	} else {
		r2 = ret.Get(2).(string)
	}

	var r3 string
	if rf, ok := ret.Get(3).(func(string, string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) string); ok {
		r3 = rf(hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	} else {
		r3 = ret.Get(3).(string)
	}

	var r4 string
	if rf, ok := ret.Get(4).(func(string, string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) string); ok {
		r4 = rf(hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	} else {
		r4 = ret.Get(4).(string)
	}

	var r5 map[string][]uint16
	if rf, ok := ret.Get(5).(func(string, string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) map[string][]uint16); ok {
		r5 = rf(hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	} else {
		if ret.Get(5) != nil {
			r5 = ret.Get(5).(map[string][]uint16)
		}
	}

	var r6 error
	if rf, ok := ret.Get(6).(func(string, string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) error); ok {
		r6 = rf(hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	} else {
		r6 = ret.Error(6)
	}

	return r0, r1, r2, r3, r4, r5, r6
}

// CheckForTransactionXattrsInUprEvent provides a mock function with given fields: uprEvent, dp, slicesToBeReleased, needToFilterBody
func (_m *UtilsIface) CheckForTransactionXattrsInUprEvent(uprEvent *memcached.UprEvent, dp utils.DataPoolIface, slicesToBeReleased *[][]byte, needToFilterBody bool) (bool, []byte, int, error, string, int64) {
	ret := _m.Called(uprEvent, dp, slicesToBeReleased, needToFilterBody)

	var r0 bool
	if rf, ok := ret.Get(0).(func(*memcached.UprEvent, utils.DataPoolIface, *[][]byte, bool) bool); ok {
		r0 = rf(uprEvent, dp, slicesToBeReleased, needToFilterBody)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 []byte
	if rf, ok := ret.Get(1).(func(*memcached.UprEvent, utils.DataPoolIface, *[][]byte, bool) []byte); ok {
		r1 = rf(uprEvent, dp, slicesToBeReleased, needToFilterBody)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]byte)
		}
	}

	var r2 int
	if rf, ok := ret.Get(2).(func(*memcached.UprEvent, utils.DataPoolIface, *[][]byte, bool) int); ok {
		r2 = rf(uprEvent, dp, slicesToBeReleased, needToFilterBody)
	} else {
		r2 = ret.Get(2).(int)
	}

	var r3 error
	if rf, ok := ret.Get(3).(func(*memcached.UprEvent, utils.DataPoolIface, *[][]byte, bool) error); ok {
		r3 = rf(uprEvent, dp, slicesToBeReleased, needToFilterBody)
	} else {
		r3 = ret.Error(3)
	}

	var r4 string
	if rf, ok := ret.Get(4).(func(*memcached.UprEvent, utils.DataPoolIface, *[][]byte, bool) string); ok {
		r4 = rf(uprEvent, dp, slicesToBeReleased, needToFilterBody)
	} else {
		r4 = ret.Get(4).(string)
	}

	var r5 int64
	if rf, ok := ret.Get(5).(func(*memcached.UprEvent, utils.DataPoolIface, *[][]byte, bool) int64); ok {
		r5 = rf(uprEvent, dp, slicesToBeReleased, needToFilterBody)
	} else {
		r5 = ret.Get(5).(int64)
	}

	return r0, r1, r2, r3, r4, r5
}

// CheckWhetherClusterIsESBasedOnBucketInfo provides a mock function with given fields: bucketInfo
func (_m *UtilsIface) CheckWhetherClusterIsESBasedOnBucketInfo(bucketInfo map[string]interface{}) bool {
	ret := _m.Called(bucketInfo)

	var r0 bool
	if rf, ok := ret.Get(0).(func(map[string]interface{}) bool); ok {
		r0 = rf(bucketInfo)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// ComposeHELORequest provides a mock function with given fields: userAgent, features
func (_m *UtilsIface) ComposeHELORequest(userAgent string, features utils.HELOFeatures) *gomemcached.MCRequest {
	ret := _m.Called(userAgent, features)

	var r0 *gomemcached.MCRequest
	if rf, ok := ret.Get(0).(func(string, utils.HELOFeatures) *gomemcached.MCRequest); ok {
		r0 = rf(userAgent, features)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gomemcached.MCRequest)
		}
	}

	return r0
}

// ConstructHttpRequest provides a mock function with given fields: baseURL, path, preservePathEncoding, username, password, authMech, userAuthMode, httpCommand, contentType, body, logger
func (_m *UtilsIface) ConstructHttpRequest(baseURL string, path string, preservePathEncoding bool, username string, password string, authMech base.HttpAuthMech, userAuthMode base.UserAuthMode, httpCommand string, contentType string, body []byte, logger *log.CommonLogger) (*http.Request, string, error) {
	ret := _m.Called(baseURL, path, preservePathEncoding, username, password, authMech, userAuthMode, httpCommand, contentType, body, logger)

	var r0 *http.Request
	if rf, ok := ret.Get(0).(func(string, string, bool, string, string, base.HttpAuthMech, base.UserAuthMode, string, string, []byte, *log.CommonLogger) *http.Request); ok {
		r0 = rf(baseURL, path, preservePathEncoding, username, password, authMech, userAuthMode, httpCommand, contentType, body, logger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Request)
		}
	}

	var r1 string
	if rf, ok := ret.Get(1).(func(string, string, bool, string, string, base.HttpAuthMech, base.UserAuthMode, string, string, []byte, *log.CommonLogger) string); ok {
		r1 = rf(baseURL, path, preservePathEncoding, username, password, authMech, userAuthMode, httpCommand, contentType, body, logger)
	} else {
		r1 = ret.Get(1).(string)
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(string, string, bool, string, string, base.HttpAuthMech, base.UserAuthMode, string, string, []byte, *log.CommonLogger) error); ok {
		r2 = rf(baseURL, path, preservePathEncoding, username, password, authMech, userAuthMode, httpCommand, contentType, body, logger)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// EncodeHttpRequest provides a mock function with given fields: req
func (_m *UtilsIface) EncodeHttpRequest(req *http.Request) ([]byte, error) {
	ret := _m.Called(req)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(*http.Request) []byte); ok {
		r0 = rf(req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*http.Request) error); ok {
		r1 = rf(req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EncodeHttpRequestHeader provides a mock function with given fields: reqBytes, key, value
func (_m *UtilsIface) EncodeHttpRequestHeader(reqBytes []byte, key string, value string) []byte {
	ret := _m.Called(reqBytes, key, value)

	var r0 []byte
	if rf, ok := ret.Get(0).(func([]byte, string, string) []byte); ok {
		r0 = rf(reqBytes, key, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	return r0
}

// EncodeMapIntoByteArray provides a mock function with given fields: data
func (_m *UtilsIface) EncodeMapIntoByteArray(data map[string]interface{}) ([]byte, error) {
	ret := _m.Called(data)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(map[string]interface{}) []byte); ok {
		r0 = rf(data)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(map[string]interface{}) error); ok {
		r1 = rf(data)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnforcePrefix provides a mock function with given fields: prefix, str
func (_m *UtilsIface) EnforcePrefix(prefix string, str string) string {
	ret := _m.Called(prefix, str)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, string) string); ok {
		r0 = rf(prefix, str)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// ExponentialBackoffExecutor provides a mock function with given fields: name, initialWait, maxRetries, factor, op
func (_m *UtilsIface) ExponentialBackoffExecutor(name string, initialWait time.Duration, maxRetries int, factor int, op utils.ExponentialOpFunc) error {
	ret := _m.Called(name, initialWait, maxRetries, factor, op)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, time.Duration, int, int, utils.ExponentialOpFunc) error); ok {
		r0 = rf(name, initialWait, maxRetries, factor, op)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ExponentialBackoffExecutorWithFinishSignal provides a mock function with given fields: name, initialWait, maxRetries, factor, op, param, finCh
func (_m *UtilsIface) ExponentialBackoffExecutorWithFinishSignal(name string, initialWait time.Duration, maxRetries int, factor int, op utils.ExponentialOpFunc2, param interface{}, finCh chan bool) (interface{}, error) {
	ret := _m.Called(name, initialWait, maxRetries, factor, op, param, finCh)

	var r0 interface{}
	if rf, ok := ret.Get(0).(func(string, time.Duration, int, int, utils.ExponentialOpFunc2, interface{}, chan bool) interface{}); ok {
		r0 = rf(name, initialWait, maxRetries, factor, op, param, finCh)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, time.Duration, int, int, utils.ExponentialOpFunc2, interface{}, chan bool) error); ok {
		r1 = rf(name, initialWait, maxRetries, factor, op, param, finCh)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterExpressionMatchesDoc provides a mock function with given fields: expression, docId, bucketName, addr, port
func (_m *UtilsIface) FilterExpressionMatchesDoc(expression string, docId string, bucketName string, addr string, port uint16) (bool, error) {
	ret := _m.Called(expression, docId, bucketName, addr, port)

	var r0 bool
	if rf, ok := ret.Get(0).(func(string, string, string, string, uint16) bool); ok {
		r0 = rf(expression, docId, bucketName, addr, port)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string, string, uint16) error); ok {
		r1 = rf(expression, docId, bucketName, addr, port)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBucketInfo provides a mock function with given fields: hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger
func (_m *UtilsIface) GetBucketInfo(hostAddr string, bucketName string, username string, password string, authMech base.HttpAuthMech, certificate []byte, sanInCertificate bool, clientCertificate []byte, clientKey []byte, logger *log.CommonLogger) (map[string]interface{}, error) {
	ret := _m.Called(hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)

	var r0 map[string]interface{}
	if rf, ok := ret.Get(0).(func(string, string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) map[string]interface{}); ok {
		r0 = rf(hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]interface{})
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) error); ok {
		r1 = rf(hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBucketPasswordFromBucketInfo provides a mock function with given fields: bucketName, bucketInfo, logger
func (_m *UtilsIface) GetBucketPasswordFromBucketInfo(bucketName string, bucketInfo map[string]interface{}, logger *log.CommonLogger) (string, error) {
	ret := _m.Called(bucketName, bucketInfo, logger)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, map[string]interface{}, *log.CommonLogger) string); ok {
		r0 = rf(bucketName, bucketInfo, logger)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, map[string]interface{}, *log.CommonLogger) error); ok {
		r1 = rf(bucketName, bucketInfo, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBucketRecreatedError provides a mock function with given fields:
func (_m *UtilsIface) GetBucketRecreatedError() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetBucketTypeFromBucketInfo provides a mock function with given fields: bucketName, bucketInfo
func (_m *UtilsIface) GetBucketTypeFromBucketInfo(bucketName string, bucketInfo map[string]interface{}) (string, error) {
	ret := _m.Called(bucketName, bucketInfo)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, map[string]interface{}) string); ok {
		r0 = rf(bucketName, bucketInfo)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, map[string]interface{}) error); ok {
		r1 = rf(bucketName, bucketInfo)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBucketUuidFromBucketInfo provides a mock function with given fields: bucketName, bucketInfo, logger
func (_m *UtilsIface) GetBucketUuidFromBucketInfo(bucketName string, bucketInfo map[string]interface{}, logger *log.CommonLogger) (string, error) {
	ret := _m.Called(bucketName, bucketInfo, logger)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, map[string]interface{}, *log.CommonLogger) string); ok {
		r0 = rf(bucketName, bucketInfo, logger)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, map[string]interface{}, *log.CommonLogger) error); ok {
		r1 = rf(bucketName, bucketInfo, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBuckets provides a mock function with given fields: hostAddr, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger
func (_m *UtilsIface) GetBuckets(hostAddr string, username string, password string, authMech base.HttpAuthMech, certificate []byte, sanInCertificate bool, clientCertificate []byte, clientKey []byte, logger *log.CommonLogger) (map[string]string, error) {
	ret := _m.Called(hostAddr, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)

	var r0 map[string]string
	if rf, ok := ret.Get(0).(func(string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) map[string]string); ok {
		r0 = rf(hostAddr, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]string)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) error); ok {
		r1 = rf(hostAddr, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetClusterCompatibilityFromBucketInfo provides a mock function with given fields: bucketInfo, logger
func (_m *UtilsIface) GetClusterCompatibilityFromBucketInfo(bucketInfo map[string]interface{}, logger *log.CommonLogger) (int, error) {
	ret := _m.Called(bucketInfo, logger)

	var r0 int
	if rf, ok := ret.Get(0).(func(map[string]interface{}, *log.CommonLogger) int); ok {
		r0 = rf(bucketInfo, logger)
	} else {
		r0 = ret.Get(0).(int)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(map[string]interface{}, *log.CommonLogger) error); ok {
		r1 = rf(bucketInfo, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetClusterCompatibilityFromNodeList provides a mock function with given fields: nodeList
func (_m *UtilsIface) GetClusterCompatibilityFromNodeList(nodeList []interface{}) (int, error) {
	ret := _m.Called(nodeList)

	var r0 int
	if rf, ok := ret.Get(0).(func([]interface{}) int); ok {
		r0 = rf(nodeList)
	} else {
		r0 = ret.Get(0).(int)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([]interface{}) error); ok {
		r1 = rf(nodeList)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetClusterInfo provides a mock function with given fields: hostAddr, path, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger
func (_m *UtilsIface) GetClusterInfo(hostAddr string, path string, username string, password string, authMech base.HttpAuthMech, certificate []byte, sanInCertificate bool, clientCertificate []byte, clientKey []byte, logger *log.CommonLogger) (map[string]interface{}, error) {
	ret := _m.Called(hostAddr, path, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)

	var r0 map[string]interface{}
	if rf, ok := ret.Get(0).(func(string, string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) map[string]interface{}); ok {
		r0 = rf(hostAddr, path, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]interface{})
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) error); ok {
		r1 = rf(hostAddr, path, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetClusterInfoWStatusCode provides a mock function with given fields: hostAddr, path, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger
func (_m *UtilsIface) GetClusterInfoWStatusCode(hostAddr string, path string, username string, password string, authMech base.HttpAuthMech, certificate []byte, sanInCertificate bool, clientCertificate []byte, clientKey []byte, logger *log.CommonLogger) (map[string]interface{}, error, int) {
	ret := _m.Called(hostAddr, path, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)

	var r0 map[string]interface{}
	if rf, ok := ret.Get(0).(func(string, string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) map[string]interface{}); ok {
		r0 = rf(hostAddr, path, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]interface{})
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) error); ok {
		r1 = rf(hostAddr, path, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	} else {
		r1 = ret.Error(1)
	}

	var r2 int
	if rf, ok := ret.Get(2).(func(string, string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) int); ok {
		r2 = rf(hostAddr, path, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	} else {
		r2 = ret.Get(2).(int)
	}

	return r0, r1, r2
}

// GetClusterUUID provides a mock function with given fields: hostAddr, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger
func (_m *UtilsIface) GetClusterUUID(hostAddr string, username string, password string, authMech base.HttpAuthMech, certificate []byte, sanInCertificate bool, clientCertificate []byte, clientKey []byte, logger *log.CommonLogger) (string, error) {
	ret := _m.Called(hostAddr, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) string); ok {
		r0 = rf(hostAddr, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) error); ok {
		r1 = rf(hostAddr, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetClusterUUIDAndNodeListWithMinInfo provides a mock function with given fields: hostAddr, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger
func (_m *UtilsIface) GetClusterUUIDAndNodeListWithMinInfo(hostAddr string, username string, password string, authMech base.HttpAuthMech, certificate []byte, sanInCertificate bool, clientCertificate []byte, clientKey []byte, logger *log.CommonLogger) (string, []interface{}, error) {
	ret := _m.Called(hostAddr, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) string); ok {
		r0 = rf(hostAddr, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 []interface{}
	if rf, ok := ret.Get(1).(func(string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) []interface{}); ok {
		r1 = rf(hostAddr, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]interface{})
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) error); ok {
		r2 = rf(hostAddr, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetClusterUUIDAndNodeListWithMinInfoFromDefaultPoolInfo provides a mock function with given fields: defaultPoolInfo, logger
func (_m *UtilsIface) GetClusterUUIDAndNodeListWithMinInfoFromDefaultPoolInfo(defaultPoolInfo map[string]interface{}, logger *log.CommonLogger) (string, []interface{}, error) {
	ret := _m.Called(defaultPoolInfo, logger)

	var r0 string
	if rf, ok := ret.Get(0).(func(map[string]interface{}, *log.CommonLogger) string); ok {
		r0 = rf(defaultPoolInfo, logger)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 []interface{}
	if rf, ok := ret.Get(1).(func(map[string]interface{}, *log.CommonLogger) []interface{}); ok {
		r1 = rf(defaultPoolInfo, logger)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]interface{})
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(map[string]interface{}, *log.CommonLogger) error); ok {
		r2 = rf(defaultPoolInfo, logger)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetClusterUUIDFromDefaultPoolInfo provides a mock function with given fields: defaultPoolInfo, logger
func (_m *UtilsIface) GetClusterUUIDFromDefaultPoolInfo(defaultPoolInfo map[string]interface{}, logger *log.CommonLogger) (string, error) {
	ret := _m.Called(defaultPoolInfo, logger)

	var r0 string
	if rf, ok := ret.Get(0).(func(map[string]interface{}, *log.CommonLogger) string); ok {
		r0 = rf(defaultPoolInfo, logger)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(map[string]interface{}, *log.CommonLogger) error); ok {
		r1 = rf(defaultPoolInfo, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetClusterUUIDFromURI provides a mock function with given fields: uri
func (_m *UtilsIface) GetClusterUUIDFromURI(uri string) (string, error) {
	ret := _m.Called(uri)

	var r0 string
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(uri)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(uri)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetConflictResolutionTypeFromBucketInfo provides a mock function with given fields: bucketName, bucketInfo
func (_m *UtilsIface) GetConflictResolutionTypeFromBucketInfo(bucketName string, bucketInfo map[string]interface{}) (string, error) {
	ret := _m.Called(bucketName, bucketInfo)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, map[string]interface{}) string); ok {
		r0 = rf(bucketName, bucketInfo)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, map[string]interface{}) error); ok {
		r1 = rf(bucketName, bucketInfo)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDefaultPoolInfoUsingHttps provides a mock function with given fields: hostHttpsAddr, username, password, certificate, clientCertificate, clientKey, logger
func (_m *UtilsIface) GetDefaultPoolInfoUsingHttps(hostHttpsAddr string, username string, password string, certificate []byte, clientCertificate []byte, clientKey []byte, logger *log.CommonLogger) (map[string]interface{}, error) {
	ret := _m.Called(hostHttpsAddr, username, password, certificate, clientCertificate, clientKey, logger)

	var r0 map[string]interface{}
	if rf, ok := ret.Get(0).(func(string, string, string, []byte, []byte, []byte, *log.CommonLogger) map[string]interface{}); ok {
		r0 = rf(hostHttpsAddr, username, password, certificate, clientCertificate, clientKey, logger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]interface{})
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string, []byte, []byte, []byte, *log.CommonLogger) error); ok {
		r1 = rf(hostHttpsAddr, username, password, certificate, clientCertificate, clientKey, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDefaultPoolInfoUsingScramSha provides a mock function with given fields: hostAddr, username, password, logger
func (_m *UtilsIface) GetDefaultPoolInfoUsingScramSha(hostAddr string, username string, password string, logger *log.CommonLogger) (map[string]interface{}, error) {
	ret := _m.Called(hostAddr, username, password, logger)

	var r0 map[string]interface{}
	if rf, ok := ret.Get(0).(func(string, string, string, *log.CommonLogger) map[string]interface{}); ok {
		r0 = rf(hostAddr, username, password, logger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]interface{})
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string, *log.CommonLogger) error); ok {
		r1 = rf(hostAddr, username, password, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetEvictionPolicyFromBucketInfo provides a mock function with given fields: bucketName, bucketInfo
func (_m *UtilsIface) GetEvictionPolicyFromBucketInfo(bucketName string, bucketInfo map[string]interface{}) (string, error) {
	ret := _m.Called(bucketName, bucketInfo)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, map[string]interface{}) string); ok {
		r0 = rf(bucketName, bucketInfo)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, map[string]interface{}) error); ok {
		r1 = rf(bucketName, bucketInfo)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetExternalAddressAndKvPortsFromNodeInfo provides a mock function with given fields: nodeInfo
func (_m *UtilsIface) GetExternalAddressAndKvPortsFromNodeInfo(nodeInfo map[string]interface{}) (string, int, error, int, error) {
	ret := _m.Called(nodeInfo)

	var r0 string
	if rf, ok := ret.Get(0).(func(map[string]interface{}) string); ok {
		r0 = rf(nodeInfo)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 int
	if rf, ok := ret.Get(1).(func(map[string]interface{}) int); ok {
		r1 = rf(nodeInfo)
	} else {
		r1 = ret.Get(1).(int)
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(map[string]interface{}) error); ok {
		r2 = rf(nodeInfo)
	} else {
		r2 = ret.Error(2)
	}

	var r3 int
	if rf, ok := ret.Get(3).(func(map[string]interface{}) int); ok {
		r3 = rf(nodeInfo)
	} else {
		r3 = ret.Get(3).(int)
	}

	var r4 error
	if rf, ok := ret.Get(4).(func(map[string]interface{}) error); ok {
		r4 = rf(nodeInfo)
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// GetExternalMgtHostAndPort provides a mock function with given fields: nodeInfo, isHttps
func (_m *UtilsIface) GetExternalMgtHostAndPort(nodeInfo map[string]interface{}, isHttps bool) (string, int, error) {
	ret := _m.Called(nodeInfo, isHttps)

	var r0 string
	if rf, ok := ret.Get(0).(func(map[string]interface{}, bool) string); ok {
		r0 = rf(nodeInfo, isHttps)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 int
	if rf, ok := ret.Get(1).(func(map[string]interface{}, bool) int); ok {
		r1 = rf(nodeInfo, isHttps)
	} else {
		r1 = ret.Get(1).(int)
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(map[string]interface{}, bool) error); ok {
		r2 = rf(nodeInfo, isHttps)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetHostAddrFromNodeInfo provides a mock function with given fields: adminHostAddr, nodeInfo, isHttps, logger, useExternal
func (_m *UtilsIface) GetHostAddrFromNodeInfo(adminHostAddr string, nodeInfo map[string]interface{}, isHttps bool, logger *log.CommonLogger, useExternal bool) (string, error) {
	ret := _m.Called(adminHostAddr, nodeInfo, isHttps, logger, useExternal)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, map[string]interface{}, bool, *log.CommonLogger, bool) string); ok {
		r0 = rf(adminHostAddr, nodeInfo, isHttps, logger, useExternal)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, map[string]interface{}, bool, *log.CommonLogger, bool) error); ok {
		r1 = rf(adminHostAddr, nodeInfo, isHttps, logger, useExternal)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetHostNameFromNodeInfo provides a mock function with given fields: adminHostAddr, nodeInfo, logger
func (_m *UtilsIface) GetHostNameFromNodeInfo(adminHostAddr string, nodeInfo map[string]interface{}, logger *log.CommonLogger) (string, error) {
	ret := _m.Called(adminHostAddr, nodeInfo, logger)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, map[string]interface{}, *log.CommonLogger) string); ok {
		r0 = rf(adminHostAddr, nodeInfo, logger)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, map[string]interface{}, *log.CommonLogger) error); ok {
		r1 = rf(adminHostAddr, nodeInfo, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetHttpClient provides a mock function with given fields: username, authMech, certificate, san_in_certificate, clientCertificate, clientKey, ssl_con_str, logger
func (_m *UtilsIface) GetHttpClient(username string, authMech base.HttpAuthMech, certificate []byte, san_in_certificate bool, clientCertificate []byte, clientKey []byte, ssl_con_str string, logger *log.CommonLogger) (*http.Client, error) {
	ret := _m.Called(username, authMech, certificate, san_in_certificate, clientCertificate, clientKey, ssl_con_str, logger)

	var r0 *http.Client
	if rf, ok := ret.Get(0).(func(string, base.HttpAuthMech, []byte, bool, []byte, []byte, string, *log.CommonLogger) *http.Client); ok {
		r0 = rf(username, authMech, certificate, san_in_certificate, clientCertificate, clientKey, ssl_con_str, logger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Client)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, base.HttpAuthMech, []byte, bool, []byte, []byte, string, *log.CommonLogger) error); ok {
		r1 = rf(username, authMech, certificate, san_in_certificate, clientCertificate, clientKey, ssl_con_str, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetIntExtHostNameKVPortTranslationMap provides a mock function with given fields: mapContainingNodesKey
func (_m *UtilsIface) GetIntExtHostNameKVPortTranslationMap(mapContainingNodesKey map[string]interface{}) (map[string]string, error) {
	ret := _m.Called(mapContainingNodesKey)

	var r0 map[string]string
	if rf, ok := ret.Get(0).(func(map[string]interface{}) map[string]string); ok {
		r0 = rf(mapContainingNodesKey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]string)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(map[string]interface{}) error); ok {
		r1 = rf(mapContainingNodesKey)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetIntSettingFromSettings provides a mock function with given fields: settings, settingName
func (_m *UtilsIface) GetIntSettingFromSettings(settings metadata.ReplicationSettingsMap, settingName string) (int, error) {
	ret := _m.Called(settings, settingName)

	var r0 int
	if rf, ok := ret.Get(0).(func(metadata.ReplicationSettingsMap, string) int); ok {
		r0 = rf(settings, settingName)
	} else {
		r0 = ret.Get(0).(int)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(metadata.ReplicationSettingsMap, string) error); ok {
		r1 = rf(settings, settingName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLocalBuckets provides a mock function with given fields: hostAddr, logger
func (_m *UtilsIface) GetLocalBuckets(hostAddr string, logger *log.CommonLogger) (map[string]string, error) {
	ret := _m.Called(hostAddr, logger)

	var r0 map[string]string
	if rf, ok := ret.Get(0).(func(string, *log.CommonLogger) map[string]string); ok {
		r0 = rf(hostAddr, logger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]string)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, *log.CommonLogger) error); ok {
		r1 = rf(hostAddr, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMapFromExpvarMap provides a mock function with given fields: expvarMap
func (_m *UtilsIface) GetMapFromExpvarMap(expvarMap *expvar.Map) map[string]interface{} {
	ret := _m.Called(expvarMap)

	var r0 map[string]interface{}
	if rf, ok := ret.Get(0).(func(*expvar.Map) map[string]interface{}); ok {
		r0 = rf(expvarMap)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]interface{})
		}
	}

	return r0
}

// GetMemcachedClient provides a mock function with given fields: serverAddr, bucketName, kv_mem_clients, userAgent, keepAlivePeriod, logger
func (_m *UtilsIface) GetMemcachedClient(serverAddr string, bucketName string, kv_mem_clients map[string]memcached.ClientIface, userAgent string, keepAlivePeriod time.Duration, logger *log.CommonLogger) (memcached.ClientIface, error) {
	ret := _m.Called(serverAddr, bucketName, kv_mem_clients, userAgent, keepAlivePeriod, logger)

	var r0 memcached.ClientIface
	if rf, ok := ret.Get(0).(func(string, string, map[string]memcached.ClientIface, string, time.Duration, *log.CommonLogger) memcached.ClientIface); ok {
		r0 = rf(serverAddr, bucketName, kv_mem_clients, userAgent, keepAlivePeriod, logger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(memcached.ClientIface)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, map[string]memcached.ClientIface, string, time.Duration, *log.CommonLogger) error); ok {
		r1 = rf(serverAddr, bucketName, kv_mem_clients, userAgent, keepAlivePeriod, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMemcachedConnection provides a mock function with given fields: serverAddr, bucketName, userAgent, keepAlivePeriod, logger
func (_m *UtilsIface) GetMemcachedConnection(serverAddr string, bucketName string, userAgent string, keepAlivePeriod time.Duration, logger *log.CommonLogger) (memcached.ClientIface, error) {
	ret := _m.Called(serverAddr, bucketName, userAgent, keepAlivePeriod, logger)

	var r0 memcached.ClientIface
	if rf, ok := ret.Get(0).(func(string, string, string, time.Duration, *log.CommonLogger) memcached.ClientIface); ok {
		r0 = rf(serverAddr, bucketName, userAgent, keepAlivePeriod, logger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(memcached.ClientIface)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string, time.Duration, *log.CommonLogger) error); ok {
		r1 = rf(serverAddr, bucketName, userAgent, keepAlivePeriod, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMemcachedConnectionWFeatures provides a mock function with given fields: serverAddr, bucketName, userAgent, keepAlivePeriod, features, logger
func (_m *UtilsIface) GetMemcachedConnectionWFeatures(serverAddr string, bucketName string, userAgent string, keepAlivePeriod time.Duration, features utils.HELOFeatures, logger *log.CommonLogger) (memcached.ClientIface, utils.HELOFeatures, error) {
	ret := _m.Called(serverAddr, bucketName, userAgent, keepAlivePeriod, features, logger)

	var r0 memcached.ClientIface
	if rf, ok := ret.Get(0).(func(string, string, string, time.Duration, utils.HELOFeatures, *log.CommonLogger) memcached.ClientIface); ok {
		r0 = rf(serverAddr, bucketName, userAgent, keepAlivePeriod, features, logger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(memcached.ClientIface)
		}
	}

	var r1 utils.HELOFeatures
	if rf, ok := ret.Get(1).(func(string, string, string, time.Duration, utils.HELOFeatures, *log.CommonLogger) utils.HELOFeatures); ok {
		r1 = rf(serverAddr, bucketName, userAgent, keepAlivePeriod, features, logger)
	} else {
		r1 = ret.Get(1).(utils.HELOFeatures)
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(string, string, string, time.Duration, utils.HELOFeatures, *log.CommonLogger) error); ok {
		r2 = rf(serverAddr, bucketName, userAgent, keepAlivePeriod, features, logger)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetMemcachedRawConn provides a mock function with given fields: serverAddr, username, password, bucketName, plainAuth, keepAlivePeriod, logger
func (_m *UtilsIface) GetMemcachedRawConn(serverAddr string, username string, password string, bucketName string, plainAuth bool, keepAlivePeriod time.Duration, logger *log.CommonLogger) (memcached.ClientIface, error) {
	ret := _m.Called(serverAddr, username, password, bucketName, plainAuth, keepAlivePeriod, logger)

	var r0 memcached.ClientIface
	if rf, ok := ret.Get(0).(func(string, string, string, string, bool, time.Duration, *log.CommonLogger) memcached.ClientIface); ok {
		r0 = rf(serverAddr, username, password, bucketName, plainAuth, keepAlivePeriod, logger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(memcached.ClientIface)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string, string, bool, time.Duration, *log.CommonLogger) error); ok {
		r1 = rf(serverAddr, username, password, bucketName, plainAuth, keepAlivePeriod, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMemcachedSSLPortMap provides a mock function with given fields: hostName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, bucket, logger, useExternal
func (_m *UtilsIface) GetMemcachedSSLPortMap(hostName string, username string, password string, authMech base.HttpAuthMech, certificate []byte, sanInCertificate bool, clientCertificate []byte, clientKey []byte, bucket string, logger *log.CommonLogger, useExternal bool) (base.SSLPortMap, error) {
	ret := _m.Called(hostName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, bucket, logger, useExternal)

	var r0 base.SSLPortMap
	if rf, ok := ret.Get(0).(func(string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, string, *log.CommonLogger, bool) base.SSLPortMap); ok {
		r0 = rf(hostName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, bucket, logger, useExternal)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(base.SSLPortMap)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, string, *log.CommonLogger, bool) error); ok {
		r1 = rf(hostName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, bucket, logger, useExternal)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetNodeListFromInfoMap provides a mock function with given fields: infoMap, logger
func (_m *UtilsIface) GetNodeListFromInfoMap(infoMap map[string]interface{}, logger *log.CommonLogger) ([]interface{}, error) {
	ret := _m.Called(infoMap, logger)

	var r0 []interface{}
	if rf, ok := ret.Get(0).(func(map[string]interface{}, *log.CommonLogger) []interface{}); ok {
		r0 = rf(infoMap, logger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]interface{})
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(map[string]interface{}, *log.CommonLogger) error); ok {
		r1 = rf(infoMap, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetNodeListWithFullInfo provides a mock function with given fields: hostAddr, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger
func (_m *UtilsIface) GetNodeListWithFullInfo(hostAddr string, username string, password string, authMech base.HttpAuthMech, certificate []byte, sanInCertificate bool, clientCertificate []byte, clientKey []byte, logger *log.CommonLogger) ([]interface{}, error) {
	ret := _m.Called(hostAddr, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)

	var r0 []interface{}
	if rf, ok := ret.Get(0).(func(string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) []interface{}); ok {
		r0 = rf(hostAddr, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]interface{})
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) error); ok {
		r1 = rf(hostAddr, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetNodeListWithMinInfo provides a mock function with given fields: hostAddr, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger
func (_m *UtilsIface) GetNodeListWithMinInfo(hostAddr string, username string, password string, authMech base.HttpAuthMech, certificate []byte, sanInCertificate bool, clientCertificate []byte, clientKey []byte, logger *log.CommonLogger) ([]interface{}, error) {
	ret := _m.Called(hostAddr, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)

	var r0 []interface{}
	if rf, ok := ret.Get(0).(func(string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) []interface{}); ok {
		r0 = rf(hostAddr, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]interface{})
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger) error); ok {
		r1 = rf(hostAddr, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetNonExistentBucketError provides a mock function with given fields:
func (_m *UtilsIface) GetNonExistentBucketError() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetRemoteMemcachedConnection provides a mock function with given fields: serverAddr, username, password, bucketName, userAgent, plainAuth, keepAlivePeriod, logger
func (_m *UtilsIface) GetRemoteMemcachedConnection(serverAddr string, username string, password string, bucketName string, userAgent string, plainAuth bool, keepAlivePeriod time.Duration, logger *log.CommonLogger) (memcached.ClientIface, error) {
	ret := _m.Called(serverAddr, username, password, bucketName, userAgent, plainAuth, keepAlivePeriod, logger)

	var r0 memcached.ClientIface
	if rf, ok := ret.Get(0).(func(string, string, string, string, string, bool, time.Duration, *log.CommonLogger) memcached.ClientIface); ok {
		r0 = rf(serverAddr, username, password, bucketName, userAgent, plainAuth, keepAlivePeriod, logger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(memcached.ClientIface)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string, string, string, bool, time.Duration, *log.CommonLogger) error); ok {
		r1 = rf(serverAddr, username, password, bucketName, userAgent, plainAuth, keepAlivePeriod, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRemoteMemcachedConnectionWFeatures provides a mock function with given fields: serverAddr, username, password, bucketName, userAgent, plainAuth, keepAlivePeriod, features, logger
func (_m *UtilsIface) GetRemoteMemcachedConnectionWFeatures(serverAddr string, username string, password string, bucketName string, userAgent string, plainAuth bool, keepAlivePeriod time.Duration, features utils.HELOFeatures, logger *log.CommonLogger) (memcached.ClientIface, utils.HELOFeatures, error) {
	ret := _m.Called(serverAddr, username, password, bucketName, userAgent, plainAuth, keepAlivePeriod, features, logger)

	var r0 memcached.ClientIface
	if rf, ok := ret.Get(0).(func(string, string, string, string, string, bool, time.Duration, utils.HELOFeatures, *log.CommonLogger) memcached.ClientIface); ok {
		r0 = rf(serverAddr, username, password, bucketName, userAgent, plainAuth, keepAlivePeriod, features, logger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(memcached.ClientIface)
		}
	}

	var r1 utils.HELOFeatures
	if rf, ok := ret.Get(1).(func(string, string, string, string, string, bool, time.Duration, utils.HELOFeatures, *log.CommonLogger) utils.HELOFeatures); ok {
		r1 = rf(serverAddr, username, password, bucketName, userAgent, plainAuth, keepAlivePeriod, features, logger)
	} else {
		r1 = ret.Get(1).(utils.HELOFeatures)
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(string, string, string, string, string, bool, time.Duration, utils.HELOFeatures, *log.CommonLogger) error); ok {
		r2 = rf(serverAddr, username, password, bucketName, userAgent, plainAuth, keepAlivePeriod, features, logger)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetRemoteNodeAddressesListFromNodeList provides a mock function with given fields: nodeList, connStr, needHttps, logger, useExternal
func (_m *UtilsIface) GetRemoteNodeAddressesListFromNodeList(nodeList []interface{}, connStr string, needHttps bool, logger *log.CommonLogger, useExternal bool) (base.StringPairList, error) {
	ret := _m.Called(nodeList, connStr, needHttps, logger, useExternal)

	var r0 base.StringPairList
	if rf, ok := ret.Get(0).(func([]interface{}, string, bool, *log.CommonLogger, bool) base.StringPairList); ok {
		r0 = rf(nodeList, connStr, needHttps, logger, useExternal)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(base.StringPairList)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([]interface{}, string, bool, *log.CommonLogger, bool) error); ok {
		r1 = rf(nodeList, connStr, needHttps, logger, useExternal)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRemoteSSLPorts provides a mock function with given fields: hostAddr, logger
func (_m *UtilsIface) GetRemoteSSLPorts(hostAddr string, logger *log.CommonLogger) (uint16, error, uint16, error) {
	ret := _m.Called(hostAddr, logger)

	var r0 uint16
	if rf, ok := ret.Get(0).(func(string, *log.CommonLogger) uint16); ok {
		r0 = rf(hostAddr, logger)
	} else {
		r0 = ret.Get(0).(uint16)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, *log.CommonLogger) error); ok {
		r1 = rf(hostAddr, logger)
	} else {
		r1 = ret.Error(1)
	}

	var r2 uint16
	if rf, ok := ret.Get(2).(func(string, *log.CommonLogger) uint16); ok {
		r2 = rf(hostAddr, logger)
	} else {
		r2 = ret.Get(2).(uint16)
	}

	var r3 error
	if rf, ok := ret.Get(3).(func(string, *log.CommonLogger) error); ok {
		r3 = rf(hostAddr, logger)
	} else {
		r3 = ret.Error(3)
	}

	return r0, r1, r2, r3
}

// GetRemoteServerVBucketsMap provides a mock function with given fields: connStr, bucketName, bucketInfo, useExternal
func (_m *UtilsIface) GetRemoteServerVBucketsMap(connStr string, bucketName string, bucketInfo map[string]interface{}, useExternal bool) (map[string][]uint16, error) {
	ret := _m.Called(connStr, bucketName, bucketInfo, useExternal)

	var r0 map[string][]uint16
	if rf, ok := ret.Get(0).(func(string, string, map[string]interface{}, bool) map[string][]uint16); ok {
		r0 = rf(connStr, bucketName, bucketInfo, useExternal)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string][]uint16)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, map[string]interface{}, bool) error); ok {
		r1 = rf(connStr, bucketName, bucketInfo, useExternal)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSecuritySettingsAndDefaultPoolInfo provides a mock function with given fields: hostAddr, hostHttpsAddr, username, password, certificate, clientCertificate, clientKey, scramShaEnabled, logger
func (_m *UtilsIface) GetSecuritySettingsAndDefaultPoolInfo(hostAddr string, hostHttpsAddr string, username string, password string, certificate []byte, clientCertificate []byte, clientKey []byte, scramShaEnabled bool, logger *log.CommonLogger) (bool, base.HttpAuthMech, map[string]interface{}, error) {
	ret := _m.Called(hostAddr, hostHttpsAddr, username, password, certificate, clientCertificate, clientKey, scramShaEnabled, logger)

	var r0 bool
	if rf, ok := ret.Get(0).(func(string, string, string, string, []byte, []byte, []byte, bool, *log.CommonLogger) bool); ok {
		r0 = rf(hostAddr, hostHttpsAddr, username, password, certificate, clientCertificate, clientKey, scramShaEnabled, logger)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 base.HttpAuthMech
	if rf, ok := ret.Get(1).(func(string, string, string, string, []byte, []byte, []byte, bool, *log.CommonLogger) base.HttpAuthMech); ok {
		r1 = rf(hostAddr, hostHttpsAddr, username, password, certificate, clientCertificate, clientKey, scramShaEnabled, logger)
	} else {
		r1 = ret.Get(1).(base.HttpAuthMech)
	}

	var r2 map[string]interface{}
	if rf, ok := ret.Get(2).(func(string, string, string, string, []byte, []byte, []byte, bool, *log.CommonLogger) map[string]interface{}); ok {
		r2 = rf(hostAddr, hostHttpsAddr, username, password, certificate, clientCertificate, clientKey, scramShaEnabled, logger)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).(map[string]interface{})
		}
	}

	var r3 error
	if rf, ok := ret.Get(3).(func(string, string, string, string, []byte, []byte, []byte, bool, *log.CommonLogger) error); ok {
		r3 = rf(hostAddr, hostHttpsAddr, username, password, certificate, clientCertificate, clientKey, scramShaEnabled, logger)
	} else {
		r3 = ret.Error(3)
	}

	return r0, r1, r2, r3
}

// GetServerVBucketsMap provides a mock function with given fields: connStr, bucketName, bucketInfo
func (_m *UtilsIface) GetServerVBucketsMap(connStr string, bucketName string, bucketInfo map[string]interface{}) (map[string][]uint16, error) {
	ret := _m.Called(connStr, bucketName, bucketInfo)

	var r0 map[string][]uint16
	if rf, ok := ret.Get(0).(func(string, string, map[string]interface{}) map[string][]uint16); ok {
		r0 = rf(connStr, bucketName, bucketInfo)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string][]uint16)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, map[string]interface{}) error); ok {
		r1 = rf(connStr, bucketName, bucketInfo)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSettingFromSettings provides a mock function with given fields: settings, settingName
func (_m *UtilsIface) GetSettingFromSettings(settings metadata.ReplicationSettingsMap, settingName string) interface{} {
	ret := _m.Called(settings, settingName)

	var r0 interface{}
	if rf, ok := ret.Get(0).(func(metadata.ReplicationSettingsMap, string) interface{}); ok {
		r0 = rf(settings, settingName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	return r0
}

// GetStringSettingFromSettings provides a mock function with given fields: settings, settingName
func (_m *UtilsIface) GetStringSettingFromSettings(settings metadata.ReplicationSettingsMap, settingName string) (string, error) {
	ret := _m.Called(settings, settingName)

	var r0 string
	if rf, ok := ret.Get(0).(func(metadata.ReplicationSettingsMap, string) string); ok {
		r0 = rf(settings, settingName)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(metadata.ReplicationSettingsMap, string) error); ok {
		r1 = rf(settings, settingName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HttpsRemoteHostAddr provides a mock function with given fields: hostAddr, logger
func (_m *UtilsIface) HttpsRemoteHostAddr(hostAddr string, logger *log.CommonLogger) (string, string, error) {
	ret := _m.Called(hostAddr, logger)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, *log.CommonLogger) string); ok {
		r0 = rf(hostAddr, logger)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 string
	if rf, ok := ret.Get(1).(func(string, *log.CommonLogger) string); ok {
		r1 = rf(hostAddr, logger)
	} else {
		r1 = ret.Get(1).(string)
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(string, *log.CommonLogger) error); ok {
		r2 = rf(hostAddr, logger)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// InvalidRuneIndexErrorMessage provides a mock function with given fields: key, index
func (_m *UtilsIface) InvalidRuneIndexErrorMessage(key string, index int) string {
	ret := _m.Called(key, index)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, int) string); ok {
		r0 = rf(key, index)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// InvokeRestWithRetry provides a mock function with given fields: baseURL, path, preservePathEncoding, httpCommand, contentType, body, timeout, out, client, keep_client_alive, logger, num_retry
func (_m *UtilsIface) InvokeRestWithRetry(baseURL string, path string, preservePathEncoding bool, httpCommand string, contentType string, body []byte, timeout time.Duration, out interface{}, client *http.Client, keep_client_alive bool, logger *log.CommonLogger, num_retry int) (error, int) {
	ret := _m.Called(baseURL, path, preservePathEncoding, httpCommand, contentType, body, timeout, out, client, keep_client_alive, logger, num_retry)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, bool, string, string, []byte, time.Duration, interface{}, *http.Client, bool, *log.CommonLogger, int) error); ok {
		r0 = rf(baseURL, path, preservePathEncoding, httpCommand, contentType, body, timeout, out, client, keep_client_alive, logger, num_retry)
	} else {
		r0 = ret.Error(0)
	}

	var r1 int
	if rf, ok := ret.Get(1).(func(string, string, bool, string, string, []byte, time.Duration, interface{}, *http.Client, bool, *log.CommonLogger, int) int); ok {
		r1 = rf(baseURL, path, preservePathEncoding, httpCommand, contentType, body, timeout, out, client, keep_client_alive, logger, num_retry)
	} else {
		r1 = ret.Get(1).(int)
	}

	return r0, r1
}

// InvokeRestWithRetryWithAuth provides a mock function with given fields: baseURL, path, preservePathEncoding, username, password, authMech, certificate, san_in_certificate, clientCertificate, clientKey, insecureSkipVerify, httpCommand, contentType, body, timeout, out, client, keep_client_alive, logger, num_retry
func (_m *UtilsIface) InvokeRestWithRetryWithAuth(baseURL string, path string, preservePathEncoding bool, username string, password string, authMech base.HttpAuthMech, certificate []byte, san_in_certificate bool, clientCertificate []byte, clientKey []byte, insecureSkipVerify bool, httpCommand string, contentType string, body []byte, timeout time.Duration, out interface{}, client *http.Client, keep_client_alive bool, logger *log.CommonLogger, num_retry int) (error, int) {
	ret := _m.Called(baseURL, path, preservePathEncoding, username, password, authMech, certificate, san_in_certificate, clientCertificate, clientKey, insecureSkipVerify, httpCommand, contentType, body, timeout, out, client, keep_client_alive, logger, num_retry)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, bool, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, bool, string, string, []byte, time.Duration, interface{}, *http.Client, bool, *log.CommonLogger, int) error); ok {
		r0 = rf(baseURL, path, preservePathEncoding, username, password, authMech, certificate, san_in_certificate, clientCertificate, clientKey, insecureSkipVerify, httpCommand, contentType, body, timeout, out, client, keep_client_alive, logger, num_retry)
	} else {
		r0 = ret.Error(0)
	}

	var r1 int
	if rf, ok := ret.Get(1).(func(string, string, bool, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, bool, string, string, []byte, time.Duration, interface{}, *http.Client, bool, *log.CommonLogger, int) int); ok {
		r1 = rf(baseURL, path, preservePathEncoding, username, password, authMech, certificate, san_in_certificate, clientCertificate, clientKey, insecureSkipVerify, httpCommand, contentType, body, timeout, out, client, keep_client_alive, logger, num_retry)
	} else {
		r1 = ret.Get(1).(int)
	}

	return r0, r1
}

// IsSeriousNetError provides a mock function with given fields: err
func (_m *UtilsIface) IsSeriousNetError(err error) bool {
	ret := _m.Called(err)

	var r0 bool
	if rf, ok := ret.Get(0).(func(error) bool); ok {
		r0 = rf(err)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// LocalBucket provides a mock function with given fields: localConnectStr, bucketName
func (_m *UtilsIface) LocalBucket(localConnectStr string, bucketName string) (*couchbase.Bucket, error) {
	ret := _m.Called(localConnectStr, bucketName)

	var r0 *couchbase.Bucket
	if rf, ok := ret.Get(0).(func(string, string) *couchbase.Bucket); ok {
		r0 = rf(localConnectStr, bucketName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*couchbase.Bucket)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(localConnectStr, bucketName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LocalBucketPassword provides a mock function with given fields: local_connStr, bucketName, logger
func (_m *UtilsIface) LocalBucketPassword(local_connStr string, bucketName string, logger *log.CommonLogger) (string, error) {
	ret := _m.Called(local_connStr, bucketName, logger)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, string, *log.CommonLogger) string); ok {
		r0 = rf(local_connStr, bucketName, logger)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, *log.CommonLogger) error); ok {
		r1 = rf(local_connStr, bucketName, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LocalBucketUUID provides a mock function with given fields: local_connStr, bucketName, logger
func (_m *UtilsIface) LocalBucketUUID(local_connStr string, bucketName string, logger *log.CommonLogger) (string, error) {
	ret := _m.Called(local_connStr, bucketName, logger)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, string, *log.CommonLogger) string); ok {
		r0 = rf(local_connStr, bucketName, logger)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, *log.CommonLogger) error); ok {
		r1 = rf(local_connStr, bucketName, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LocalPool provides a mock function with given fields: localConnectStr
func (_m *UtilsIface) LocalPool(localConnectStr string) (couchbase.Pool, error) {
	ret := _m.Called(localConnectStr)

	var r0 couchbase.Pool
	if rf, ok := ret.Get(0).(func(string) couchbase.Pool); ok {
		r0 = rf(localConnectStr)
	} else {
		r0 = ret.Get(0).(couchbase.Pool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(localConnectStr)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewEnhancedError provides a mock function with given fields: msg, err
func (_m *UtilsIface) NewEnhancedError(msg string, err error) error {
	ret := _m.Called(msg, err)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, error) error); ok {
		r0 = rf(msg, err)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NewTCPConn provides a mock function with given fields: hostName
func (_m *UtilsIface) NewTCPConn(hostName string) (*net.TCPConn, error) {
	ret := _m.Called(hostName)

	var r0 *net.TCPConn
	if rf, ok := ret.Get(0).(func(string) *net.TCPConn); ok {
		r0 = rf(hostName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*net.TCPConn)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(hostName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseHighSeqnoAndVBUuidFromStats provides a mock function with given fields: vbnos, stats_map, high_seqno_and_vbuuid_map
func (_m *UtilsIface) ParseHighSeqnoAndVBUuidFromStats(vbnos []uint16, stats_map map[string]string, high_seqno_and_vbuuid_map map[uint16][]uint64) {
	_m.Called(vbnos, stats_map, high_seqno_and_vbuuid_map)
}

// ParseHighSeqnoStat provides a mock function with given fields: vbnos, stats_map, highseqno_map
func (_m *UtilsIface) ParseHighSeqnoStat(vbnos []uint16, stats_map map[string]string, highseqno_map map[uint16]uint64) error {
	ret := _m.Called(vbnos, stats_map, highseqno_map)

	var r0 error
	if rf, ok := ret.Get(0).(func([]uint16, map[string]string, map[uint16]uint64) error); ok {
		r0 = rf(vbnos, stats_map, highseqno_map)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ProcessUprEventForFiltering provides a mock function with given fields: uprEvent, body, endBodyPos, dp, flags, slicesBuf
func (_m *UtilsIface) ProcessUprEventForFiltering(uprEvent *memcached.UprEvent, body []byte, endBodyPos int, dp utils.DataPoolIface, flags base.FilterFlagType, slicesBuf *[][]byte) ([]byte, error, string, int64) {
	ret := _m.Called(uprEvent, body, endBodyPos, dp, flags, slicesBuf)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(*memcached.UprEvent, []byte, int, utils.DataPoolIface, base.FilterFlagType, *[][]byte) []byte); ok {
		r0 = rf(uprEvent, body, endBodyPos, dp, flags, slicesBuf)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*memcached.UprEvent, []byte, int, utils.DataPoolIface, base.FilterFlagType, *[][]byte) error); ok {
		r1 = rf(uprEvent, body, endBodyPos, dp, flags, slicesBuf)
	} else {
		r1 = ret.Error(1)
	}

	var r2 string
	if rf, ok := ret.Get(2).(func(*memcached.UprEvent, []byte, int, utils.DataPoolIface, base.FilterFlagType, *[][]byte) string); ok {
		r2 = rf(uprEvent, body, endBodyPos, dp, flags, slicesBuf)
	} else {
		r2 = ret.Get(2).(string)
	}

	var r3 int64
	if rf, ok := ret.Get(3).(func(*memcached.UprEvent, []byte, int, utils.DataPoolIface, base.FilterFlagType, *[][]byte) int64); ok {
		r3 = rf(uprEvent, body, endBodyPos, dp, flags, slicesBuf)
	} else {
		r3 = ret.Get(3).(int64)
	}

	return r0, r1, r2, r3
}

// QueryRestApi provides a mock function with given fields: baseURL, path, preservePathEncoding, httpCommand, contentType, body, timeout, out, logger
func (_m *UtilsIface) QueryRestApi(baseURL string, path string, preservePathEncoding bool, httpCommand string, contentType string, body []byte, timeout time.Duration, out interface{}, logger *log.CommonLogger) (error, int) {
	ret := _m.Called(baseURL, path, preservePathEncoding, httpCommand, contentType, body, timeout, out, logger)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, bool, string, string, []byte, time.Duration, interface{}, *log.CommonLogger) error); ok {
		r0 = rf(baseURL, path, preservePathEncoding, httpCommand, contentType, body, timeout, out, logger)
	} else {
		r0 = ret.Error(0)
	}

	var r1 int
	if rf, ok := ret.Get(1).(func(string, string, bool, string, string, []byte, time.Duration, interface{}, *log.CommonLogger) int); ok {
		r1 = rf(baseURL, path, preservePathEncoding, httpCommand, contentType, body, timeout, out, logger)
	} else {
		r1 = ret.Get(1).(int)
	}

	return r0, r1
}

// QueryRestApiWithAuth provides a mock function with given fields: baseURL, path, preservePathEncoding, username, password, authMech, certificate, san_in_certificate, clientCertificate, clientKey, httpCommand, contentType, body, timeout, out, client, keep_client_alive, logger
func (_m *UtilsIface) QueryRestApiWithAuth(baseURL string, path string, preservePathEncoding bool, username string, password string, authMech base.HttpAuthMech, certificate []byte, san_in_certificate bool, clientCertificate []byte, clientKey []byte, httpCommand string, contentType string, body []byte, timeout time.Duration, out interface{}, client *http.Client, keep_client_alive bool, logger *log.CommonLogger) (error, int) {
	ret := _m.Called(baseURL, path, preservePathEncoding, username, password, authMech, certificate, san_in_certificate, clientCertificate, clientKey, httpCommand, contentType, body, timeout, out, client, keep_client_alive, logger)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, bool, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, string, string, []byte, time.Duration, interface{}, *http.Client, bool, *log.CommonLogger) error); ok {
		r0 = rf(baseURL, path, preservePathEncoding, username, password, authMech, certificate, san_in_certificate, clientCertificate, clientKey, httpCommand, contentType, body, timeout, out, client, keep_client_alive, logger)
	} else {
		r0 = ret.Error(0)
	}

	var r1 int
	if rf, ok := ret.Get(1).(func(string, string, bool, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, string, string, []byte, time.Duration, interface{}, *http.Client, bool, *log.CommonLogger) int); ok {
		r1 = rf(baseURL, path, preservePathEncoding, username, password, authMech, certificate, san_in_certificate, clientCertificate, clientKey, httpCommand, contentType, body, timeout, out, client, keep_client_alive, logger)
	} else {
		r1 = ret.Get(1).(int)
	}

	return r0, r1
}

// RecoverPanic provides a mock function with given fields: err
func (_m *UtilsIface) RecoverPanic(err *error) {
	_m.Called(err)
}

// RemoteBucketValidationInfo provides a mock function with given fields: hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger, useExternal
func (_m *UtilsIface) RemoteBucketValidationInfo(hostAddr string, bucketName string, username string, password string, authMech base.HttpAuthMech, certificate []byte, sanInCertificate bool, clientCertificate []byte, clientKey []byte, logger *log.CommonLogger, useExternal bool) (map[string]interface{}, string, string, string, string, map[string][]uint16, error) {
	ret := _m.Called(hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger, useExternal)

	var r0 map[string]interface{}
	if rf, ok := ret.Get(0).(func(string, string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger, bool) map[string]interface{}); ok {
		r0 = rf(hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger, useExternal)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]interface{})
		}
	}

	var r1 string
	if rf, ok := ret.Get(1).(func(string, string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger, bool) string); ok {
		r1 = rf(hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger, useExternal)
	} else {
		r1 = ret.Get(1).(string)
	}

	var r2 string
	if rf, ok := ret.Get(2).(func(string, string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger, bool) string); ok {
		r2 = rf(hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger, useExternal)
	} else {
		r2 = ret.Get(2).(string)
	}

	var r3 string
	if rf, ok := ret.Get(3).(func(string, string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger, bool) string); ok {
		r3 = rf(hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger, useExternal)
	} else {
		r3 = ret.Get(3).(string)
	}

	var r4 string
	if rf, ok := ret.Get(4).(func(string, string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger, bool) string); ok {
		r4 = rf(hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger, useExternal)
	} else {
		r4 = ret.Get(4).(string)
	}

	var r5 map[string][]uint16
	if rf, ok := ret.Get(5).(func(string, string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger, bool) map[string][]uint16); ok {
		r5 = rf(hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger, useExternal)
	} else {
		if ret.Get(5) != nil {
			r5 = ret.Get(5).(map[string][]uint16)
		}
	}

	var r6 error
	if rf, ok := ret.Get(6).(func(string, string, string, string, base.HttpAuthMech, []byte, bool, []byte, []byte, *log.CommonLogger, bool) error); ok {
		r6 = rf(hostAddr, bucketName, username, password, authMech, certificate, sanInCertificate, clientCertificate, clientKey, logger, useExternal)
	} else {
		r6 = ret.Error(6)
	}

	return r0, r1, r2, r3, r4, r5, r6
}

// RemovePrefix provides a mock function with given fields: prefix, str
func (_m *UtilsIface) RemovePrefix(prefix string, str string) string {
	ret := _m.Called(prefix, str)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, string) string); ok {
		r0 = rf(prefix, str)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// ReplaceCouchApiBaseObjWithExternals provides a mock function with given fields: couchApiBase, nodeInfo
func (_m *UtilsIface) ReplaceCouchApiBaseObjWithExternals(couchApiBase string, nodeInfo map[string]interface{}) string {
	ret := _m.Called(couchApiBase, nodeInfo)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, map[string]interface{}) string); ok {
		r0 = rf(couchApiBase, nodeInfo)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// ReplicationStatusNotFoundError provides a mock function with given fields: topic
func (_m *UtilsIface) ReplicationStatusNotFoundError(topic string) error {
	ret := _m.Called(topic)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(topic)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SendHELO provides a mock function with given fields: client, userAgent, readTimeout, writeTimeout, logger
func (_m *UtilsIface) SendHELO(client memcached.ClientIface, userAgent string, readTimeout time.Duration, writeTimeout time.Duration, logger *log.CommonLogger) error {
	ret := _m.Called(client, userAgent, readTimeout, writeTimeout, logger)

	var r0 error
	if rf, ok := ret.Get(0).(func(memcached.ClientIface, string, time.Duration, time.Duration, *log.CommonLogger) error); ok {
		r0 = rf(client, userAgent, readTimeout, writeTimeout, logger)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SendHELOWithFeatures provides a mock function with given fields: client, userAgent, readTimeout, writeTimeout, requestedFeatures, logger
func (_m *UtilsIface) SendHELOWithFeatures(client memcached.ClientIface, userAgent string, readTimeout time.Duration, writeTimeout time.Duration, requestedFeatures utils.HELOFeatures, logger *log.CommonLogger) (utils.HELOFeatures, error) {
	ret := _m.Called(client, userAgent, readTimeout, writeTimeout, requestedFeatures, logger)

	var r0 utils.HELOFeatures
	if rf, ok := ret.Get(0).(func(memcached.ClientIface, string, time.Duration, time.Duration, utils.HELOFeatures, *log.CommonLogger) utils.HELOFeatures); ok {
		r0 = rf(client, userAgent, readTimeout, writeTimeout, requestedFeatures, logger)
	} else {
		r0 = ret.Get(0).(utils.HELOFeatures)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(memcached.ClientIface, string, time.Duration, time.Duration, utils.HELOFeatures, *log.CommonLogger) error); ok {
		r1 = rf(client, userAgent, readTimeout, writeTimeout, requestedFeatures, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TranslateKvVbMap provides a mock function with given fields: kvVBMap, targetBucketInfo
func (_m *UtilsIface) TranslateKvVbMap(kvVBMap base.BucketKVVbMap, targetBucketInfo map[string]interface{}) {
	_m.Called(kvVBMap, targetBucketInfo)
}

// UnwrapError provides a mock function with given fields: infos
func (_m *UtilsIface) UnwrapError(infos map[string]interface{}) error {
	ret := _m.Called(infos)

	var r0 error
	if rf, ok := ret.Get(0).(func(map[string]interface{}) error); ok {
		r0 = rf(infos)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UrlForLog provides a mock function with given fields: urlStr
func (_m *UtilsIface) UrlForLog(urlStr string) string {
	ret := _m.Called(urlStr)

	var r0 string
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(urlStr)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// ValidateSettings provides a mock function with given fields: defs, settings, logger
func (_m *UtilsIface) ValidateSettings(defs base.SettingDefinitions, settings metadata.ReplicationSettingsMap, logger *log.CommonLogger) error {
	ret := _m.Called(defs, settings, logger)

	var r0 error
	if rf, ok := ret.Get(0).(func(base.SettingDefinitions, metadata.ReplicationSettingsMap, *log.CommonLogger) error); ok {
		r0 = rf(defs, settings, logger)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// VerifyTargetBucket provides a mock function with given fields: targetBucketName, targetBucketUuid, remoteClusterRef, logger
func (_m *UtilsIface) VerifyTargetBucket(targetBucketName string, targetBucketUuid string, remoteClusterRef *metadata.RemoteClusterReference, logger *log.CommonLogger) error {
	ret := _m.Called(targetBucketName, targetBucketUuid, remoteClusterRef, logger)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, *metadata.RemoteClusterReference, *log.CommonLogger) error); ok {
		r0 = rf(targetBucketName, targetBucketUuid, remoteClusterRef, logger)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}
